<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>WaveMult · WaveletsExt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">WaveletsExt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/transforms/">Transforms</a></li><li><a class="tocitem" href="../../manual/bestbasis/">Best Basis</a></li><li><a class="tocitem" href="../../manual/denoising/">Denoising</a></li><li><a class="tocitem" href="../../manual/localdiscriminantbasis/">Local Discriminant Basis</a></li><li><a class="tocitem" href="../../manual/wavemult/">Wavelets and Fast Numerical Algorithms</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../dwt/">DWT</a></li><li><a class="tocitem" href="../acwt/">ACWT</a></li><li><a class="tocitem" href="../swt/">SWT</a></li><li><a class="tocitem" href="../siwt/">SIWT</a></li><li class="is-active"><a class="tocitem" href>WaveMult</a><ul class="internal"><li><a class="tocitem" href="#Wavelet-Multiplication"><span>Wavelet Multiplication</span></a></li><li><a class="tocitem" href="#Matrix-to-Sparse-Format"><span>Matrix to Sparse Format</span></a></li><li><a class="tocitem" href="#Fast-Transform-Algorithms"><span>Fast Transform Algorithms</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li><li><a class="tocitem" href="../bestbasis/">Best Basis</a></li><li><a class="tocitem" href="../denoising/">Denoising</a></li><li><a class="tocitem" href="../ldb/">LDB</a></li><li><a class="tocitem" href="../utils/">Utils</a></li><li><a class="tocitem" href="../visualizations/">Visualizations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>WaveMult</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>WaveMult</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/master/docs/src/api/wavemult.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#WaveletsExt.WaveMult.dyadlength"><code>WaveletsExt.WaveMult.dyadlength</code></a></li><li><a href="#WaveletsExt.WaveMult.isft"><code>WaveletsExt.WaveMult.isft</code></a></li><li><a href="#WaveletsExt.WaveMult.mat2sparseform_nonstd"><code>WaveletsExt.WaveMult.mat2sparseform_nonstd</code></a></li><li><a href="#WaveletsExt.WaveMult.mat2sparseform_std"><code>WaveletsExt.WaveMult.mat2sparseform_std</code></a></li><li><a href="#WaveletsExt.WaveMult.ndyad"><code>WaveletsExt.WaveMult.ndyad</code></a></li><li><a href="#WaveletsExt.WaveMult.nonstd_wavemult"><code>WaveletsExt.WaveMult.nonstd_wavemult</code></a></li><li><a href="#WaveletsExt.WaveMult.ns_dwt"><code>WaveletsExt.WaveMult.ns_dwt</code></a></li><li><a href="#WaveletsExt.WaveMult.ns_idwt"><code>WaveletsExt.WaveMult.ns_idwt</code></a></li><li><a href="#WaveletsExt.WaveMult.sft"><code>WaveletsExt.WaveMult.sft</code></a></li><li><a href="#WaveletsExt.WaveMult.std_wavemult"><code>WaveletsExt.WaveMult.std_wavemult</code></a></li><li><a href="#WaveletsExt.WaveMult.stretchmatrix"><code>WaveletsExt.WaveMult.stretchmatrix</code></a></li></ul><h2 id="Wavelet-Multiplication"><a class="docs-heading-anchor" href="#Wavelet-Multiplication">Wavelet Multiplication</a><a id="Wavelet-Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Wavelet-Multiplication" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.nonstd_wavemult" href="#WaveletsExt.WaveMult.nonstd_wavemult"><code>WaveletsExt.WaveMult.nonstd_wavemult</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonstd_wavemult(M, x, wt, [L], [ϵ])
nonstd_wavemult(NM, x, wt, [L])</code></pre><p>If <code>M</code> is an <span>$n$</span> by <span>$n$</span> matrix, there are two ways to compute <span>$y = Mx$</span>. The first is to use the standard matrix multiplication to compute the product. This algorithm works in order of <span>$O(n^2)$</span>, where <span>$n$</span> is the length of <code>x</code>.</p><p>The second is to transform both the matrix and vector to their nonstandard forms and multiply the nonstandard forms. If the matrix is sparse in nonstandard form, this can be an order <span>$O(n)$</span> algorithm.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>One may choose to use the original matrix <code>M</code> as input by doing <code>nonstd_wavemult(M, x, wt, [L], [ϵ])</code>. However, if the nonstandard form sparse matrix <code>NM</code> is already computed prior, one can skip the redundant step by doing <code>nonstd_wavemult(NM, x, wt, [L])</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>M::AbstractVector{T} where T&lt;:AbstractFloat</code>: <span>$n$</span> by <span>$n$</span> matrix.</li><li><code>NM::SparseMatrixCSC{T,S} where {T&lt;:AbstractFloat, S&lt;:Integer}</code>: Nonstandard transformed sparse matrix of <code>M</code>.</li><li><code>x::AbstractVector{T} where T&lt;:AbstractFloat</code>: Vector of length <span>$n$</span> in natural basis.</li><li><code>wt::OrthoFilter</code>: Type of wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of decomposition levels.</li><li><code>ϵ::T where T&lt;:AbstractFloat</code>: (Default: <code>1e-4</code>) Truncation criterion for nonstandard transform of <code>M</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>y::Vector{T}</code>: Standard approximation of <span>$Mx$</span>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Wavelets, WaveletsExt

julia&gt; M = randn(4,4); x = randn(4); wt = wavelet(WT.haar);

julia&gt; NM = mat2sparseform_nonstd(M, wt); y₀ = nonstd_wavemult(NM, x, wt)
4-element Vector{Float64}:
 -1.2590015844047044
 -1.3234024176418535
  2.1158027198405627
  1.5364835417087566

julia&gt; y₁ = nonstd_wavemult(M, x, wt)
4-element Vector{Float64}:
 -1.2590015844047044
 -1.3234024176418535
  2.1158027198405627
  1.5364835417087566

julia&gt; y₀ == y₁                     # Both methods are equivalent
true</code></pre><p>**See also:* <a href="#WaveletsExt.WaveMult.std_wavemult"><code>std_wavemult</code></a>, <a href="#WaveletsExt.WaveMult.mat2sparseform_nonstd"><code>mat2sparseform_nonstd</code></a>, <a href="#WaveletsExt.WaveMult.ns_dwt"><code>ns_dwt</code></a>, <a href="#WaveletsExt.WaveMult.ns_idwt"><code>ns_idwt</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/wavemult.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.std_wavemult" href="#WaveletsExt.WaveMult.std_wavemult"><code>WaveletsExt.WaveMult.std_wavemult</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">std_wavemult(M, x, wt, [L], [ϵ])
std_wavemult(SM, x, wt, [L])</code></pre><p>If <code>M</code> is an <span>$n$</span> by <span>$n$</span> matrix, there are two ways to compute <span>$y = Mx$</span>. The first is to use the standard matrix multiplication to compute the product. This algorithm works in order of <span>$O(n^2)$</span>, where <span>$n$</span> is the length of <code>x</code>.</p><p>The second is to transform both the matrix and vector to their standard forms and multiply the standard forms. If the matrix is sparse in standard form, this can be an order <span>$O(n)$</span> algorithm.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>One may choose to use the original matrix <code>M</code> as input by doing <code>std_wavemult(M, x, wt, [L], [ϵ])</code>. However, if the standard form sparse matrix <code>SM</code> is already computed prior, one can skip the redundant step by doing <code>std_wavemult(SM, x, wt, [L])</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>M::AbstractVector{T} where T&lt;:AbstractFloat</code>: <span>$n$</span> by <span>$n$</span> matrix.</li><li><code>NM::SparseMatrixCSC{T,S} where {T&lt;:AbstractFloat, S&lt;:Integer}</code>: Standard transformed sparse matrix of <code>M</code>.</li><li><code>x::AbstractVector{T} where T&lt;:AbstractFloat</code>: Vector of length <span>$n$</span> in natural basis.</li><li><code>wt::OrthoFilter</code>: Type of wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of decomposition levels.</li><li><code>ϵ::T where T&lt;:AbstractFloat</code>: (Default: <code>1e-4</code>) Truncation criterion for standard transform of <code>M</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>y::Vector{T}</code>: Standard form approximation of <span>$Mx$</span>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Wavelets, WaveletsExt

julia&gt; M = randn(4,4); x = randn(4); wt = wavelet(WT.haar);

julia&gt; SM = mat2sparseform_std(M, wt); y₀ = std_wavemult(SM, x, wt)
4-element Vector{Float64}:
  2.2303830532617344
 -0.12704611958926648
  2.656411941014368
 -4.811388406857621

julia&gt; y₁ = std_wavemult(M, x, wt)
4-element Vector{Float64}:
  2.2303830532617344
 -0.12704611958926648
  2.656411941014368
 -4.811388406857621

julia&gt; y₀ == y₁
true</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.nonstd_wavemult"><code>nonstd_wavemult</code></a>, <a href="#WaveletsExt.WaveMult.mat2sparseform_std"><code>mat2sparseform_std</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/wavemult.jl#L78-L133">source</a></section></article><h2 id="Matrix-to-Sparse-Format"><a class="docs-heading-anchor" href="#Matrix-to-Sparse-Format">Matrix to Sparse Format</a><a id="Matrix-to-Sparse-Format-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-to-Sparse-Format" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.mat2sparseform_nonstd" href="#WaveletsExt.WaveMult.mat2sparseform_nonstd"><code>WaveletsExt.WaveMult.mat2sparseform_nonstd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mat2sparseform_nonstd(M, wt, [L], [ϵ])</code></pre><p>Transform the matrix <code>M</code> into the wavelet basis. Then, it is stretched into its nonstandard form. Elements exceeding <code>ϵ * maximum column norm</code> are set to zero. The resulting output sparse matrix, and can be used as input to <code>nonstd_wavemult</code>.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix{T} where T&lt;:AbstractFloat</code>: <code>n</code> by <code>n</code> matrix (<code>n</code> dyadic) to be put in Sparse Nonstandard form. </li><li><code>wt::OrthoFilter</code>: Wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(M)</code>) Number of decomposition levels.</li><li><code>ϵ::T where T&lt;:AbstractFloat</code>: (Default: <code>1e-4</code>) Truncation Criterion.</li></ul><p><strong>Returns</strong></p><ul><li><code>NM::SparseMatrixCSC{T, Integer}</code>: Sparse nonstandard form of matrix of size 2n x 2n.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Wavelets, WaveletsExt; import Random: seed!

julia&gt; seed!(1234); M = randn(4,4); wt = wavelet(WT.haar);

julia&gt; mat2sparseform_nonstd(M, wt)
8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
 1.88685   ⋅    ⋅         ⋅          ⋅         ⋅         ⋅          ⋅
  ⋅        ⋅    ⋅         ⋅          ⋅         ⋅         ⋅          ⋅
  ⋅        ⋅    ⋅        0.363656    ⋅         ⋅         ⋅          ⋅
  ⋅        ⋅   2.49634  -1.08139     ⋅         ⋅         ⋅          ⋅
  ⋅        ⋅    ⋅         ⋅          ⋅         ⋅       -1.0187     0.539411
  ⋅        ⋅    ⋅         ⋅          ⋅         ⋅        1.68141    0.0351839
  ⋅        ⋅    ⋅         ⋅        -1.39713  -1.21352   0.552745   0.427717
  ⋅        ⋅    ⋅         ⋅        -1.05882   0.16666  -0.124156  -0.218902</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.mat2sparseform_std"><code>mat2sparseform_std</code></a>, <a href="#WaveletsExt.WaveMult.stretchmatrix"><code>stretchmatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/mat2sparse.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.mat2sparseform_std" href="#WaveletsExt.WaveMult.mat2sparseform_std"><code>WaveletsExt.WaveMult.mat2sparseform_std</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mat2sparseform_std(M, wt, [L], [ϵ])</code></pre><p>Transform the matrix <code>M</code> into the standard form. Then, elements exceeding <code>ϵ * maximum column norm</code> are set to zero. The resulting output sparse matrix, and can be used as input to <code>std_wavemult</code>.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix{T} where T&lt;:AbstractFloat</code>: Matrix to be put in Sparse Standard form. </li><li><code>wt::OrthoFilter</code>: Wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(M)</code>) Number of decomposition levels.</li><li><code>ϵ::T where T&lt;:AbstractFloat</code>: (Default: <code>1e-4</code>) Truncation Criterion.</li></ul><p><strong>Returns</strong></p><ul><li><code>SM::SparseMatrixCSC{T, Integer}</code>: Sparse standard form of matrix of size <span>$n 	imes n$</span>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Wavelets, WaveletsExt; import Random: seed!

julia&gt; seed!(1234); M = randn(4,4); wt = wavelet(WT.haar);

julia&gt; mat2sparseform_std(M, wt)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
  1.88685    0.363656   0.468602   0.4063
  2.49634   -1.08139    1.90927   -0.356542
 -1.84601    0.129829   0.552745   0.427717
 -0.630852   0.866545  -0.124156  -0.218902</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.mat2sparseform_nonstd"><code>mat2sparseform_nonstd</code></a>, <a href="#WaveletsExt.WaveMult.sft"><code>sft</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/mat2sparse.jl#L57-L88">source</a></section></article><h2 id="Fast-Transform-Algorithms"><a class="docs-heading-anchor" href="#Fast-Transform-Algorithms">Fast Transform Algorithms</a><a id="Fast-Transform-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Transform-Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.ns_dwt" href="#WaveletsExt.WaveMult.ns_dwt"><code>WaveletsExt.WaveMult.ns_dwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ns_dwt(x, wt, [L])</code></pre><p>Nonstandard wavelet transform on 1D signals.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T} where T&lt;:AbstractFloat</code>: 1D signal of length <span>$2^J$</span>.</li><li><code>wt::OrthoFilter</code>: Type of wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of decomposition levels.</li></ul><p><strong>Returns</strong></p><ul><li><code>nxw::Vector{T}</code>: Nonstandard wavelet transform of <code>x</code> of length <span>$2^{J+1}$</span>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Wavelets, WaveletsExt; import Random: seed!

julia&gt; seed!(1234); x = randn(4)
4-element Vector{Float64}:
 -0.3597289068234817
  1.0872084924285859
 -0.4195896169388487
  0.7189099374659392

julia&gt; wt = wavelet(WT.haar);

julia&gt; nxw = ns_dwt(x, wt)      # Nonstandard transform
8-element Vector{Float64}:
  0.0
  0.0
  0.5133999530660974
 -0.2140796325390069
  0.5144057481561487
  0.21165142839163664
  1.0231392469635638
  0.8050407552974883

julia&gt; x̂ = ns_idwt(nxw, wt)     # Nonstandard inverse transform
4-element Vector{Float64}:
  0.004010885979070622
  1.4509482852311382
 -0.2699294566753035
  0.8685700977294846

julia&gt; x ≈ x̂                    # Unlike standard dwt, x ≠ x̂
false</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.nonstd_wavemult"><code>nonstd_wavemult</code></a>, <a href="#WaveletsExt.WaveMult.mat2sparseform_nonstd"><code>mat2sparseform_nonstd</code></a>, <a href="#WaveletsExt.WaveMult.ns_idwt"><code>ns_idwt</code></a>, <a href="#WaveletsExt.WaveMult.ndyad"><code>ndyad</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/transforms.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.ns_idwt" href="#WaveletsExt.WaveMult.ns_idwt"><code>WaveletsExt.WaveMult.ns_idwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ns_idwt(nxw, wt, [L])</code></pre><p>Inverse nonstandard wavelet transform on 1D signals.</p><p><strong>Arguments</strong></p><ul><li><code>nxw::AbstractVector{T} where T&lt;:AbstractFloat</code>: Nonstandard wavelet transformed 1D signal of length <span>$2^{J+1}$</span>.</li><li><code>wt::OrthoFilter</code>: Type of wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(nxw) - 1</code>) Number of decomposition levels.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Vector{T}</code>: 1D signal of length <span>$2^J$</span>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Wavelets, WaveletsExt; import Random: seed!

julia&gt; seed!(1234); x = randn(4)
4-element Vector{Float64}:
 -0.3597289068234817
  1.0872084924285859
 -0.4195896169388487
  0.7189099374659392

julia&gt; wt = wavelet(WT.haar);

julia&gt; nxw = ns_dwt(x, wt)      # Nonstandard transform
8-element Vector{Float64}:
  0.0
  0.0
  0.5133999530660974
 -0.2140796325390069
  0.5144057481561487
  0.21165142839163664
  1.0231392469635638
  0.8050407552974883

julia&gt; x̂ = ns_idwt(nxw, wt)     # Nonstandard inverse transform
4-element Vector{Float64}:
  0.004010885979070622
  1.4509482852311382
 -0.2699294566753035
  0.8685700977294846

julia&gt; x ≈ x̂                    # Unlike standard dwt, x ≠ x̂
false</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.nonstd_wavemult"><code>nonstd_wavemult</code></a>, <a href="#WaveletsExt.WaveMult.mat2sparseform_nonstd"><code>mat2sparseform_nonstd</code></a>, <a href="#WaveletsExt.WaveMult.ns_dwt"><code>ns_dwt</code></a>, <a href="#WaveletsExt.WaveMult.ndyad"><code>ndyad</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/transforms.jl#L72-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.sft" href="#WaveletsExt.WaveMult.sft"><code>WaveletsExt.WaveMult.sft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sft(M, wt, [L])</code></pre><p>Transforms a matrix <code>M</code> to be then represented in the sparse standard form. This is achieved by first computing <span>$L$</span> levels of wavelet transform on each column of <code>M</code>, and then computing <span>$L$</span> levels of wavelet transform on each row of <code>M</code>.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix{T} where T&lt;:AbstractFloat</code>: Matrix to be put in standard form.</li><li><code>wt::OrthoFilter</code>: Type of wavelet filter.</li><li><code>L::Integer</code>: Number of decomposition levels.</li></ul><p><strong>Returns</strong></p><ul><li><code>Mw::Matrix{T}</code>: Matrix in the standard form.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import WaveletsExt.WaveMult: sft
using Wavelets

M = randn(4,4); wt = wavelet(WT.haar)
Mw = sft(M, wt)
M̂ = isft(Mw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.mat2sparseform_std"><code>mat2sparseform_std</code></a>, <a href="#WaveletsExt.WaveMult.isft"><code>isft</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/transforms.jl#L144-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.isft" href="#WaveletsExt.WaveMult.isft"><code>WaveletsExt.WaveMult.isft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isft(Mw, wt, [L])</code></pre><p>Reconstructs the matrix <code>M</code> from the sparse standard form <code>Mw</code>. This is achieved by first computing <span>$L$</span> levels of inverse wavelet transform on each row of <code>Mw</code>, and then computing <span>$L$</span> levels of inverse wavelet transform on each column of <code>Mw</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Mw::AbstractMatrix{T} where T&lt;:AbstractFloat</code>: Matrix in standard form.</li><li><code>wt::OrthoFilter</code>: Type of wavelet filter.</li><li><code>L::Integer</code>: Number of decomposition levels.</li></ul><p><strong>Returns</strong></p><ul><li><code>M::Matrix{T}</code>: Reconstructed matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import WaveletsExt.WaveMult: sft
using Wavelets

M = randn(4,4); wt = wavelet(WT.haar)
Mw = sft(M, wt)
M̂ = isft(Mw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.WaveMult.sft"><code>sft</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/transforms.jl#L187-L213">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.dyadlength" href="#WaveletsExt.WaveMult.dyadlength"><code>WaveletsExt.WaveMult.dyadlength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dyadlength(x)
dyadlength(n)</code></pre><p>Find dyadic length of array.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Array of length <code>n</code>. Preferred array length is <span>$2^J$</span> where <span>$J$</span> is an integer.</li><li><code>n::Integer</code>: Length of array.</li></ul><p><strong>Returns</strong></p><ul><li><code>J::Integer</code>: Least power of two greater than <code>n</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function <code>dyadlength</code> is very similar to the function <code>maxtransformlevels</code> from Wavelets.jl. The only difference here is the way it handles <code>n</code> when <code>n</code> is not a power of 2. The example below provides a demonstration of the differences in the 2 functions.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import WaveletsExt.WaveMult: dyadlength

julia&gt; import Wavelets: maxtransformlevels

julia&gt; x = randn(16); dyadlength(x)
4

julia&gt; dyadlength(16)              # Same as previous
4

julia&gt; maxtransformlevels(16)      # Equivalent to dyadlength when n is power of 2
4

julia&gt; dyadlength(15)              # Produces warning when n is not power of 2
┌ Warning: Dyadlength n != 2^J
└ @ WaveletsExt.WaveMult
4

julia&gt; maxtransformlevels(15)      # Not equivalent to dyadlength when n is not power of 2
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/utils.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.ndyad" href="#WaveletsExt.WaveMult.ndyad"><code>WaveletsExt.WaveMult.ndyad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ndyad(L, Lmax, gender)</code></pre><p>Index dyad of nonstandard wavelet transform.</p><p><strong>Arguments</strong></p><ul><li><code>L::T where T&lt;:Integer</code>: Current level of node.</li><li><code>Lmax::T where T&lt;:Integer</code>: Max level of a signal being analyzed.</li><li><code>gender::Bool</code>: &quot;Gender&quot; of node. <ul><li><code>true</code> = Female: Node is detail coefficients of the decomposition of its parent.</li><li><code>false</code> = Male: Node is approximate coefficients of the decomposition of its parent.</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Current level of node <code>L</code> cannot be 0 or larger than its max possible level <code>Lmax</code>.</p></div></div><p><strong>Returns</strong></p><ul><li><code>::UnitRange{T}</code>: Range of all coefficients at the <code>L</code>-th level attached to wavelets of indicated gender.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import WaveletsExt.WaveMult: ndyad

julia&gt; ndyad(1, 4, false)
17:24

julia&gt; ndyad(1, 4, true)
25:32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/utils.jl#L116-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WaveMult.stretchmatrix" href="#WaveletsExt.WaveMult.stretchmatrix"><code>WaveletsExt.WaveMult.stretchmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stretchmatrix(i, j, n, L)</code></pre><p>Stretch matrix into BCR nonstandard form.</p><p><strong>Arguments</strong></p><ul><li><code>i::AbstractVector{T} where T&lt;:Integer</code>: Row indices of nonzero elements of matrix.</li><li><code>j::AbstractVector{T} where T&lt;:Integer</code>: Column indices of nonzero elements of matrix.</li><li><code>n::T where T&lt;:Integer</code>: Size of square matrix.</li><li><code>L::T where T&lt;:Integer</code>: Number of resolution levels.</li></ul><p><strong>Returns</strong></p><ul><li><code>ie::Vector{T}</code>: Row indices of elements in nonstandard form of matrix.</li><li><code>je::Vector{T}</code>: Column indices of elements in nonstandard form of matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 0 0 0;
            0 2 0 0;
            0 0 3 0;
            0 0 0 4];

julia&gt; idx = findall(!iszero, M)
2-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia&gt; i = getindex.(idx, 1)
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; j = getindex.(idx, 2)
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; stretchmatrix(i, j, 4, 2)
([1, 4, 7, 8], [1, 4, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/2498e290596c43210ca71792471146272d23a990/src/mod/wavemult/utils.jl#L53-L97">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../siwt/">« SIWT</a><a class="docs-footer-nextpage" href="../bestbasis/">Best Basis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Saturday 11 June 2022 03:10">Saturday 11 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
