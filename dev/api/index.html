<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · WaveletsExt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WaveletsExt.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">WaveletsExt.jl</a></li><li><a class="tocitem" href="../transforms/">Wavelet Transforms</a></li><li><a class="tocitem" href="../bestbasis/">Best Basis Examples</a></li><li><a class="tocitem" href="../denoising/">Denoising Examples</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zengfung/WaveletsExt.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#Wavelets.Threshold.VisuShrink-Tuple{Integer, Wavelets.Threshold.THType}"><code>Wavelets.Threshold.VisuShrink</code></a></li><li><a href="#WaveletsExt.Denoising.RelErrorShrink"><code>WaveletsExt.Denoising.RelErrorShrink</code></a></li><li><a href="#WaveletsExt.Denoising.RelErrorShrink"><code>WaveletsExt.Denoising.RelErrorShrink</code></a></li><li><a href="#WaveletsExt.Denoising.SureShrink"><code>WaveletsExt.Denoising.SureShrink</code></a></li><li><a href="#WaveletsExt.Denoising.SureShrink"><code>WaveletsExt.Denoising.SureShrink</code></a></li><li><a href="#Wavelets.Threshold.bestbasistree-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T&lt;:AbstractFloat"><code>Wavelets.Threshold.bestbasistree</code></a></li><li><a href="#Wavelets.Threshold.denoise-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T&lt;:Number, S&lt;:Wavelets.Threshold.DNFT}"><code>Wavelets.Threshold.denoise</code></a></li><li><a href="#Wavelets.Threshold.noisest-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T&lt;:Number"><code>Wavelets.Threshold.noisest</code></a></li><li><a href="#WaveletsExt.ACWT.acwpt"><code>WaveletsExt.ACWT.acwpt</code></a></li><li><a href="#WaveletsExt.ACWT.acwt"><code>WaveletsExt.ACWT.acwt</code></a></li><li><a href="#WaveletsExt.ACWT.acwt_step"><code>WaveletsExt.ACWT.acwt_step</code></a></li><li><a href="#WaveletsExt.ACWT.autocorr-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.autocorr</code></a></li><li><a href="#WaveletsExt.ACWT.hacwt"><code>WaveletsExt.ACWT.hacwt</code></a></li><li><a href="#WaveletsExt.ACWT.iacwt"><code>WaveletsExt.ACWT.iacwt</code></a></li><li><a href="#WaveletsExt.ACWT.make_acqmfpair-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.make_acqmfpair</code></a></li><li><a href="#WaveletsExt.ACWT.make_acreverseqmfpair-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.make_acreverseqmfpair</code></a></li><li><a href="#WaveletsExt.ACWT.pfilter-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.pfilter</code></a></li><li><a href="#WaveletsExt.ACWT.qfilter-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.qfilter</code></a></li><li><a href="#WaveletsExt.ACWT.vacwt"><code>WaveletsExt.ACWT.vacwt</code></a></li><li><a href="#WaveletsExt.BestBasis.bestbasis_treeselection-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>WaveletsExt.BestBasis.bestbasis_treeselection</code></a></li><li><a href="#WaveletsExt.BestBasis.bestbasiscoef-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector}} where T&lt;:AbstractFloat"><code>WaveletsExt.BestBasis.bestbasiscoef</code></a></li><li><a href="#WaveletsExt.BestBasis.tree_costs-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T&lt;:AbstractFloat"><code>WaveletsExt.BestBasis.tree_costs</code></a></li><li><a href="#WaveletsExt.Denoising.denoiseall-Union{Tuple{S}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T1&lt;:Number, T2&lt;:Number, S&lt;:Wavelets.Threshold.DNFT}"><code>WaveletsExt.Denoising.denoiseall</code></a></li><li><a href="#WaveletsExt.Denoising.findelbow-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>WaveletsExt.Denoising.findelbow</code></a></li><li><a href="#WaveletsExt.Denoising.orth2relerror-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Number"><code>WaveletsExt.Denoising.orth2relerror</code></a></li><li><a href="#WaveletsExt.Denoising.relerrorthreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}, Integer}} where T&lt;:Number"><code>WaveletsExt.Denoising.relerrorthreshold</code></a></li><li><a href="#WaveletsExt.Denoising.surethreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T&lt;:Number"><code>WaveletsExt.Denoising.surethreshold</code></a></li><li><a href="#WaveletsExt.LDB.discriminant_measure-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, DiscriminantMeasure}} where T&lt;:Number"><code>WaveletsExt.LDB.discriminant_measure</code></a></li><li><a href="#WaveletsExt.LDB.discriminant_power-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector, BasisDiscriminantMeasure}} where T&lt;:Number"><code>WaveletsExt.LDB.discriminant_power</code></a></li><li><a href="#WaveletsExt.LDB.energy_map-Tuple{AbstractArray{var&quot;#s53&quot;, 3} where var&quot;#s53&quot;&lt;:Number, TimeFrequency}"><code>WaveletsExt.LDB.energy_map</code></a></li><li><a href="#WaveletsExt.LDB.ldb-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}} where {S&lt;:Number, T}"><code>WaveletsExt.LDB.ldb</code></a></li><li><a href="#WaveletsExt.SIWPD.makesiwpdtree-Tuple{Integer, Integer, Integer}"><code>WaveletsExt.SIWPD.makesiwpdtree</code></a></li><li><a href="#WaveletsExt.SIWPD.siwpd-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer, Integer}} where T&lt;:Number"><code>WaveletsExt.SIWPD.siwpd</code></a></li><li><a href="#WaveletsExt.SWT.isdwt"><code>WaveletsExt.SWT.isdwt</code></a></li><li><a href="#WaveletsExt.SWT.isdwt_step"><code>WaveletsExt.SWT.isdwt_step</code></a></li><li><a href="#WaveletsExt.SWT.isdwt_step!"><code>WaveletsExt.SWT.isdwt_step!</code></a></li><li><a href="#WaveletsExt.SWT.iswpt"><code>WaveletsExt.SWT.iswpt</code></a></li><li><a href="#WaveletsExt.SWT.sdwt"><code>WaveletsExt.SWT.sdwt</code></a></li><li><a href="#WaveletsExt.SWT.sdwt_step"><code>WaveletsExt.SWT.sdwt_step</code></a></li><li><a href="#WaveletsExt.SWT.sdwt_step!"><code>WaveletsExt.SWT.sdwt_step!</code></a></li><li><a href="#WaveletsExt.SWT.swpd"><code>WaveletsExt.SWT.swpd</code></a></li><li><a href="#WaveletsExt.SWT.swpt"><code>WaveletsExt.SWT.swpt</code></a></li><li><a href="#WaveletsExt.Utils.coarsestscalingrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T&lt;:Number"><code>WaveletsExt.Utils.coarsestscalingrange</code></a></li><li><a href="#WaveletsExt.Utils.finestdetailrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T&lt;:Number"><code>WaveletsExt.Utils.finestdetailrange</code></a></li><li><a href="#WaveletsExt.Utils.generatesignals-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Integer}, Tuple{AbstractVector{T}, Integer, Integer, Bool}, Tuple{AbstractVector{T}, Integer, Integer, Bool, Real}} where T&lt;:Number"><code>WaveletsExt.Utils.generatesignals</code></a></li><li><a href="#WaveletsExt.Utils.getleaf-Tuple{BitVector}"><code>WaveletsExt.Utils.getleaf</code></a></li><li><a href="#WaveletsExt.Utils.left-Tuple{Integer}"><code>WaveletsExt.Utils.left</code></a></li><li><a href="#WaveletsExt.Utils.nodelength-Tuple{Integer, Integer}"><code>WaveletsExt.Utils.nodelength</code></a></li><li><a href="#WaveletsExt.Utils.psnr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>WaveletsExt.Utils.psnr</code></a></li><li><a href="#WaveletsExt.Utils.relativenorm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Real}} where T&lt;:Number"><code>WaveletsExt.Utils.relativenorm</code></a></li><li><a href="#WaveletsExt.Utils.right-Tuple{Integer}"><code>WaveletsExt.Utils.right</code></a></li><li><a href="#WaveletsExt.Utils.snr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>WaveletsExt.Utils.snr</code></a></li><li><a href="#WaveletsExt.Utils.ssim-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}} where T&lt;:Number"><code>WaveletsExt.Utils.ssim</code></a></li><li><a href="#WaveletsExt.Visualizations.plot_tfbdry-Tuple{BitVector}"><code>WaveletsExt.Visualizations.plot_tfbdry</code></a></li><li><a href="#WaveletsExt.Visualizations.treenodes_matrix-Tuple{BitVector}"><code>WaveletsExt.Visualizations.treenodes_matrix</code></a></li><li><a href="#WaveletsExt.Visualizations.wiggle-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>WaveletsExt.Visualizations.wiggle</code></a></li><li><a href="#WaveletsExt.Visualizations.wiggle!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>WaveletsExt.Visualizations.wiggle!</code></a></li><li><a href="#WaveletsExt.WPD.wpd"><code>WaveletsExt.WPD.wpd</code></a></li><li><a href="#WaveletsExt.WPD.wpd!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet, Integer}} where T&lt;:Number"><code>WaveletsExt.WPD.wpd!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.acwpt" href="#WaveletsExt.ACWT.acwpt"><code>WaveletsExt.ACWT.acwpt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>acwpt(x, wt[, L=maxtransformlevels(x)])</p><p>Performs a discrete autocorrelation wavelet packet transform for a given signal <code>x</code>. The wavelet type <code>wt</code> determines the transform type. Refer to Wavelet.jl for a list of available methods.</p><p><strong>Examples</strong></p><pre><code class="language-julia">acwpt(x, wavelet(WT.db4))

acwpt(x, wavelet(WT.db4), 4)</code></pre><p><strong>See also:</strong> <code>acwt</code>, <code>acwpt_step</code>, <code>iacwpt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L45-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.acwt" href="#WaveletsExt.ACWT.acwt"><code>WaveletsExt.ACWT.acwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">acwt(x, wt[, L=maxtransformlevels(x)])</code></pre><p>acwt(x, wt[, Lrow=maxtransformlevels(x[1,:]), Lcol=maxtransformlevels(x[:,1])])</p><p>Performs a discrete autocorrelation wavelet transform for a given signal <code>x</code>. The signal can be 1D or 2D. The wavelet type <code>wt</code> determines the transform type. Refer to Wavelet.jl for a list of available methods.</p><p><strong>Examples</strong></p><pre><code class="language-julia">acwt(x, wavelet(WT.db4))

acwt(x, wavelet(WT.db4), 4) # level 4 decomposition</code></pre><p><strong>See also:</strong> <code>acwt_step</code>, <code>iacwt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.acwt_step" href="#WaveletsExt.ACWT.acwt_step"><code>WaveletsExt.ACWT.acwt_step</code></a> — <span class="docstring-category">Function</span></header><section><div><p>acwt_step(v, j, h, g)</p><p>Performs one level of the autocorrelation discrete wavelet transform (ACWT) on the  vector <code>v</code>, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors <code>h</code> and <code>g</code> are the detail and scaling filters.</p><p>Returns a tuple <code>(v, w)</code> of the scaling and detail coefficients at level <code>j+1</code>.</p><p><strong>See also:</strong> <code>acwt</code>, <code>iacwt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.autocorr-Tuple{Wavelets.WT.OrthoFilter}" href="#WaveletsExt.ACWT.autocorr-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.autocorr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>autocorr(f::OrthoFilter)</p><p>Generates the autocorrelation filter for a given wavelet filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.hacwt" href="#WaveletsExt.ACWT.hacwt"><code>WaveletsExt.ACWT.hacwt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>hacwt(x, wt[, L=maxtransformlevels(x)])</p><p>Computes the column-wise discrete autocorrelation transform coeficients for 2D signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.iacwt" href="#WaveletsExt.ACWT.iacwt"><code>WaveletsExt.ACWT.iacwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iacwt(xw::AbstractArray{&lt;:Number,2})</code></pre><p>iacwt(xw::AbstractArray{&lt;:Number,4})</p><p>Performs the inverse autocorrelation discrete wavelet transform.  Can be used for both the 1D and 2D case.</p><p><strong>See also:</strong> <code>iacwt!, acwt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.make_acqmfpair-Tuple{Wavelets.WT.OrthoFilter}" href="#WaveletsExt.ACWT.make_acqmfpair-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.make_acqmfpair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>acmakeqmfpair(f::OrthoFilter)</p><p>Generates the autocorrelation quadratic mirror filters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.make_acreverseqmfpair-Tuple{Wavelets.WT.OrthoFilter}" href="#WaveletsExt.ACWT.make_acreverseqmfpair-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.make_acreverseqmfpair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>makereverseqmfpair(f::OrthoFilter)</p><p>Generates the reverse autocorrelation quadratic mirror filters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.pfilter-Tuple{Wavelets.WT.OrthoFilter}" href="#WaveletsExt.ACWT.pfilter-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.pfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>pfilter(f::OrthoFilter)</p><p>Generates the high-pass autocorrelation filter </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.qfilter-Tuple{Wavelets.WT.OrthoFilter}" href="#WaveletsExt.ACWT.qfilter-Tuple{Wavelets.WT.OrthoFilter}"><code>WaveletsExt.ACWT.qfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>qfilter(f::OrthoFilter)</p><p>Generates the low-pass autocorrelation filter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.ACWT.vacwt" href="#WaveletsExt.ACWT.vacwt"><code>WaveletsExt.ACWT.vacwt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>vacwt(x, wt[, L=maxtransformlevels(x)])</p><p>Computes the row-wise discrete autocorrelation transform coeficients for 2D signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/ACWT.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wavelets.Threshold.bestbasistree-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T&lt;:AbstractFloat" href="#Wavelets.Threshold.bestbasistree-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T&lt;:AbstractFloat"><code>Wavelets.Threshold.bestbasistree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bestbasistree(X[, method])</code></pre><p>Extension to the best basis tree function from Wavelets.jl. Given a set of  decomposed signals, returns different types of best basis trees based on the  methods specified. Available methods are the joint best basis (<code>JBB()</code>), least  statistically dependent basis (<code>LSDB()</code>), and individual regular best basis  (<code>BB()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/BestBasis.jl#L378-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.BestBasis.bestbasis_treeselection-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:AbstractFloat" href="#WaveletsExt.BestBasis.bestbasis_treeselection-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>WaveletsExt.BestBasis.bestbasis_treeselection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bestbasis_treeselection(costs, n)</code></pre><p>Computes the best tree based on the given cost vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/BestBasis.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.BestBasis.bestbasiscoef-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector}} where T&lt;:AbstractFloat" href="#WaveletsExt.BestBasis.bestbasiscoef-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector}} where T&lt;:AbstractFloat"><code>WaveletsExt.BestBasis.bestbasiscoef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bestbasiscoef(X, tree)
bestbasiscoef(X, wt, tree)</code></pre><p>Returns the expansion coefficients based on the given tree(s) and wavelet packet decomposition (WPD) expansion coefficients. If the WPD expansion coefficients  were not provided, the expansion coefficients can be obtained by providing the signals and wavelet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/BestBasis.jl#L442-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.BestBasis.tree_costs-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T&lt;:AbstractFloat" href="#WaveletsExt.BestBasis.tree_costs-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T&lt;:AbstractFloat"><code>WaveletsExt.BestBasis.tree_costs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_costs(X, method)</code></pre><p>Returns the cost of each node in a binary tree in order to find the best basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/BestBasis.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wavelets.Threshold.denoise-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T&lt;:Number, S&lt;:Wavelets.Threshold.DNFT}" href="#Wavelets.Threshold.denoise-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T&lt;:Number, S&lt;:Wavelets.Threshold.DNFT}"><code>Wavelets.Threshold.denoise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">denoise(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),
    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),
    estnoise=noisest, smooth=:regular])</code></pre><p>Extension of the <code>denoise</code> function from <code>Wavelets.jl</code>. Denoise a signal of  input type <code>inputtype</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractArray{&lt;:Number}</code>: input signals/coefficients.</li><li><code>inputtype::Symbol</code>: input type of <code>x</code>. Current accepted types of inputs are<ul><li><code>:sig</code>: original signals; <code>x</code> should be a 2-D array with each column    representing a signal.</li><li><code>:dwt</code>: <code>dwt</code>-transformed signal coefficients; <code>x</code> should be a 1-D array    with each column representing the coefficients of a signal.</li><li><code>:wpt</code>: <code>wpt</code>-transformed signal coefficients; <code>x</code> should be a 1-D array    with each column representing the coefficients of a signal.</li><li><code>:sdwt</code>: <code>sdwt</code>-transformed signal coefficients; <code>x</code> should be a 2-D array   with each column representing the coefficients of a node.</li><li><code>:swpd</code>: <code>swpd</code>-transformed signal coefficients; <code>x</code> should be a 2-D array   with each column representing the coefficients of a node.</li><li><code>:acwt</code>: <code>acwt</code>-transformed signal coefficients from    AutocorrelationShell.jl; <code>x</code> should be a 2-D array with each column    representing the coefficients of a node.</li><li><code>:acwpt</code>: <code>acwpt</code>-transformed signal coefficients from   AutocorrelationShell.jl; <code>x</code> should be a 2-D array with each column    representing the coefficients of a node.</li></ul></li><li><code>wt::Union{DiscreteWavelet, Nothing}</code>: the discrete wavelet to be used for   decomposition (for input type <code>:sig</code>) and reconstruction. <code>nothing</code> can    be supplied if no reconstruction is necessary.</li><li><code>L::Integer</code>: the number of decomposition levels. Necessary for input types   <code>:sig</code>, <code>:dwt</code>, and <code>:sdwt</code>. Default value is set to be    <code>maxtransformlevels(size(x,1))</code>.</li><li><code>tree::BitVector</code>: the decomposition tree of the signals. Necessary for input   types <code>:wpt</code> and <code>:swpd</code>. Default value is set to be    <code>maketree(size(x,1), L, :dwt)</code>.</li><li><code>dnt::DNFT</code>: denoise type. Default type is set to be <code>VisuShrink(size(x,1))</code>.</li><li><code>estnoise::Union{Function, Vector{&lt;:Number}}</code>: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the <code>noisest</code> function.</li><li><code>smooth::Symbol</code>: the smoothing method used. <code>:regular</code> smoothing thresholds   all given coefficients, whereas <code>:undersmooth</code> smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be <code>:regular</code>.</li></ul><p><strong>See also:</strong> <code>denoiseall</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L72-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wavelets.Threshold.noisest-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T&lt;:Number" href="#Wavelets.Threshold.noisest-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T&lt;:Number"><code>Wavelets.Threshold.noisest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noisest(x, redundant[, tree=nothing])</code></pre><p>Extension to the <code>noisest</code> function from <code>Wavelets.jl</code>. Estimates the noise of a signal from its coefficients.</p><p><strong>Examples</strong></p><pre><code class="language-julia">x = randn(128)
wt = wavelet(WT.haar)

# noise estimate for dwt transformation
y = dwt(x, wt)
noise = noisest(y, false)

# noise estimate for wpt transformation
tree = maketree(x, :full)
y = wpt(x, wt, tree)
noise = noisest(y, false, tree)

# noise estimate for sdwt transformation
y = sdwt(x, wt)
noise = noisest(y, true)

# noise estimate for swpd transformation
y = swpd(x, wt)
noise = noisest(y, true, tree)</code></pre><p><strong>See also:</strong> <code>relerrorthreshold</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L351-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.denoiseall-Union{Tuple{S}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T1&lt;:Number, T2&lt;:Number, S&lt;:Wavelets.Threshold.DNFT}" href="#WaveletsExt.Denoising.denoiseall-Union{Tuple{S}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T1&lt;:Number, T2&lt;:Number, S&lt;:Wavelets.Threshold.DNFT}"><code>WaveletsExt.Denoising.denoiseall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">denoiseall(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),
    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),
    estnoise=noisest, bestTH=nothing, smooth=:regular])</code></pre><p>Denoise multiple signals of input type <code>inputtype</code>. </p><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractArray{&lt;:Number}</code>: input signals/coefficients.</li><li><code>inputtype::Symbol</code>: input type of <code>x</code>. Current accepted types of inputs are<ul><li><code>:sig</code>: original signals; <code>x</code> should be a 2-D array with each column    representing a signal.</li><li><code>:dwt</code>: <code>dwt</code>-transformed signal coefficients; <code>x</code> should be a 2-D array    with each column representing the coefficients of a signal.</li><li><code>:wpt</code>: <code>wpt</code>-transformed signal coefficients; <code>x</code> should be a 2-D array    with each column representing the coefficients of a signal.</li><li><code>:sdwt</code>: <code>sdwt</code>-transformed signal coefficients; <code>x</code> should be a 3-D array   with each 2-D slice representing the coefficients of a signal.</li><li><code>:swpd</code>: <code>swpd</code>-transformed signal coefficients; <code>x</code> should be a 3-D array   with each 2-D slice representing the coefficients of a signal.</li><li><code>:acwt</code>: <code>acwt</code>-transformed signal coefficients from   AutocorrelationShell.jl; <code>x</code> should be a 3-D array with each 2-D slice    representing the coefficients of a signal.</li><li><code>:acwpt</code>: <code>acwpt</code>-transformed signal coefficients from   AutocorrelationShell.jl; <code>x</code> should be a 3-D array with each 2-D slice    representing the coefficients of a signal.</li></ul></li><li><code>wt::Union{DiscreteWavelet, Nothing}</code>: the discrete wavelet to be used for   decomposition (for input type <code>:sig</code>) and reconstruction. <code>nothing</code> can    be supplied if no reconstruction is necessary.</li><li><code>L::Integer</code>: the number of decomposition levels. Necessary for input types   <code>:sig</code>, <code>:dwt</code>, and <code>:sdwt</code>. Default value is set to be    <code>maxtransformlevels(size(x,1))</code>.</li><li><code>tree::BitVector</code>: the decomposition tree of the signals. Necessary for input   types <code>:wpt</code> and <code>:swpd</code>. Default value is set to be    <code>maketree(size(x,1), L, :dwt)</code>.</li><li><code>dnt::DNFT</code>: denoise type. Default type is set to be <code>VisuShrink(size(x,1))</code>.</li><li><code>estnoise::Union{Function, Vector{&lt;:Number}}</code>: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the <code>noisest</code> function.</li><li><code>bestTH::Union{Function, Nothing}</code>: method to determine the best threshold    value for a group of signals. If <code>nothing</code> is given, then each signal will   be denoised by its respective best threshold value determined from the    parameters <code>dnt</code> and <code>estnoise</code>; otherwise some function can be passed   to determine the best threshold value from a vector of threshold values, eg:   <code>mean</code> and <code>median</code>. Default is set to be <code>nothing</code>.</li><li><code>smooth::Symbol</code>: the smoothing method used. <code>:regular</code> smoothing thresholds   all given coefficients, whereas <code>:undersmooth</code> smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be <code>:regular</code>.</li></ul><p><strong>See alse:</strong> <code>denoise</code>, <code>noisest</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L235-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.findelbow-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number" href="#WaveletsExt.Denoising.findelbow-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>WaveletsExt.Denoising.findelbow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findelbow(x, y)</code></pre><p>Given the x and y coordinates of a curve, return the elbow.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L516-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.orth2relerror-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Number" href="#WaveletsExt.Denoising.orth2relerror-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Number"><code>WaveletsExt.Denoising.orth2relerror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orth2relerror(orth)</code></pre><p>Given a vector &#39;orth&#39; of orthonormal expansion coefficients, return a  vector of relative approximation errors when retaining the 1,2,...,N  largest coefficients in magnitude.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L502-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.relerrorthreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}, Integer}} where T&lt;:Number" href="#WaveletsExt.Denoising.relerrorthreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}, Integer}} where T&lt;:Number"><code>WaveletsExt.Denoising.relerrorthreshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relerrorthreshold(coef, redundant[, tree, elbows=2; makeplot=false])</code></pre><p>Takes in a set of expansion coefficients, &#39;plot&#39; the threshold vs relative error  curve and select the best threshold value based on the elbow method.</p><p><strong>Examples</strong></p><pre><code class="language-julia">x = randn(128)
wt = wavelet(WT.haar)

# noise estimate for dwt transformation
y = dwt(x, wt)
noise = relerrorthreshold(y, false)

# noise estimate for wpt transformation
tree = maketree(x, :full)
y = wpt(x, wt, tree)
noise = relerrorthreshold(y, false, tree)

# noise estimate for sdwt transformation
y = sdwt(x, wt)
noise = relerrorthreshold(y, true)

# noise estimate for swpd transformation
y = swpd(x, wt)
noise = relerrorthreshold(y, true, tree)</code></pre><p><strong>See also:</strong> <code>noisest</code>, <code>RelErrorShrink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L428-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.surethreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T&lt;:Number" href="#WaveletsExt.Denoising.surethreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T&lt;:Number"><code>WaveletsExt.Denoising.surethreshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surethreshold(coef, redundant[, tree=nothing])</code></pre><p>Determination of the <code>t</code> value used for <code>SureShrink</code>.</p><p><strong>See also:</strong> <code>SureShrink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L399-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wavelets.Threshold.VisuShrink-Tuple{Integer, Wavelets.Threshold.THType}" href="#Wavelets.Threshold.VisuShrink-Tuple{Integer, Wavelets.Threshold.THType}"><code>Wavelets.Threshold.VisuShrink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VisuShrink(n, th)</code></pre><p>Extension to the <code>VisuShrink</code> struct constructor from <code>Wavelets.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.RelErrorShrink" href="#WaveletsExt.Denoising.RelErrorShrink"><code>WaveletsExt.Denoising.RelErrorShrink</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relative Error Shrink</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.RelErrorShrink" href="#WaveletsExt.Denoising.RelErrorShrink"><code>WaveletsExt.Denoising.RelErrorShrink</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelErrorShrink([th=HardTH()])</code></pre><p>Struct constructor for Relative Error Shrink.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.SureShrink" href="#WaveletsExt.Denoising.SureShrink"><code>WaveletsExt.Denoising.SureShrink</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stein&#39;s Unbiased Risk Estimate (SURE) Shrink</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Denoising.SureShrink" href="#WaveletsExt.Denoising.SureShrink"><code>WaveletsExt.Denoising.SureShrink</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SureShrink(x[, tree=nothing, th=SteinTH()])</code></pre><p>Struct constructor for <code>SureShrink</code> based on the signal coefficients <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Denoising.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.LDB.discriminant_measure-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, DiscriminantMeasure}} where T&lt;:Number" href="#WaveletsExt.LDB.discriminant_measure-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, DiscriminantMeasure}} where T&lt;:Number"><code>WaveletsExt.LDB.discriminant_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discriminant_measure(Γ, dm)</code></pre><p>Returns the discriminant measure calculated from the energy maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/LDB.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.LDB.discriminant_power-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector, BasisDiscriminantMeasure}} where T&lt;:Number" href="#WaveletsExt.LDB.discriminant_power-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector, BasisDiscriminantMeasure}} where T&lt;:Number"><code>WaveletsExt.LDB.discriminant_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discriminant_power(coefs, tree, dp)</code></pre><p>Returns the discriminant power of each leaf from the local discriminant basis (LDB) tree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/LDB.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.LDB.energy_map-Tuple{AbstractArray{var&quot;#s53&quot;, 3} where var&quot;#s53&quot;&lt;:Number, TimeFrequency}" href="#WaveletsExt.LDB.energy_map-Tuple{AbstractArray{var&quot;#s53&quot;, 3} where var&quot;#s53&quot;&lt;:Number, TimeFrequency}"><code>WaveletsExt.LDB.energy_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_map(coef, method)</code></pre><p>Returns the Time Frequency Energy map or the Probability Density Energy map depending on the input <code>method</code> (<code>TimeFrequency()</code> or <code>ProbabilityDensity()</code>).  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/LDB.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.LDB.ldb-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}} where {S&lt;:Number, T}" href="#WaveletsExt.LDB.ldb-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}} where {S&lt;:Number, T}"><code>WaveletsExt.LDB.ldb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ldb(X, y, wt[; dm=AsymmetricRelativeEntropy(), energy=TimeFrequency(),
    dp=BasisDiscriminantMeasure(), topk=size(X,1), m=size(X,1)])</code></pre><p>The Local Discriminant Basis (LDB) feature selection algorithm developed by  Saito and Coifman. This function takes in the input signals and their  respective class labels, an orthogonal wavelet filter, and returns a set of  expansion coefficients of reduced features and dimensions.</p><p><strong>Arguments:</strong></p><ul><li><code>X::AbstractArray{&lt;:Number,2}</code>: the input set of signals. each column    represents a signal.</li><li><code>y::AbstractVector{T}</code>: the corresponding labels</li><li><code>wt::DiscreteWavelet</code>: a discrete wavelet for transform purposes</li><li><code>dm::DiscriminantMeasure</code>: the discriminant measure for the LDB algorithm.    Supported measures are the <code>AsymmetricRelativeEntropy()</code>, <code>LpEntropy()</code>   <code>SymmetricRelativeEntropy()</code>, and <code>HellingerDistance()</code>. Default is set to    be <code>AsymmetricRelativeEntropy()</code>.</li><li><code>energy::EnergyMap</code>: the type of energy map used. Supported maps are    <code>TimeFrequency()</code> and <code>ProbabilityDensity()</code>. Default is set to be    <code>TimeFrequency()</code>.</li><li><code>dp::DiscriminantPower()</code>: the measure of discriminant power among expansion   coefficients. Supported measures are <code>BasisDiscriminantMeasure()</code>,   <code>FishersClassSeparability()</code>, and <code>RobustFishersClassSeparability()</code>.    Default is set to be <code>BasisDiscriminantMeasure()</code>.</li><li><code>topk::Integer</code>: the top-k coefficients used in each node to determine the    discriminant measure. Default is set to all coefficients.</li><li><code>m::Integer</code>: the dimension of output after undergoing feature selection and   transformation. Default is set to all coefficients of most discriminant    subtree, ie. the length of each signals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/LDB.jl#L249-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SIWPD.makesiwpdtree-Tuple{Integer, Integer, Integer}" href="#WaveletsExt.SIWPD.makesiwpdtree-Tuple{Integer, Integer, Integer}"><code>WaveletsExt.SIWPD.makesiwpdtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makesiwpdtree(n, L, d)</code></pre><p>Returns the multi-level, multi-depth binary tree corresponding to the Shift- Invariant Wavelet Packet Decomposition. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SIWPD.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SIWPD.siwpd-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer, Integer}} where T&lt;:Number" href="#WaveletsExt.SIWPD.siwpd-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer, Integer}} where T&lt;:Number"><code>WaveletsExt.SIWPD.siwpd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">siwpd(x, wt[, L=maxtransformlevels(x), d=L])</code></pre><p>Computes the Shift-Invariant Wavelet Packet Decomposition originally developed by Cohen, Raz &amp; Malah on the vector <code>x</code> using the discrete wavelet filter <code>wt</code> for <code>L</code> levels with depth <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SIWPD.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt" href="#WaveletsExt.SWT.isdwt"><code>WaveletsExt.SWT.isdwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdwt(xw, wt[, ε])</code></pre><p>Performs the inverse stationary discrete wavelet transform (ISDWT) on the <code>sdwt</code> transform coefficients with respect to the Boolean Vector <code>ε</code> which represents  the shifts to be used. If <code>ε</code> is not provided, the average-basis ISDWT will be  computed instead.</p><p><strong>See also:</strong> <code>iswpt</code>, <code>sdwt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt_step" href="#WaveletsExt.SWT.isdwt_step"><code>WaveletsExt.SWT.isdwt_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdwt_step(v1, w1, j, s0, s1, g, h)</code></pre><p>Perform one level of the inverse stationary discrete wavelet transform (ISDWT)  on the vector <code>v1</code> and <code>w1</code>, which is the j-th level scaling coefficients (Note  the 0th level scaling coefficients is the raw signal). The vectors <code>h</code> and <code>g</code>  are the detail and scaling filters.</p><p>Returns a vector <code>v0</code> of the scaling and detail coefficients at level <code>j-1</code>.</p><p><strong>See also:</strong> <code>isdwt_step!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L94-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt_step!" href="#WaveletsExt.SWT.isdwt_step!"><code>WaveletsExt.SWT.isdwt_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdwt_step!(v0, v1, w1, j, s0, s1, g, h)</code></pre><p>Same as <code>isdwt_step</code> but without array allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswpt" href="#WaveletsExt.SWT.iswpt"><code>WaveletsExt.SWT.iswpt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iswpt(xw, wt, ε[, L=maxtransformlevels(size(xw,1))])

iswpt(xw, wt, ε, tree)

iswpt(xw, wt[, L=maxtransformlevels(size(xw,1))])

iswpt(xw, wt, tree)</code></pre><p>Performs the inverse stationary wavelet packet transform (ISWPT) on the <code>swpd</code> transform coefficients with respect to a given Boolean Vector that represents a binary <code>tree</code> and the BitVector <code>ε</code> which represents the shifts to be used. If <code>ε</code> is not provided, the average-basis ISWPT will be computed instead. </p><p><strong>See also:</strong> <code>isdwt</code>, <code>swpd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L127-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt" href="#WaveletsExt.SWT.sdwt"><code>WaveletsExt.SWT.sdwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sdwt(x, wt[, L=maxtransformlevels(x)])</code></pre><p>Perform a stationary discrete wavelet transform (SDWT) of the array <code>x</code>. The wavelet type <code>wt</code> determines the transform type and the wavelet class, see  <code>wavelet</code>. </p><p>The number of transform levels <code>L</code> can be 1 ≤ L ≤ <code>maxtransformlevels(x)</code>. Default value is set to <code>maxtransformlevels(x)</code>.</p><p>Returns the <code>n × (L+1)</code> matrix (where <code>n</code> is the length of <code>x</code>) with the detail coefficients for level j in column (L-j+2). The scaling coefficients are in the 1st column.</p><p><strong>See also:</strong> <code>swpd</code>, <code>swpt</code>, <code>isdwt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L35-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt_step" href="#WaveletsExt.SWT.sdwt_step"><code>WaveletsExt.SWT.sdwt_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sdwt_step(v, j, h, g)</code></pre><p>Perform one level of the stationary discrete wavelet transform (SDWT) on the  vector <code>v</code>, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors <code>h</code> and <code>g</code> are the detail and scaling filters.</p><p>Returns a tuple <code>(v, w)</code> of the scaling and detail coefficients at level <code>j+1</code>.</p><p><strong>See also:</strong> <code>sdwt_step!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt_step!" href="#WaveletsExt.SWT.sdwt_step!"><code>WaveletsExt.SWT.sdwt_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sdwt_step!(v1, w1, v, j, h, g)</code></pre><p>Same as <code>sdwt_step</code> but without array allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpd" href="#WaveletsExt.SWT.swpd"><code>WaveletsExt.SWT.swpd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swpd(x, wt[, L=maxtransformlevels(x)])</code></pre><p>Perform a stationary wavelet packet decomposition (SPWD) of the array <code>x</code>. The  wavelet type <code>wt</code> determines the transform type and the wavelet class, see  <code>wavelet</code>.</p><p>The number of transform levels <code>L</code> can be 1 ≤ L ≤ <code>maxtransformlevels(x)</code>. Default value is set to <code>maxtransformlevels(x)</code>.</p><p>Returns the <code>n × (2⁽ᴸ⁺¹⁾-1)</code> matrix (where <code>n</code> is the length of <code>x</code>) with each  column representing the nodes in the binary tree.</p><p><strong>See also:</strong> <code>swpt</code>, <code>sdwt</code>, <code>iswpt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L53-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpt" href="#WaveletsExt.SWT.swpt"><code>WaveletsExt.SWT.swpt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swpt(x, wt[, L=maxtransformlevels(x)])

swpt(x, wt, tree)

swpt(x, h, g, tree)

swpt(x, h, g, tree, i)</code></pre><p>Performs the stationary wavelet packet transform (SWPT) of the vector <code>x</code> of  length <code>N = 2ᴸ</code>. The wavelet type <code>wt</code> determines the transform type and the  wavelet class, see <code>wavelet</code>.</p><p>The number of transform levels <code>L</code> can be 1 ≤ L ≤ <code>maxtransformlevels(x)</code>. Default value is set to <code>maxtransformlevels(x)</code>.</p><p>Returns the expansion coefficients of the SWPT of the size <code>N × k</code>. Each column  represents a leaf node from <code>tree</code>. Number of returned columns can vary between  1 ≤ k ≤ N depending on the input <code>tree</code>.</p><p><strong>See also:</strong> <code>sdwt</code>, <code>swpd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/SWT.jl#L70-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.coarsestscalingrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T&lt;:Number" href="#WaveletsExt.Utils.coarsestscalingrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T&lt;:Number"><code>WaveletsExt.Utils.coarsestscalingrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coarsestscalingrange(x, tree[, redundant=false])

coarsestscalingrange(n, tree[, redundant=false])</code></pre><p>Given a binary tree, returns the index range of the coarsest scaling  coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.finestdetailrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T&lt;:Number" href="#WaveletsExt.Utils.finestdetailrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T&lt;:Number"><code>WaveletsExt.Utils.finestdetailrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">finestdetailrange(x, tree[, redundant=false])

finestdetailrange(n, tree[, redundant=false])</code></pre><p>Given a binary tree, returns the index range of the coarsest scaling  coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.generatesignals-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Integer}, Tuple{AbstractVector{T}, Integer, Integer, Bool}, Tuple{AbstractVector{T}, Integer, Integer, Bool, Real}} where T&lt;:Number" href="#WaveletsExt.Utils.generatesignals-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Integer}, Tuple{AbstractVector{T}, Integer, Integer, Bool}, Tuple{AbstractVector{T}, Integer, Integer, Bool, Real}} where T&lt;:Number"><code>WaveletsExt.Utils.generatesignals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generatesignals(x, N, k[, noise=false, t=1])</code></pre><p>Given a signal x, returns N shifted versions of the signal, each with shifts of multiples of k. </p><p>Setting <code>noise = true</code> allows randomly generated Gaussian noises of μ = 0,  σ² = t to be added to the circularly shifted signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.getleaf-Tuple{BitVector}" href="#WaveletsExt.Utils.getleaf-Tuple{BitVector}"><code>WaveletsExt.Utils.getleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getleaf(tree)</code></pre><p>Returns the leaf nodes of a tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.left-Tuple{Integer}" href="#WaveletsExt.Utils.left-Tuple{Integer}"><code>WaveletsExt.Utils.left</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">left(i)</code></pre><p>Given the node index <code>i</code>, returns the index of its left node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.nodelength-Tuple{Integer, Integer}" href="#WaveletsExt.Utils.nodelength-Tuple{Integer, Integer}"><code>WaveletsExt.Utils.nodelength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodelength(N, L)</code></pre><p>Returns the node length at level L of a signal of length N. Level L == 0  corresponds to the original input signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.psnr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number" href="#WaveletsExt.Utils.psnr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>WaveletsExt.Utils.psnr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">psnr(x, x₀)</code></pre><p>Returns the peak signal to noise ratio (PSNR) between original signal x₀ and noisy signal x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.relativenorm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Real}} where T&lt;:Number" href="#WaveletsExt.Utils.relativenorm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Real}} where T&lt;:Number"><code>WaveletsExt.Utils.relativenorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relativenorm(x, x₀[, p=2]) where T&lt;:Number</code></pre><p>Returns the relative norm of base p between original signal x₀ and noisy signal x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.right-Tuple{Integer}" href="#WaveletsExt.Utils.right-Tuple{Integer}"><code>WaveletsExt.Utils.right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">right(i)</code></pre><p>Given the node index <code>i</code>, returns the index of its right node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.snr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number" href="#WaveletsExt.Utils.snr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>WaveletsExt.Utils.snr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">snr(x, x₀)</code></pre><p>Returns the signal to noise ratio (SNR) between original signal x₀ and noisy  signal x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Utils.ssim-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}} where T&lt;:Number" href="#WaveletsExt.Utils.ssim-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}} where T&lt;:Number"><code>WaveletsExt.Utils.ssim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ssim(x, x₀)</code></pre><p>Wrapper for <code>assess_ssim</code> function from ImageQualityIndex.jl.</p><p>Returns the Structural Similarity Index Measure (SSIM) between the original  signal/image x₀ and noisy signal/image x. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Utils.jl#L177-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Visualizations.plot_tfbdry-Tuple{BitVector}" href="#WaveletsExt.Visualizations.plot_tfbdry-Tuple{BitVector}"><code>WaveletsExt.Visualizations.plot_tfbdry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_tfbdry(tree[; start=0, nodecolor:white])</code></pre><p>Given a tree, output a visual representation of the leaf nodes, user will  have the option to start the node count of each level with 0 or 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Visualizations.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Visualizations.treenodes_matrix-Tuple{BitVector}" href="#WaveletsExt.Visualizations.treenodes_matrix-Tuple{BitVector}"><code>WaveletsExt.Visualizations.treenodes_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">treenodes_matrix(x)</code></pre><p>Given a <code>BitVector</code> of nodes in a binary tree, output the matrix representation  of the nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Visualizations.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Visualizations.wiggle!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number" href="#WaveletsExt.Visualizations.wiggle!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>WaveletsExt.Visualizations.wiggle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wiggle!(wav; taxis=1:size(wav,1), zaxis=1:size(wav,2), sc=1, 
    EdgeColor=:black, FaceColor=:black, Orient=:across, Overlap=true, 
    ZDir=:normal)</code></pre><p>Plot a set of shaded wiggles on the current displayed graphics</p><p><strong>Arguments</strong></p><ul><li>&#39;wav::AbstractArray{&lt;:Number,2}&#39;: matrix of waveform columns.</li><li>&#39;taxis::AbstractVector=1:size(wav,1)&#39;: time axis vector</li><li>&#39;zaxis::AbstractVector=1:size(wav,2)&#39;: space axis vector</li><li>&#39;sc::Real=1&#39;: scale factor/magnification.</li><li>&#39;EdgeColor::Symbol=:black&#39;: Sets edge of wiggles color.</li><li>&#39;FaceColor::Symbol=:black&#39;: Sets shading color of wiggles.</li><li>&#39;Overlap::Bool=true&#39;: How signals are scaled.       true  - Signals overlap (default);       false - Signals are scaled so they do not overlap.</li><li>&#39;Orient::Symbol=:across&#39;: Controls orientation of wiggles.       :across - from left to right       :down   - from top to down</li><li>&#39;ZDir::Symbol=:normal&#39;: Direction of space axis.       :normal  - First signal at bottom (default)       :reverse - First signal at top.</li></ul><p>Translated by Nicholas Hausch – MATLAB file provided by Naoki Saito The previous MATLAB version contributors are:     Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC) Revised by Naoki Saito, Feb. 05, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Visualizations.jl#L202-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.Visualizations.wiggle-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number" href="#WaveletsExt.Visualizations.wiggle-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>WaveletsExt.Visualizations.wiggle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wiggle(wav; taxis=1:size(wav,1), zaxis=1:size(wav,2), sc=1, 
    EdgeColor=:black, FaceColor=:black, Orient=:across, Overlap=true, 
    ZDir=:normal)</code></pre><p>Plot a set of shaded wiggles.</p><p><strong>Arguments</strong></p><ul><li>&#39;wav::AbstractArray{&lt;:Number, 2}&#39;: matrix of waveform columns.</li><li>&#39;taxis::AbstractVector=1:size(wav,1)&#39;: time axis vector</li><li>&#39;zaxis::AbstractVector=1:size(wav,2)&#39;: space axis vector</li><li>&#39;sc::Real=1&#39;: scale factor/magnification.</li><li>&#39;EdgeColor::Symbol=:black&#39;: Sets edge of wiggles color.</li><li>&#39;FaceColor::Symbol=:black&#39;: Sets shading color of wiggles.</li><li>&#39;Overlap::Bool=true&#39;: How signals are scaled.       true  - Signals overlap (default);       false - Signals are scaled so they do not overlap.</li><li>&#39;Orient::Symbol=:across&#39;: Controls orientation of wiggles.       :across - from left to right       :down   - from top to down</li><li>&#39;ZDir::Symbol=:normal&#39;: Direction of space axis.       :normal  - First signal at bottom (default)       :reverse - First signal at top.</li></ul><p>Translated by Nicholas Hausch – MATLAB file provided by Naoki Saito The previous MATLAB version contributors are:     Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC) Revised by Naoki Saito, Feb. 05, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/Visualizations.jl#L80-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WPD.wpd" href="#WaveletsExt.WPD.wpd"><code>WaveletsExt.WPD.wpd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wpd(x, wt[, L=maxtransformlevels(x)])

wpd(x, wt, hqf, gqf[, L=maxtransformlevels(x)])</code></pre><p>Returns the wavelet packet decomposition WPD) for L levels for input signal(s)  x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/WPD.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.WPD.wpd!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet, Integer}} where T&lt;:Number" href="#WaveletsExt.WPD.wpd!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet, Integer}} where T&lt;:Number"><code>WaveletsExt.WPD.wpd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wpd!(y, x, wt[, L=maxtransformlevels(x)])

wpd!(y, x, wt, hqf, gqf[, L=maxtransformlevels(x)])</code></pre><p>Same as <code>wpd</code> but without array allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zengfung/WaveletsExt.jl/blob/8574c113ea580946f8ebf21733863f6ca95b2532/src/mod/WPD.jl#L42-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../denoising/">« Denoising Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 20 April 2021 02:10">Tuesday 20 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
