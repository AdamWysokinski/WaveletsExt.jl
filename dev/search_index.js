var documenterSearchIndex = {"docs":
[{"location":"api/siwpd/#Shift-Invariant-Wavelet-Packet-Decomposition","page":"SIWPD","title":"Shift Invariant Wavelet Packet Decomposition","text":"","category":"section"},{"location":"api/siwpd/","page":"SIWPD","title":"SIWPD","text":"Modules = [SIWPD]","category":"page"},{"location":"api/siwpd/#Public-API","page":"SIWPD","title":"Public API","text":"","category":"section"},{"location":"api/siwpd/","page":"SIWPD","title":"SIWPD","text":"Modules = [SIWPD]\nPrivate = false","category":"page"},{"location":"api/siwpd/#WaveletsExt.SIWPD.makesiwpdtree-Tuple{Integer, Integer, Integer}","page":"SIWPD","title":"WaveletsExt.SIWPD.makesiwpdtree","text":"makesiwpdtree(n, L, d)\n\nReturns the multi-level, multi-depth binary tree corresponding to the Shift- Invariant Wavelet Packet Decomposition. \n\n\n\n\n\n","category":"method"},{"location":"api/siwpd/#WaveletsExt.SIWPD.siwpd-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, OrthoFilter}, Tuple{AbstractArray{T, N} where N, OrthoFilter, Integer}, Tuple{AbstractArray{T, N} where N, OrthoFilter, Integer, Integer}} where T<:Number","page":"SIWPD","title":"WaveletsExt.SIWPD.siwpd","text":"siwpd(x, wt[, L=maxtransformlevels(x), d=L])\n\nComputes the Shift-Invariant Wavelet Packet Decomposition originally developed by Cohen, Raz & Malah on the vector x using the discrete wavelet filter wt for L levels with depth d.\n\n\n\n\n\n","category":"method"},{"location":"manual/transforms/#transforms_manual","page":"Transforms","title":"Wavelet Transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Wavelet transform is a feature extraction process for decomposing signals into high and low frequency segments. Using a pair of orthonormal wavelet psi in L^2(mathbbR), where L^2(mathbbR) is a Hilbert space of square integrable functions, one can compute","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"y_low = g(x) where x is the signal of interest, g is the low pass filter corresponding to psi, and y_low is the output when x passes through g.\ny_high = h(x) where x is the signal of interest, h is the high pass filter corresponding to psi, and y_high is the output when x passes through h.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The wavelet transform can be thought of as an improvement over the Fourier transform due to its ability to preserve information in both the time and frequency domains. It has vast applications in fields such as signal analysis and image compression.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"As an extension to Wavelets.jl, WaveletsExt.jl offers additional (redundant) wavelet transform techniques via autocorrelation wavelet transforms (Beylkin, Saito), stationary wavelet transforms (Nason, Silverman), and shift invariant wavelet transform (Cohen et. al.).","category":"page"},{"location":"manual/transforms/#Wavelet-Transform-Methods","page":"Transforms","title":"Wavelet Transform Methods","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"There are essentially 3 methods of wavelet transforms: discrete wavelet transforms, wavelet packet transforms, and wavelet packet decomposition. The overall idea of signals being decomposed into high and low frequency segments remain the same, but the number of levels of decomposition for each segment may vary.","category":"page"},{"location":"manual/transforms/#Discrete-Wavelet-Transforms-(DWT)","page":"Transforms","title":"Discrete Wavelet Transforms (DWT)","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The discrete wavelet transfrom only iteratively decomposes the approximation coefficients at each level, ie. iteratively transforms the output from the low pass filter. The coefficients of the leaf nodes are returned. See Figure 1 for a visualization of the DWT transform process and output.","category":"page"},{"location":"manual/transforms/#Wavelet-Packet-Transforms-(WPT)","page":"Transforms","title":"Wavelet Packet Transforms (WPT)","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The wavelet packet transform takes the decomposition process one step further and itereatively decomposes on both the approximation and detail coefficients, ie. both the outputs from the low pass filter and high pass filter are being iteratively decomposed. The coefficients of the leaf nodes are returned.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"An extension to WPT is that one can decompose a signal based on a given tree. See Figure 1 for better visualization of the transform process.","category":"page"},{"location":"manual/transforms/#Wavelet-Packet-Decomposition-(WPD)","page":"Transforms","title":"Wavelet Packet Decomposition (WPD)","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The wavelet packet decomposition functions similarly to WPT, except that all the coefficients (regardless of whether they're at the lead node) are retained in the output. The WPD is useful for selecting the wavelet best basis and feature extraction algorithms such as Local Discriminant Basis.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Discrete Wavelet Transform Wavelet Packet Transform Wavelet Packet Decomposition\n(Image: ) (Image: ) (Image: )\n (Image: ) ","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Figure 1: Decomposition method for DWT, WPT, and WPD respectively. Coefficient outputs from DWT, WPT, and WPD are highlighted in red.","category":"page"},{"location":"manual/transforms/#Types-of-Wavelet-Transforms-and-Their-Examples-in-WaveletsExt.jl","page":"Transforms","title":"Types of Wavelet Transforms and Their Examples in WaveletsExt.jl","text":"","category":"section"},{"location":"manual/transforms/#Regular-Wavelet-Transform","page":"Transforms","title":"Regular Wavelet Transform","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The standard wavelet transform (DWT and WPT) from Wavelets.jl and the WPD can be performed as follows:","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"using Wavelets, WaveletsExt\n\n# Define function and wavelet\nx = generatesignals(:heavisine, 8)\nwt = wavelet(WT.db4)\n\n# ----- Discrete Wavelet Transform (DWT) -----\ny = dwt(x, wt)      # Forward transform\nz = idwt(y, wt)     # Inverse transform\n\n# ----- Wavelet Packet Transform (WPT) -----\ny = wpt(x, wt)      # Forward transform\nz = iwpt(y, wt)     # Inverse transform\n\n# ----- Wavelet Packet Decomposition (WPD) -----\ny = wpd(x, wt)      # Decompose into L levels\nnothing # hide","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"In the case where there are multiple signals to transform, one may opt for dwtall, wptall, and wpdall.","category":"page"},{"location":"manual/transforms/#s_transforms","page":"Transforms","title":"Stationary Wavelet Transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The stationary wavelet transform is a redundant type of wavelet transform. This means that there are no downsampling involved unlike the standard transforms, resulting in an exponentially larger number of coefficients compared to that of the standard transforms. A strength of the stationary wavelet transform is its ability to retain more information, thereby being more useful in certain signal analysis applications such as denoising. However, it also takes an exponentially larger amount of time and space to decompose a signal compared to the standard transforms.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# ----- Discrete Wavelet Transform (DWT) -----\ny = sdwt(x, wt)     # Forward transform\nz = isdwt(y, wt)    # Inverse transform\n\n# ----- Wavelet Packet Decomposition (WPD) -----\ny = swpd(x, wt)     # Decompose into L levels\nnothing # hide","category":"page"},{"location":"manual/transforms/#ac_transforms","page":"Transforms","title":"Autocorrelation Wavelet Transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The autocorrelation wavelet transforms, similar to the stationary transforms, is a redundant type of wavelet transform. This also means that there is no downsampling involved unlike the standard transforms, and that more information is retained. ","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"While the decomposition process is still slower than that of the standard transform, its reconstruction process is extremely quick as it only requires the iterative summation of approximation and detail coefficients.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# ----- Discrete Wavelet Transform (DWT) -----\ny = acdwt(x, wt)    # Forward transform\nz = iacdwt(y)       # Inverse transform\n\n# ----- Wavelet Packet Decomposition (WPD) -----\ny = acwpd(x, wt)    # Decompose into L levels\nnothing # hide","category":"page"},{"location":"manual/transforms/#Comparisons-between-standard,-autocorrelation,-and-stationary-wavelet-transforms","page":"Transforms","title":"Comparisons between standard, autocorrelation, and stationary wavelet transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"1D Example:","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"using Wavelets, WaveletsExt, Plots\n\n# Define signal and wavelet\nx = zeros(256); x[128] = 1;\nwt = wavelet(WT.db4);\n\n# Wavelet transforms\nxw0 = dwt(x, wt, 4);\nxw0 = [repeat(xw0[1:16],inner=16) repeat(xw0[17:32], inner=16) repeat(xw0[33:64], inner=8) repeat(xw0[65:128], inner=4) repeat(xw0[129:256], inner=2)]; nothing # hide\nxw1 = sdwt(x, wt, 4);\nxw2 = acdwt(x, wt, 4);\n\n# Wiggle plots\np0 = wiggle(xw0, Overlap=false) \nplot!(p0, yticks=1:5, title=\"Standard WT\")\np1 = wiggle(xw1, Overlap=false) \nplot!(p1, yticks=1:5, title=\"Stationary WT\")\np2 = wiggle(xw2, Overlap=false)\nplot!(p2, yticks=1:5, title=\"Autocorrelation WT\")\nplot(p0, p1, p2, layout=(1,3))","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"2D Example","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"using Images, TestImages\n\nimg = testimage(\"cameraman\");\nx = convert(Array{Float64}, img);\n\n# Wavelet Transforms\nxw0 = dwt(x, wt, 1);\nxw1 = sdwt(x, wt, 1);\nxw2 = acdwt(x, wt, 1);\n\n# Outputs\np0 = heatmap(xw0, yflip=true, color=:greys, legend=false, xaxis=false, yaxis=false, xticks=false, yticks=false);\nplot!(p0, title=\"Standard WT\")\np1 = heatmap([xw1[:,:,1] xw1[:,:,2]; xw1[:,:,3] xw1[:,:,4]], yflip=true, color=:greys, legend=false, xaxis=false, yaxis=false, xticks=false, yticks=false)\nplot!(p1, title=\"Stationary WT\")\np2 = heatmap([xw2[:,:,1] xw2[:,:,2]; xw2[:,:,3] xw2[:,:,4]], yflip=true, color=:greys, legend=false, xaxis=false, yaxis=false, xticks=false, yticks=false)\nplot!(p2, title=\"Autocorrelation WT\")\nplot(plot(img, title=\"Original\"), p0, p1, p2, layout=(2,2))","category":"page"},{"location":"manual/transforms/#si_transforms","page":"Transforms","title":"Shift Invariant Wavelet Packet Decomposition","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The Shift-Invariant Wavelet Decomposition (SIWPD) is developed by Cohen et. al.. While it is also a type of redundant transform, it does not follow the same methodology as the SWT and the ACWT. Cohen's main goal for developing this algorithm was to obtain a global minimum entropy from a signal and all its shifted versions. See its best basis implementation for more information.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"One can compute the SIWPD of a single signal as follows.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# decomposition\nxw = siwpd(x, wt);\nnothing # hide","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"note: Note\nAs of right now, there is not too many functions written based on the SIWPD, as it does not follow the conventional style of wavelet transforms. There is a lot of ongoing work to develop more functions catered for the SIWPD such as it's inverse transforms and group-implementations.","category":"page"},{"location":"api/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/utils/#Public-API","page":"Utils","title":"Public API","text":"","category":"section"},{"location":"api/utils/#Useful-wavelet/signal-utilities","page":"Utils","title":"Useful wavelet/signal utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Wavelets.Util.maxtransformlevels\nUtils.getbasiscoef\nUtils.getbasiscoefall\nUtils.getrowrange\nUtils.getcolrange\nUtils.nodelength\nUtils.coarsestscalingrange\nUtils.finestdetailrange","category":"page"},{"location":"api/utils/#Wavelets.Util.maxtransformlevels","page":"Utils","title":"Wavelets.Util.maxtransformlevels","text":"maxtransformlevels(n)\n\nmaxtransformlevels(x[, dims])\n\nExtension function from Wavelets.jl. Finds the max number of transform levels for an array x. If dims is provided for a multidimensional array, then it finds the max transform level for that corresponding dimension.\n\nArguments\n\nx::AbstractArray: Input array.\ndims::Integer: Dimension used for wavelet transform.\nn::Integer: Length of input vector.\n\nReturns\n\n::Integer: Max number of transform levels.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Define random signal\nx = randn(64, 128)\n\n# Max transform levels and their corresponding return values\nmaxtransformlevels(128)     # 7\nmaxtransformlevels(x)       # 6\nmaxtransformlevels(x, 2)    # 7\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getbasiscoef","page":"Utils","title":"WaveletsExt.Utils.getbasiscoef","text":"getbasiscoef(Xw, tree)\n\nGet the basis coefficients for the decomposed signal Xw with respect to the tree tree.\n\nArguments\n\nXw::AbstractArray{T,2} where T<:Number: Decomposed 1D-signal.\ntree::BitVector: The corresponding basis tree.\n\nReturns\n\n::Array{T,1}: Basis coefficients of signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate signal and wavelet\nx = generatesignals(:heavysine)\nwt = wavelet(WT.db4)\n\n# Decompose signal\nXw = iwpd(x, wt)\ntree = maketree(128, 6, :dwt)\n\n# Get basis coefficients\nxw = getbasiscoef(Xw, tree)\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getbasiscoefall","page":"Utils","title":"WaveletsExt.Utils.getbasiscoefall","text":"getbasiscoefall(Xw, tree)\n\nGet the basis coefficients for all decomposed signals in Xw with respect to the tree(s) tree.\n\nArguments\n\nXw::AbstractArray{T,3} where T<:Number: A set of decomposed 1D-signals.\ntree::BitVector or tree::BitArray{2}: The corresponding basis tree(s). If input is a BitMatrix, each column corresponds to a signal in Xw, and therefore the number of columns must be equal to the number of signals.\n\nReturns\n\n::Array{T,2}: Basis coefficients of signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate signals and wavelet\nc = ClassData(:cbf, 10, 10, 10)\nX = generateclassdata(c)\nwt = wavelet(WT.db4)\n\n# Decompose signals\nXw = iwpdall(X, wt)\ntree = maketree(128, 6, :dwt)\n\n# Get basis coefficients\ngetbasiscoefall(Xw, tree)\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getrowrange","page":"Utils","title":"WaveletsExt.Utils.getrowrange","text":"getrowrange(n, idx)\n\nGet the row range from a matrix with n rows that corresponds to idx from a quadtree.\n\nArguments\n\nn::Integer: Number of rows in matrix.\nidx::T where T<:Integer: Index from a quadtree corresponding to the matrix.\n\nReturns\n\n::UnitRange{Int64}: Row range in matrix that corresponds to idx.\n\nExamples\n\nusing WaveletsExt\n\nx = randn(8,8)\ntree = maketree(x, 3, :full)\ngetrowrange(8,3)            # 1:4\n\nSee also: Wavelets.Util.maketree, getcolrange\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getcolrange","page":"Utils","title":"WaveletsExt.Utils.getcolrange","text":"getcolrange(n, idx)\n\nGet the column range from a matrix with n columns that corresponds to idx from a quadtree.\n\nArguments\n\nn::Integer: Number of columns in matrix.\nidx::T where T<:Integer: Index from a quadtree corresponding to the matrix.\n\nReturns\n\n::UnitRange{Int64}: Column range in matrix that corresponds to idx.\n\nExamples\n\nusing WaveletsExt\n\nx = randn(8,8)\ntree = maketree(x, 3, :full)\ngetcolrange(8,3)            # 5:8\n\nSee also: Wavelets.Util.maketree, getrowrange\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.nodelength","page":"Utils","title":"WaveletsExt.Utils.nodelength","text":"nodelength(N, L)\n\nReturns the node length at level L of a signal of length N when performaing wavelet packet decomposition. Level L == 0 corresponds to the original input signal.\n\nArguments\n\nN::Integer: Length of signal.\nL::Integer: Level of signal.\n\nReturns\n\n::Integer: Length of nodes at level L.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.coarsestscalingrange","page":"Utils","title":"WaveletsExt.Utils.coarsestscalingrange","text":"coarsestscalingrange(x, tree[, redundant])\ncoarsestscalingrange(n, tree[, redundant])\n\nGiven a binary tree, returns the index range of the coarsest scaling coefficients.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Decomposed 1D-signal.\nn::Integer: Length of signal of interest.\ntree::BitVector: Binary tree.\nredundant::Bool: (Default: false) Whether the wavelet decomposition is redundant. Examples of redundant wavelet transforms are the Autocorrelation wavelet transform (ACWT), Stationary wavelet transform (SWT), and the Maximal Overlap wavelet transform (MOWT).\n\nReturns\n\nUnitRange{Integer} or ::Tuple{UnitRange{Integer}, Integer}: The index range of the coarsest scaling subspace based on the input binary tree.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nx = randn(8)\nwt = wavelet(WT.haar)\ntree = maketree(x)\n\n# Non-redundant wavelet transform\nxw = wpd(x, wt)\ncoarsestscalingrange(xw, tree)          # 1:1\n\n# Redundant wavelet transform\nxw = swpd(x, wt)\ncoarsestscalingrange(xw, tree, true)    # (1:8, 8)\n\nSee also: finestdetailrange\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.finestdetailrange","page":"Utils","title":"WaveletsExt.Utils.finestdetailrange","text":"finestdetailrange(x, tree[, redundant])\nfinestdetailrange(n, tree[, redundant])\n\nGiven a binary tree, returns the index range of the finest detail coefficients.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Decomposed 1D-signal.\nn::Integer: Length of signal of interest.\ntree::BitVector: Binary tree.\nredundant::Bool: (Default: false) Whether the wavelet decomposition is redundant. Examples of redundant wavelet transforms are the Autocorrelation wavelet transform (ACWT), Stationary wavelet transform (SWT), and the Maximal Overlap wavelet transform (MOWT).\n\nReturns\n\nUnitRange{Integer} or ::Tuple{UnitRange{Integer}, Integer}: The index range of the finest detail subspace based on the input binary tree.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nx = randn(8)\nwt = wavelet(WT.haar)\ntree = maketree(x)\n\n# Non-redundant wavelet transform\nxw = wpd(x, wt)\nfinestdetailrange(xw, tree)          # 8:8\n\n# Redundant wavelet transform\nxw = swpd(x, wt)\nfinestdetailrange(xw, tree, true)    # (1:8, 15)\n\nSee also: coarsestscalingrange\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Tree-traversing-functions","page":"Utils","title":"Tree traversing functions","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Wavelets.Util.isvalidtree\nWavelets.Util.maketree\nUtils.getchildindex\nUtils.getparentindex\nUtils.getleaf\nUtils.getdepth\nUtils.gettreelength","category":"page"},{"location":"api/utils/#Wavelets.Util.isvalidtree","page":"Utils","title":"Wavelets.Util.isvalidtree","text":"isvalidtree(x, b)\n\nCheck if tree is a valid tree for the signal x.\n\nArguments\n\nx::AbstractVector or x::AbstractMatrix: Signal (1D or 2D).\nb::BitVector: Tree to represent x.\n\nReturns\n\n::Bool: Whether tree is valid.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Wavelets.Util.maketree","page":"Utils","title":"Wavelets.Util.maketree","text":"maketree(x::Vector, s::Symbol=:full)\nmaketree(n::Int, L::Int, s::Symbol=:full)\n\nreturn a tree (BitVector) s=:full, all nodes for first L levels equal 1, others 0 s=:dwt, nodes corresponding to a dwt for first L levels equal 1, others 0\n\n\n\n\n\nmaketree(x[, s])\nmaketree(n, m, L[, s])\n\nBuild quadtree for 2D wavelet transform. Indexing of the tree are as follows:\n\nLevel 0                 Level 1                 Level 2             ...\n_________________       _________________       _________________\n|               |       |   2   |   3   |       |_6_|_7_|10_|11_|\n|       1       |       |_______|_______|       |_8_|_9_|12_|13_|   ...\n|               |       |   4   |   5   |       |14_|15_|18_|19_|\n|_______________|       |_______|_______|       |16_|17_|20_|21_|\n\nArguments\n\nx::AbstractMatrix{T} where T<:Number: Input array.\nn::Integer: Number of rows in x.\nm::Integer: Number of columns in x.\nL::Integer: Number of decomposition levels.\ns::Symbol: (Default: :full) Type of quadtree. Available types are :full and :dwt.\n\nReturns\n\n::BitVector: Quadtree representation.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nx = randn(16,16)\nmaketree(x)\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getchildindex","page":"Utils","title":"WaveletsExt.Utils.getchildindex","text":"getchildindex(idx, child)\n\nGet the child index of a parent index idx.\n\nArguments\n\nidx::T where T<:Integer: Index of parent node.\nchild::Symbol: Type of child. For binary trees, available children are :left and :right. For quadtrees, available children are :topleft, :topright, :bottomleft, :bottomright.\n\nReturns\n\n::T: Index of child node.\n\nExamples\n\nusing WaveletsExt\n\ngetchildindex(3,:left) == 6\ngetchildindex(3,:right) == 7\ngetchildindex(3,:topleft) == 22\ngetchildindex(3,:topright) == 23\ngetchildindex(3,:bottomleft) == 24\ngetchildindex(3,:bottomright) == 25\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getparentindex","page":"Utils","title":"WaveletsExt.Utils.getparentindex","text":"getparentindex(idx, tree_type)\n\nGet the parent index of the child node idx.\n\nArguments\n\nidx::T where T<:Integer: Index of child node.\ntree_type::Symbol: Tree type, ie. :binary tree or :quad tree.\n\nReturns\n\n::T: Index of parent node.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getleaf","page":"Utils","title":"WaveletsExt.Utils.getleaf","text":"getleaf(tree, tree_type)\n\nReturns the leaf nodes of a tree.\n\nArguments\n\ntree::BitVector: BitVector to represent binary tree.\n\nReturns\n\n::BitVector: BitVector that can represent a binary tree, but only the leaves are labeled 1, the rest of the nodes are labeled 0.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\ntree = maketree(4, 2, :dwt)     # [1,1,0]\ngetleaf(tree)                   # [0,0,1,1,1,0,0]\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.getdepth","page":"Utils","title":"WaveletsExt.Utils.getdepth","text":"getdepth(idx, tree_type)\n\nGet depth of idx in a binary tree or quadtree.\n\nArguments\n\nidx::T where T<:Integer: Index of a node.\ntree_type::Symbol: Tree type. Supported types are :binary and :quad trees.\n\nReturns\n\n::T: Depth of node idx.\n\nExamples\n\nusing WaveletsExt\n\ngetdepth(1,:binary)     # 0\ngetdepth(3,:binary)     # 1\ngetdepth(8,:binary)     # 3\n\ngetdepth(1,:quad)       # 0\ngetdepth(3,:quad)       # 1\ngetdepth(8,:quad)       # 2\n\nSee also: Wavelets.Util.maketree\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.gettreelength","page":"Utils","title":"WaveletsExt.Utils.gettreelength","text":"gettreelength(n[, m])\n\nCompute the length of the binary/quad tree BitVector.\n\nArguments\n\nn::T where T<:Integer: Array size at 1st dimension/Signal length for 1D-signals.\nm::T where T<:Integer: Array size at 2nd dimension.\n\nReturns\n\n::T: Length of binary/quad tree.\n\nExamples\n\nusing WaveletsExt\n\nUtils.gettreelength(8)          # 7\nUtils.gettreelength(8,8)        # 21\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Metrics","page":"Utils","title":"Metrics","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Utils.relativenorm\nUtils.psnr\nUtils.snr\nUtils.ssim","category":"page"},{"location":"api/utils/#WaveletsExt.Utils.relativenorm","page":"Utils","title":"WaveletsExt.Utils.relativenorm","text":"relativenorm(x, x₀[, p]) where T<:Number\n\nReturns the relative norm of base p between original signal x₀ and noisy signal x.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Signal with noise.\nx₀::AbstractArray{T} where T<:Number: Reference signal.\np::Real: (Default: 2) p-norm to be computed.\n\nReturns\n\n::AbstractFloat: The relative norm between x and x₀.\n\nExamples\n\nusing WaveletsExt\n\nx = randn(8)\ny = randn(8)\n\nrelativenorm(x, y)\n\nSee also: psnr, snr, ssim\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.psnr","page":"Utils","title":"WaveletsExt.Utils.psnr","text":"psnr(x, x₀)\n\nReturns the peak signal to noise ratio (PSNR) between original signal x₀ and noisy signal x.\n\nPSNR definition: 10 log_10 fracmax(x_0)^2MSE(x x_0)\n\nArguments\n\nx::AbstractVector{T} where T<:Number: Signal with noise.\nx₀::AbstractVector{T} where T<:Number: Reference signal.\n\nReturns\n\n::AbstractFloat: The PSNR between x and x₀.\n\nExamples\n\nusing WaveletsExt\n\nx = randn(8)\ny = randn(8)\n\npsnr(x, y)\n\nSee also: relativenorm, snr, ssim\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.snr","page":"Utils","title":"WaveletsExt.Utils.snr","text":"snr(x, x₀)\n\nReturns the signal to noise ratio (SNR) between original signal x₀ and noisy signal x.\n\nSNR definition: 20 log_10 fracx_0_2x-x_0_2\n\nArguments\n\nx::AbstractVector{T} where T<:Number: Signal with noise.\nx₀::AbstractVector{T} where T<:Number: Reference signal.\n\nReturns\n\n::AbstractFloat: The SNR between x and x₀.\n\nExamples\n\nusing WaveletsExt\n\nx = randn(8)\ny = randn(8)\n\nsnr(x, y)\n\nSee also: relativenorm, psnr, ssim\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.ssim","page":"Utils","title":"WaveletsExt.Utils.ssim","text":"ssim(x, x₀)\n\nWrapper for assess_ssim function from ImageQualityIndex.jl.\n\nReturns the Structural Similarity Index Measure (SSIM) between the original signal/image x₀ and noisy signal/image x.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Signal with noise.\nx₀::AbstractArray{T} where T<:Number: Reference signal.\n\nReturns\n\n::AbstractFloat: The SNR between x and x₀.\n\nExamples\n\nusing WaveletsExt\n\nx = randn(8)\ny = randn(8)\n\nssim(x, y)\n\nSee also: relativenorm, psnr, snr\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Dataset-generation","page":"Utils","title":"Dataset generation","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Utils.ClassData\nUtils.duplicatesignals\nUtils.generatesignals\nUtils.generateclassdata","category":"page"},{"location":"api/utils/#WaveletsExt.Utils.ClassData","page":"Utils","title":"WaveletsExt.Utils.ClassData","text":"ClassData(type, s₁, s₂, s₃)\n\nBased on the input type, generates 3 classes of signals with sample sizes s₁, s₂, and s₃ respectively. Accepted input types are:  \n\n:tri: Triangular signals of length 32\n:cbf: Cylinder-Bell-Funnel signals of length 128\n\nBased on N. Saito and R. Coifman in \"Local Discriminant Basis and their Applications\" in the Journal of Mathematical Imaging and Vision, Vol. 5, 337-358 (1995).\n\nSee also: generateclassdata\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#WaveletsExt.Utils.duplicatesignals","page":"Utils","title":"WaveletsExt.Utils.duplicatesignals","text":"duplicatesignals(x, N, k[, noise=false, t=1])\n\nGiven a signal x, returns N shifted versions of the signal, each with shifts of multiples of k. \n\nSetting noise = true allows randomly generated Gaussian noises of μ = 0,  σ² = t to be added to the circularly shifted signals.\n\nArguments\n\nx::AbstractVector{T} where T<:Number: 1D-signal to be duplicated.\nN::Integer:: Number of duplicated signals.\nk::Integer:: Circular shift size for each duplicated signal.\nnoise::Bool: (Default: false) Whether or not to add Gaussian noise.\nt::Real: (Default: 1) Relative size of noise.\n\nReturns\n\n::Array{T}: Duplicated signals.\n\nExamples\n\nusing WaveletsExt\n\nx = generatesignals(:blocks)\nduplicatesignals(x, 5, 0)      # [x x x x x]\n\nSee also: generatesignals\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.generatesignals","page":"Utils","title":"WaveletsExt.Utils.generatesignals","text":"generatesignals(fn, L)\n\nGenerates a signal of length 2ᴸ given the function symbol fn. Current accepted inputs  below are based on D. Donoho and I. Johnstone in \"Adapting to Unknown Smoothness via Wavelet  Shrinkage\" Preprint Stanford, January 93, p 27-28.  \n\n:blocks\n:bumps\n:heavisine\n:doppler\n:quadchirp\n:mishmash\n\nThe code for this function is adapted and translated based on MATLAB's Wavelet Toolbox's  wnoise function.\n\nArguments\n\nfn::Symbol: Type of function/signal to generate.\nL::Integer: (Default = 7) Size of the signal to generate. Will return a signal of size 2ᴸ.\n\nReturns\n\n::Vector{Float64}: Signal of length 2ᴸ.\n\nExamples\n\nusing WaveletsExt\n\ngeneratesignals(:bumps, 8)\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.generateclassdata","page":"Utils","title":"WaveletsExt.Utils.generateclassdata","text":"generateclassdata(c[, shuffle])\n\nGenerates 3 classes of data given a ClassData struct as an input. Returns a matrix  containing the 3 classes of signals and a vector containing their corresponding labels.\n\nBased on N. Saito and R. Coifman in \"Local Discriminant Basis and their Applications\" in the Journal of Mathematical Imaging and Vision, Vol. 5, 337-358 (1995).\n\nArguments\n\nc::ClassData: Type of signal classes to generate.\nshuffle::Bool: (Default: true). Whether or not to shuffle the signals.\n\nReturns\n\n::Matrix{Float64}: Generated signals.\n::Vector{Int64}: Class corresponding to each column of generated signals.\n\nExamples\n\nusing WaveletsExt\n\nc = ClassData(:tri, 100, 100, 100)\ngenerateclassdata(c)\n\nSee also: ClassData\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Private-API","page":"Utils","title":"Private API","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Utils.main2depthshift\nUtils.packet","category":"page"},{"location":"api/utils/#WaveletsExt.Utils.main2depthshift","page":"Utils","title":"WaveletsExt.Utils.main2depthshift","text":"main2depthshift(sm, L)\n\nGiven the overall shift sm, compute the cumulative shift at each depth. Useful for computing the shift based inverse redundant wavelet transforms.\n\nArguments\n\nsm::Integer: Overall shift.\nL::Integer: The total number of depth.\n\nReturns\n\n::Vector{Int}: Vector where each entry i describes the shift at depth i-1.\n\nExamples\n\nusing WaveletsExt\n\nUtils.main2depthshift(10, 4)      # [0, 0, 2, 2, 10]\nUtils.main2depthshift(5, 5)       # [0, 1, 1, 5, 5, 5]\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.packet","page":"Utils","title":"WaveletsExt.Utils.packet","text":"packet(d, b, n)\n\nPacket table indexing.\n\nArguments\n\nd::Integer: Depth of splitting in packet decomposition. Note: Depth of root node is 0.\nb::Integer: Block index among 2ᵈ possibilities at depth d. Note: Block indexing starts from 0.\nn::Integer: Length of signal.\n\nReturns\n\n::UnitRange{Int64}: Index range of block b of signal of length n at level d.\n\nExamples\n\nusing WaveletsExt\n\nUtils.packet(0, 0, 8)       # 1:8\nUtils.packet(2, 1, 8)       # 3:4\n\nTranslated from Wavelab850 by Zeng Fung Liew.\n\n\n\n\n\n","category":"function"},{"location":"api/ldb/#Local-Discriminant-Basis","page":"LDB","title":"Local Discriminant Basis","text":"","category":"section"},{"location":"api/ldb/","page":"LDB","title":"LDB","text":"Modules = [LDB]","category":"page"},{"location":"api/ldb/#Public-API","page":"LDB","title":"Public API","text":"","category":"section"},{"location":"api/ldb/","page":"LDB","title":"LDB","text":"Modules = [LDB]\nPrivate = false","category":"page"},{"location":"api/ldb/#WaveletsExt.LDB.AsymmetricRelativeEntropy","page":"LDB","title":"WaveletsExt.LDB.AsymmetricRelativeEntropy","text":"AsymmetricRelativeEntropy <: ProbabilityDensityDM\n\nAsymmetric Relative Entropy discriminant measure for the Probability Density and Time Frequency based energy maps. This measure is also known as cross entropy  and Kullback-Leibler divergence.\n\nEquation: D(pq) = sum p(x) log fracp(x)q(x)\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.BasisDiscriminantMeasure","page":"LDB","title":"WaveletsExt.LDB.BasisDiscriminantMeasure","text":"BasisDiscriminantMeasure <: DiscriminantPower\n\nThis is the discriminant measure of a single basis function computed in a  previous step to construct the energy maps.\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.DiscriminantMeasure","page":"LDB","title":"WaveletsExt.LDB.DiscriminantMeasure","text":"Discriminant measure for Local Discriminant Basis. Current available subtypes are:\n\nProbabilityDensityDM\nSignaturesDM\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.DiscriminantPower","page":"LDB","title":"WaveletsExt.LDB.DiscriminantPower","text":"Discriminant Power measure for the Local Discriminant Basis. Current available measures are\n\nBasisDiscriminantMeasure\nFishersClassSeparability\nRobustFishersClassSeparability\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.EarthMoverDistance","page":"LDB","title":"WaveletsExt.LDB.EarthMoverDistance","text":"EarthMoverDistance <: SignaturesDM\n\nEarth Mover Distance discriminant measure for the Signatures energy map.\n\nEquation:  E(PQ) = fracsum_k=1^m+n+1 hat p_k - hat q_k (r_k+1 - r_k)w_Sigma\n\nwhere r_1 r_2 ldots r_m+n is the sorted list of p_1 ldots p_m  q_1 ldots q_n and hat p_k = sum_p_i leq r_k w_p_i,  hat q_k = sum_q)i leq r_k w_q_i.\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.EnergyMap","page":"LDB","title":"WaveletsExt.LDB.EnergyMap","text":"Energy map for Local Discriminant Basis. Current available types are:\n\nTimeFrequency\nProbabilityDensity\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.FishersClassSeparability","page":"LDB","title":"WaveletsExt.LDB.FishersClassSeparability","text":"FishersClassSeparability <: DiscriminantPower\n\nThe Fisher's class separability of the expansion coefficients in the basis  function.\n\nEquation: fracsum_c=1^C pi_c(rm mean_i(alpha_lambdai^(c)) - rm mean_c(rm mean_i(alpha_lambdai^(c))))^2sum_c=1^C pi_c rm var_i(alpha_lambdai^(c))\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.HellingerDistance","page":"LDB","title":"WaveletsExt.LDB.HellingerDistance","text":"HellingerDistance <: ProbabilityDensityDM\n\nHellinger Distance discriminant measure for the Probability Density energy  map.\n\nEquation: H(pq) = sum_i=1^n (sqrtp_i - sqrtq_i)^2\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.LocalDiscriminantBasis","page":"LDB","title":"WaveletsExt.LDB.LocalDiscriminantBasis","text":"LocalDiscriminantBasis\n\nClass type for the Local Discriminant Basis (LDB), a feature selection algorithm developed by N. Saito and R. Coifman in \"Local Discriminant Bases and Their Applications\" in the Journal of Mathematical Imaging and Vision, Vol 5, 337-358 (1995). This struct contains the following field values: \n\nParameters and Attributes:\n\nwt::DiscreteWavelet: a discrete wavelet for transform purposes\nmax_dec_level::Union{Integer, Nothing}: max level of wavelet packet   decomposition to be computed.\ndm::DiscriminantMeasure: the discriminant measure for the LDB algorithm.    Supported measures are the AsymmetricRelativeEntropy(), LpDistance(),   SymmetricRelativeEntropy(), and HellingerDistance()\nen::EnergyMap: the type of energy map used. Supported maps are    TimeFrequency(), ProbabilityDensity(), and Signatures().\ndp::DiscriminantPower(): the measure of discriminant power among expansion   coefficients. Supported measures are BasisDiscriminantMeasure(),   FishersClassSeparability(), and RobustFishersClassSeparability(). \ntop_k::Union{Integer, Nothing}: the top-k coefficients used in each node to    determine the discriminant measure.\nn_features::Union{Integer, Nothing}: the dimension of output after    undergoing feature selection and transformation.\nn::Union{Integer, Nothing}: length of signal\n`Γ::Union{AbstractArray{<:AbstractFloat}, \n\nAbstractArray{NamedTuple{(:coef, :weight), Tuple{S1, S2}}} where {S1<:Array{T}      where T<:AbstractFloat, S2<:Union{AbstractFloat, Array{<:AbstractFloat}}},     Nothing}`: computed energy map\n\nDM::Union{AbstractArray{<:AbstractFloat}, Nothing}: computed discriminant   measure\ncost::Union{AbstractVector{<:AbstractFloat}, Nothing}: computed wavelet   packet decomposition (WPD) tree cost based on the discriminant measure DM.\ntree::Union{BitVector, Nothing}: computed best WPD tree based on the    discriminant measure DM.\nDP::Union{AbstractVector{<:AbstractFloat}, Nothing}: computed discriminant    power\norder::Union{AbstractVector{Integer}, Nothing}: ordering of DP by    descending order.\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.LocalDiscriminantBasis-Tuple{}","page":"LDB","title":"WaveletsExt.LDB.LocalDiscriminantBasis","text":"LocalDiscriminantBasis([; \n    wt=wavelet(WT.haar),\n    max_dec_level=nothing,\n    dm=AsymmetricRelativeEntropy(), em=TimeFrequency(), \n    dp=BasisDiscriminantMeasure(), top_k=nothing,\n    n_features=nothing]\n)\n\nClass constructor for LocalDiscriminantBasis. \n\nArguments:\n\nwt::DiscreteWavelet: Wavelet used for decomposition of signals. Default is   set to be wavelet(WT.haar).\nmax_dec_level::Union{Integer, Nothing}: max level of wavelet packet   decomposition to be computed. When max_dec_level=nothing, the maximum   transform levels will be used. Default is set to be nothing.\ndm::DiscriminantMeasure: the discriminant measure for the LDB algorithm.    Supported measures are the AsymmetricRelativeEntropy(), LpDistance(),    SymmetricRelativeEntropy(), and HellingerDistance(). Default is set to   be AsymmetricRelativeEntropy().\nen::EnergyMap: the type of energy map used. Supported maps are    TimeFrequency() and ProbabilityDensity(). Default is set to be    TimeFrequency().\ndp::DiscriminantPower=BasisDiscriminantMeasure(): the measure of    discriminant power among expansion coefficients. Supported measures are    BasisDiscriminantMeasure(), FishersClassSeparability(), and    RobustFishersClassSeparability(). Default is set to be BasisDiscriminantMeasure().\ntop_k::Union{Integer, Nothing}: the top-k coefficients used in each node to    determine the discriminant measure. When top_k=nothing, all coefficients    are used to determine the discriminant measure. Default is set to be    nothing.\nn_features::Union{Integer, Nothing}: the dimension of output after    undergoing feature selection and transformation. When n_features=nothing,   all features will be returned as output. Default is set to be nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.LpDistance","page":"LDB","title":"WaveletsExt.LDB.LpDistance","text":"LpDistance <: ProbabilityDensityDM\n\nell^p Distance discriminant measure for the Probability Density and Time  Frequency based energy maps. The default p value is set to 2.\n\nEquation: W(qr) = q-r_p^p = sum_i=1^n (q_i - r_i)^p\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.ProbabilityDensity","page":"LDB","title":"WaveletsExt.LDB.ProbabilityDensity","text":"ProbabilityDensity <: EnergyMap\n\nAn energy map based on probability density, a measure based on the differences  among the pdfs of Z_i. Since we do not know the true density functions of the coefficients, the PDFs are estimated using the Average Shifted Histogram (ASH).\n\nSee also: EnergyMap, TimeFrequency, Signatures\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.ProbabilityDensityDM","page":"LDB","title":"WaveletsExt.LDB.ProbabilityDensityDM","text":"Discriminant measure for Probability Density and Time Frequency based energy  maps. Current available measures are:\n\nAsymmetricRelativeEntropy\nSymmetricRelativeEntropy\nLpDistance\nHellingerDistance\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.RobustFishersClassSeparability","page":"LDB","title":"WaveletsExt.LDB.RobustFishersClassSeparability","text":"RobustFishersClassSeparability <: DiscriminantPower\n\nThe robust version of Fisher's class separability of the expansion coefficients  in the basis function.\n\nEquation: fracsum_c=1^C pi_c(rm med_i(alpha_lambdai^(c)) - rm med_c(rm med_i(alpha_lambdai^(c))))^2sum_c=1^C pi_c rm mad_i(alpha_lambdai^(c))\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.Signatures","page":"LDB","title":"WaveletsExt.LDB.Signatures","text":"Signatures <: EnergyMap\n\nAn energy map based on signatures, a measure that uses the Earth Mover's Distance (EMD) to compute the discriminating  power of a coordinate. Signatures provide us with a fully data-driven representation, which can be efficiently used with EMD. This representation is more efficient than a histogram and is able to represent complex data structure with fewer samples.\n\nHere, a signature for the coefficients in the j-th level, k-th node, l-th index of class c is defined as\n\ns_jkl^(c) = (alpha_ijkl^(c) w_ijkl^(c))_i=1^N_c\n\nwhere alpha_ijkl^(c) and w_ijkl^(c) are the expansion  coefficients and weights at location (jkl) for signal i of class c respectively. Currently, the two valid types of weights are :equal and :pdf.\n\nArgumemts\n\nweight::Symbol: Type of weight to be used to compute w_ijkl^(c).   Available methods are :equal and pdf. Default is set to :equal.\n\nSee also: EnergyMap, TimeFrequency,     ProbabilityDensity\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.SignaturesDM","page":"LDB","title":"WaveletsExt.LDB.SignaturesDM","text":"Discriminant measure for Signatures based energy maps. Current available measures are:\n\nEarthMoverDistance\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.SymmetricRelativeEntropy","page":"LDB","title":"WaveletsExt.LDB.SymmetricRelativeEntropy","text":"SymmetricRelativeEntropy <: ProbabilityDensityDM\n\nSymmetric Relative Entropy discriminant measure for the Probability Density and  Time Frequency energy maps. Similar idea to the Asymmetric Relative Entropy, but  this aims to make the measure more symmetric.\n\nEquation: Denote the Asymmetric Relative Entropy as D_A(pq), then\n\nD(pq) = D_A(pq) + D_A(qp) = sum p(x) log fracp(x)q(x) + q(x) log fracq(x)p(x)\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.TimeFrequency","page":"LDB","title":"WaveletsExt.LDB.TimeFrequency","text":"TimeFrequency <: EnergyMap\n\nAn energy map based on time frequencies, a measure based on the differences of  derived quantities from projection Z_i, such as mean class energies or  cumulants.\n\nSee also: EnergyMap, ProbabilityDensity,     Signatures\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.change_nfeatures-Union{Tuple{T}, Tuple{LocalDiscriminantBasis, AbstractMatrix{T}, Integer}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.change_nfeatures","text":"change_nfeatures(f, x, n_features)\n\nChange the number of features from f.n_features to n_features. \n\nNote that if the input n_features is larger than f.n_features, it results in the regeneration of signals based on the current f.n_features before  reselecting the features. This will cause additional features to be less  accurate and effective.\n\nSee also: LocalDiscriminantBasis, fit!, fit_transform,     transform, inverse_transform\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.discriminant_measure-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, ProbabilityDensityDM}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.discriminant_measure","text":"discriminant_measure(Γ, dm)\n\nReturns the discriminant measure of each node calculated from the energy maps.\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.discriminant_power-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector, BasisDiscriminantMeasure}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.discriminant_power","text":"discriminant_power(D, tree, dp)\n\nReturns the discriminant power of each leaf from the local discriminant basis (LDB) tree. \n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.energy_map-Union{Tuple{T}, Tuple{S}, Tuple{AbstractArray{S, 3}, AbstractVector{T}, TimeFrequency}} where {S<:Number, T}","page":"LDB","title":"WaveletsExt.LDB.energy_map","text":"energy_map(Xw, y, method)\n\nReturns the Time Frequency Energy map or the Probability Density Energy map depending on the input method (TimeFrequency() or ProbabilityDensity()).\n\nSee also: EnergyMap. TimeFrequency,      ProbabilityDensity\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.fit!-Union{Tuple{T}, Tuple{S}, Tuple{LocalDiscriminantBasis, AbstractMatrix{S}, AbstractVector{T}}} where {S<:Number, T}","page":"LDB","title":"WaveletsExt.LDB.fit!","text":"fit!(f, X, y)\n\nFits the Local Discriminant Basis feature selection algorithm f onto the  signals X (or the decomposed signals Xw) with labels y.\n\nSee also: LocalDiscriminantBasis, fit_transform,     transform, inverse_transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.fit_transform-Union{Tuple{T}, Tuple{S}, Tuple{LocalDiscriminantBasis, AbstractMatrix{S}, AbstractVector{T}}} where {S<:Number, T}","page":"LDB","title":"WaveletsExt.LDB.fit_transform","text":"fit_transform(f, X, y)\n\nFit and transform the signals X with labels y based on the LDB class f.\n\nSee also: LocalDiscriminantBasis, fit!,     transform, inverse_transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.inverse_transform-Union{Tuple{T}, Tuple{LocalDiscriminantBasis, AbstractMatrix{T}}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.inverse_transform","text":"inverse_transform(f, x)\n\nCompute the inverse transform on the feature matrix x to form the original signal based on the LDB class f.\n\nSee also: LocalDiscriminantBasis, fit!,     fit_transform, transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.transform-Union{Tuple{T}, Tuple{LocalDiscriminantBasis, AbstractMatrix{T}}} where T","page":"LDB","title":"WaveletsExt.LDB.transform","text":"transform(f, X)\n\nExtract the LDB features on signals X.\n\nSee also: LocalDiscriminantBasis, fit!,      fit_transform, inverse_transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#Private-API","page":"LDB","title":"Private API","text":"","category":"section"},{"location":"api/ldb/","page":"LDB","title":"LDB","text":"Modules = [LDB]\nPublic = false","category":"page"},{"location":"api/acwt/#Autocorrelation-Wavelet-Transform","page":"ACWT","title":"Autocorrelation Wavelet Transform","text":"","category":"section"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"Modules = [ACWT]","category":"page"},{"location":"api/acwt/#Public-API","page":"ACWT","title":"Public API","text":"","category":"section"},{"location":"api/acwt/#Transforms-on-1-Signal","page":"ACWT","title":"Transforms on 1 Signal","text":"","category":"section"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"ACWT.acdwt\nACWT.acdwt!\nACWT.iacdwt\nACWT.iacdwt!\nACWT.acwpt\nACWT.acwpt!\nACWT.iacwpt\nACWT.iacwpt!\nACWT.acwpd\nACWT.acwpd!\nACWT.iacwpd\nACWT.iacwpd!","category":"page"},{"location":"api/acwt/#WaveletsExt.ACWT.acdwt","page":"ACWT","title":"WaveletsExt.ACWT.acdwt","text":"acdwt(x, wt[, L])\n\nPerforms a discrete autocorrelation wavelet transform for a given signal x. The signal can be 1D or 2D. The wavelet type wt determines the transform type. Refer to Wavelet.jl for a list of available methods.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Original signal, preferably of size 2ᴷ where K   in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Array{T}: Output from ACDWT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACDWT\nacdwt(x, wt)\nacdwt(x, wt, 4) # level 4 decomposition\n\nSee also: acdwt_step, iacdwt, acdwt!\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acdwt!","page":"ACWT","title":"WaveletsExt.ACWT.acdwt!","text":"acdwt!(xw, x, wt, L)\n\nSame as acdwt but without array allocation.\n\nArguments\n\nxw::AbstractArray{T}: An allocated array of dimension (n,L+1) or (n,m,3L+1) to write the outputs of x onto.\nx::AbstractArray{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\nxw::Array{T,2}: Output from ACDWT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine, 7)\nwt = wavelet(WT.haar)\n\n# ACDWT\nxw = Matrix{Float64}(undef, (128,5))\nacdwt!(xw, x, wt, 4)\n\nSee also: acdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacdwt","page":"ACWT","title":"WaveletsExt.ACWT.iacdwt","text":"iacdwt(xw[, wt])\n\nPerforms the inverse autocorrelation discrete wavelet transform. Can be used for both the 1D and 2D case.\n\nnote: Note\nThe inverse autocorrelation transform does not require any wavelet filter, but an optional wt positional argument is included for the standardization of syntax with dwt and sdwt, but is ignored during the reconstruction of signals.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: ACDWT-transformed array.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\n\nReturns\n\n::Array{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACDWT\nxw = acdwt(x, wt)\n\n# IACDWT\nx̃ = iacdwt(xw)\n\nSee also: acdwt, iacdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacdwt!","page":"ACWT","title":"WaveletsExt.ACWT.iacdwt!","text":"iacdwt!(x, xw[, wt])\n\nSimilar to iacdwt but without array allocation.\n\nArguments\n\nx::AbstractArray{T} where T<:Number or x::AbstractArray{T,2} where T<:Number: Allocation for reconstructed signal.\nxw::AbstractArray{T} where T<:Number or xw::AbstractArray{T,4}: ACDWT-transformed array.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\n\nReturns\n\nx::Array{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACDWT\nxw = acdwt(x, wt)\n\n# IACDWT\nx̃ = similar(x)\niacdwt!(x̃, xw)\n\nSee also: iacdwt, acdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpt","page":"ACWT","title":"WaveletsExt.ACWT.acwpt","text":"acwpt(x, wt[, L])\n\nComputes L levels of autocorrelation wavelet packet transforms (ACWPT) on x.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Original signal, preferably of size 2ᴷ or (2ᴷ,2ᴹ) where K M in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Array{T}: Output from ACWPT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPT\nxw = acwpt(x, wt)\n\nSee also: iacwpt, acdwt, acwpd\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpt!","page":"ACWT","title":"WaveletsExt.ACWT.acwpt!","text":"acwpt!(xw, x, wt[, L])\n\nSame as acwpt but without array allocation.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: Allocation for transformed signal.\nx::AbstractArray{T} where T<:Number: Original signal, preferably of size 2ᴷ or (2ᴷ,2ᴹ) where K M in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\nxw::Array{T}: Output from ACWPT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPT\nxw = Array{Float64,2}(undef, (128,128))\nacwpt!(xw, x, wt)\n\nSee also: acwpt, iacwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwpt","page":"ACWT","title":"WaveletsExt.ACWT.iacwpt","text":"iacwpt(xw[, wt])\n\nComputes the inverse autocorrelation wavelet packet transform (IACWPT) on xw.\n\nnote: Note\nThe inverse autocorrelation transform does not require any wavelet filter, but an optional wt positional argument is included for the standardization of syntax with wpt and swpt, but is ignored during the reconstruction of signals.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: ACWPT-transformed array.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\n\nReturns\n\n::Array{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPT\nxw = acwpt(x, wt)\n\n# IACWPT\nx̃ = iacwpt(xw)\n\nSee also: iacdwt, acwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwpt!","page":"ACWT","title":"WaveletsExt.ACWT.iacwpt!","text":"iacwpt!(x, xw[, wt])\n\nSame as iacwpt but without array allocation.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Allocated array for output.\nxw::AbstractArray{T} where T<:Number: ACWPD-transformed array.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\n\nReturns\n\nx::Array{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPT\nxw = acwpt(x, wt)\n\n# IACWPT\nx̂ = similar(x)\niacwpt!(x̂, xw)\n\nSee also: iacwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpd","page":"ACWT","title":"WaveletsExt.ACWT.acwpd","text":"acwpd(x, wt[, L])\n\nPerforms a discrete autocorrelation wavelet packet transform for a given signal x. The wavelet type wt determines the transform type. Refer to Wavelet.jl for a list of available methods.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Original signal, preferably of size 2ᴷ or (2ᴷ,2ᴹ) where K M in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Array{T}: Output from ACWPD on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPD\nacwpd(x, wt)\n\nacwpd(x, wt, 4)\n\nSee also: iacwpd, acdwt, acdwt_step\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpd!","page":"ACWT","title":"WaveletsExt.ACWT.acwpd!","text":"acwpd!(xw, x, wt[, L])\n\nSame as acwpd but without array allocation.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: Allocated array for output.\nx::AbstractArray{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\nxw::Array{T}: Output from ACWPD on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPD\nxw = Matrix{Float64}(undef, (128, 255))\nacwpd!(xw, x, wt)\nacwpd!(xw, x, wt, 7)\n\nSee also: acwpd!\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwpd","page":"ACWT","title":"WaveletsExt.ACWT.iacwpd","text":"iacwpd(xw, L)\niacwpd(xw[, wt, L])\niacwpd(xw, tree)\niacwpd(xw, wt, tree)\n\nPerforms the inverse autocorrelation discrete wavelet packet transform, with respect to a decomposition tree.\n\nnote: Note\nThe inverse autocorrelation transform does not require any wavelet filter, but an optional wt positional argument is included for the standardization of syntax with wpt and swpt, but is ignored during the reconstruction of signals.\n\nnote: Note\nThis function might not be very useful if one is looking to reconstruct a raw decomposed signal. The purpose of this function would be better utilized in applications such as denoising, where a signal is decomposed (swpd) and thresholded (denoise/denoiseall) before being reconstructed.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: ACWPD-transformed array.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition used for reconstruction.\ntree::BitVector: Binary tree for inverse transform to be computed accordingly. \n\nReturns\n\n::Array{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPD\nxw = acwpd(x, wt)\n\n# IACWPD\nx̂ = iacwpd(xw, 4)\nx̂ = iacwpd(xw, wt, 4)\nx̂ = iacwpd(xw, maketree(x))\nx̂ = iacwpd(xw, wt, maketree(x))\n\nSee also: acwpd\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwpd!","page":"ACWT","title":"WaveletsExt.ACWT.iacwpd!","text":"iacwpd!(x, xw, L)\niacwpd!(x, xw[, wt, L])\niacwpd!(x, xw, tree)\niacwpd!(x, xw, wt, tree)\n\nSame as iacwpd but with no array allocation.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Allocated array for output.\nxw::AbstractArray{T} where T<:Number: ACWPD-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition used for reconstruction.\ntree::BitVector: Binary tree for inverse transform to be computed accordingly. \n\nReturns\n\nx::Array{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# ACWPD\nxw = acwpd(x, wt)\n\n# IACWPD\nx̂ = similar(x)\niacwpd!(x̂, xw, 4)\niacwpd!(x̂, xw, wt, 4)\niacwpd!(x̂, xw, maketree(x))\niacwpd!(x̂, xw, wt, maketree(x))\n\nSee also: iacwpd\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#Transforms-on-Multiple-Signals","page":"ACWT","title":"Transforms on Multiple Signals","text":"","category":"section"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"note: Note\nThe following functions currently only support 1D-signals. Transforms on multiple 2D-signals are not yet supported.","category":"page"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"ACWT.acdwtall\nACWT.iacdwtall\nACWT.acwptall\nACWT.iacwptall\nACWT.acwpdall\nACWT.iacwpdall","category":"page"},{"location":"api/acwt/#WaveletsExt.ACWT.acdwtall","page":"ACWT","title":"WaveletsExt.ACWT.acdwtall","text":"acdwtall(x, wt[, L])\n\nComputes the autocorrelation discrete wavelet transform (ACDWT) on each slice of signal.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input N-1-D signals, where each signal is sliced at dimension N.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: minimum(size(xw)[1:end-1]) |> maxtransformlevels) Number of levels of wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of transformed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# ACDWT on all signals in x\nxw = acdwtall(x, wt)\n\nSee also: acdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacdwtall","page":"ACWT","title":"WaveletsExt.ACWT.iacdwtall","text":"iacdwtall(xw[, wt])\n\nComputes the inverse autocorrelation discrete wavelet transform (IACDWT) on each slice of signal.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: ACDWT-transformed signal.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\n\nReturns\n\n::Array{T}: Slices of reconstructed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# ACDWT on all signals in x\nxw = acdwtall(x, wt)\n\n# IACDWT on all signals in xw\nx̂ = iacdwtall(xw)\n\nSee also: iacdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwptall","page":"ACWT","title":"WaveletsExt.ACWT.acwptall","text":"acwptall(x, wt[, L])\n\nComputes the autocorrelation wavelet packet transform (ACWPT) on each slice of signal.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input N-1-D signals, where each signal is sliced at dimension N.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: minimum(size(xw)[1:end-1]) |> maxtransformlevels) Number of levels of wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of transformed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# ACWPT on all signals in x\nxw = acwptall(x, wt)\n\nSee also: acwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwptall","page":"ACWT","title":"WaveletsExt.ACWT.iacwptall","text":"iacwptall(xw[, wt])\n\nComputes the inverse autocorrelation wavelet packet transform (IACWPT) on each slice of signal.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: ACWPT-transformed signal.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\n\nReturns\n\n::Array{T}: Slices of reconstructed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# ACWPT on all signals in x\nxw = acwptall(x, wt)\n\n# IACWPT on all signals in xw\nx̂ = iacwptall(xw)\n\nSee also: iacwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpdall","page":"ACWT","title":"WaveletsExt.ACWT.acwpdall","text":"acwpdall(x, wt[, L])\n\nComputes the autocorrelation wavelet packet decomposition (ACWPD) on each slice of signal.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input N-1-D signals, where each signal is sliced at dimension N.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: minimum(size(xw)[1:end-1]) |> maxtransformlevels) Number of levels of wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of transformed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# ACWPD on all signals in x\nxw = acwpdall(x, wt)\n\nSee also: acwpd\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwpdall","page":"ACWT","title":"WaveletsExt.ACWT.iacwpdall","text":"iacwpdall(xw[, wt, L])\niacwpdall(xw, L)\niacwpdall(xw, wt, tree)\niacwpdall(xw, tree)\n\nComputes the inverse autocorrelation wavelet packet decomposition (IACWPD) on each slice of signal.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: ACWPD-transformed signal.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\nL::Integer: (Default: minimum(size(xw)[1:end-2]) |> maxtransformlevels) Number of levels of wavelet transforms.\ntree::BitVector: Binary tree for inverse transform to be computed accordingly.\n\nReturns\n\n::Array{T}: Slices of reconstructed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# ACWPD on all signals in x\nxw = acwpdall(x, wt)\n\n# IACWPD on all signals in xw\nx̂ = iacwpdall(xw)\nx̂ = iacwpdalll(xw, maketree(x))\nx̂ = iacwpdall(xw, 5)\n\nSee also: iacwpd\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#Private-API","page":"ACWT","title":"Private API","text":"","category":"section"},{"location":"api/acwt/#Utilities","page":"ACWT","title":"Utilities","text":"","category":"section"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"ACWT.autocorr\nACWT.pfilter\nACWT.qfilter\nACWT.make_acqmfpair\nACWT.make_acreverseqmfpair","category":"page"},{"location":"api/acwt/#WaveletsExt.ACWT.autocorr","page":"ACWT","title":"WaveletsExt.ACWT.autocorr","text":"autocorr(f::OrthoFilter)\n\nGenerates the autocorrelation filter for a given wavelet filter.\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.pfilter","page":"ACWT","title":"WaveletsExt.ACWT.pfilter","text":"pfilter(f::OrthoFilter)\n\nGenerates the high-pass autocorrelation filter\n\nSee also: qfilter, autocorr\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.qfilter","page":"ACWT","title":"WaveletsExt.ACWT.qfilter","text":"qfilter(f::OrthoFilter)\n\nGenerates the low-pass autocorrelation filter.\n\nSee also: pfilter, autocorr\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.make_acqmfpair","page":"ACWT","title":"WaveletsExt.ACWT.make_acqmfpair","text":"make_acqmfpair(f::OrthoFilter)\n\nGenerates the autocorrelation quadratic mirror filters.\n\nSee also: make_acreverseqmfpair, pfilter, qfilter\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.make_acreverseqmfpair","page":"ACWT","title":"WaveletsExt.ACWT.make_acreverseqmfpair","text":"make_acreverseqmfpair(f::OrthoFilter)\n\nGenerates the reverse autocorrelation quadratic mirror filters.\n\nSee also: make_acqmfpair, pfilter, qfilter\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#Single-Step-Transforms","page":"ACWT","title":"Single Step Transforms","text":"","category":"section"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"ACWT.acdwt_step\nACWT.acdwt_step!\nACWT.iacdwt_step\nACWT.iacdwt_step!","category":"page"},{"location":"api/acwt/#WaveletsExt.ACWT.acdwt_step","page":"ACWT","title":"WaveletsExt.ACWT.acdwt_step","text":"acdwt_step(v, d, h, g)\n\nPerforms one level of the autocorrelation discrete wavelet transform (acdwt) on the vector v, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nArguments\n\nv::AbstractArray{T} where T<:Number: Array of coefficients from a node at level d.\nd::Integer: Depth level of v.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Vector allocation for output from low pass filter (1D case); or matrix allocation for output from low + low pass filter (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Vector allocation for output from high pass filter (1D case); or matrix allocation for output from low + high pass filter (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Matrix allocation for output from high + low pass filter (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Matrix allocation for output from high + high pass filter (2D case).\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.make_acreverseqmfpair(wt)\n\n# One step of ACDWT\nACWT.acdwt_step(v, 0, h, g)\n\nSee also: acdwt, iacdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acdwt_step!","page":"ACWT","title":"WaveletsExt.ACWT.acdwt_step!","text":"acdwt_step!(w₁, w₂, v, j, h, g)\n\nSame with acdwt_step but without array allocation.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Vector allocation for output from low pass filter (1D case); or matrix allocation for output from low + low pass filter (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Vector allocation for output from high pass filter (1D case); or matrix allocation for output from low + high pass filter (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Matrix allocation for output from high + low pass filter (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Matrix allocation for output from high + high pass filter (2D case).\nv::AbstractArray{T} where T<:Number: Array of coefficients from a node at level d.\nd::Integer: Depth level of v.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Output from low pass filter (1D case); or output from low + low pass filter (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Output from high pass filter (1D case); or output from low + high pass filter (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Output from high + low pass filter (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Output from high + high pass filter (2D case).\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nw₁ = similar(v)\nw₂ = similar(v)\nwt = wavelet(WT.haar)\ng, h = WT.make_acreverseqmfpair(wt)\n\n# One step of ACDWT\nACWT.acdwt_step!(w₁, w₂, v, 0, h, g)\n\nSee also: acdwt_step!, acdwt, iacdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacdwt_step","page":"ACWT","title":"WaveletsExt.ACWT.iacdwt_step","text":"iacdwt_step(w₁, w₂)\niacdwt_step(w₁, w₂, w₃, w₄)\n\nPerform one level of the inverse autocorrelation discrete wavelet transform (IACDWT) on the vectors w₁ and w₂, which are the j+1-th level scaling coefficients (Note that the 0th level scaling coefficients is the raw signal).\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Coefficients of left child node (1D case); or coefficients from top left child node (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Coefficients of right child node (1D case); or coefficients from top right child node (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Coefficients from bottom left child node (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Coefficients from bottom right child node (2D case).\n\nReturns\n\nv::Array{T}: Reconstructed coefficients.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.make_acreverseqmfpair(wt)\n\n# One step of ACDWT\nw₁, w₂ = ACWT.acdwt_step(v, 0, h, g)\n\n# One step of IACDWT\nv̂ = ACWT.iacdwt_step(w₁, w₂)\n\nSee also: iacdwt_step!, acdwt_step, iacdwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacdwt_step!","page":"ACWT","title":"WaveletsExt.ACWT.iacdwt_step!","text":"iacdwt_step!(v, w₁, w₂)\n\nSame as iacdwt_step but without array allocation.\n\nArguments\n\nv::AbstractArray{T} where T<:Number: Array allocation for reconstructed coefficients.\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Coefficients of left child node (1D case); or coefficients from top left child node (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Coefficients of right child node (1D case); or coefficients from top right child node (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Coefficients from bottom left child node (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Coefficients from bottom right child node (2D case).\n\nReturns\n\nv::Array{T}: Reconstructed coefficients.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.make_acreverseqmfpair(wt)\n\n# One step of ACDWT\nw₁, w₂ = ACWT.acdwt_step(v, 0, h, g)\n\n# One step of IACDWT\nv̂ = similar(v)\nACWT.iacdwt_step!(v̂, w₁, w₂)\n\nSee also: iacdwt_step, acdwt_step, iacdwt\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Standard-Wavelet-Transforms","page":"DWT","title":"Standard Wavelet Transforms","text":"","category":"section"},{"location":"api/dwt/","page":"DWT","title":"DWT","text":"Modules = [DWT]","category":"page"},{"location":"api/dwt/#Public-API","page":"DWT","title":"Public API","text":"","category":"section"},{"location":"api/dwt/#Transforms-on-1-Signal","page":"DWT","title":"Transforms on 1 Signal","text":"","category":"section"},{"location":"api/dwt/","page":"DWT","title":"DWT","text":"Wavelets.Transforms.wpt\nWavelets.Transforms.wpt(::AbstractArray{T,2}, ::OrthoFilter, ::Integer; ::Bool) where T<:Number\nWavelets.Transforms.wpt!\nWavelets.Transforms.wpt!(::AbstractArray{T,2}, ::AbstractArray{T,2}, ::OrthoFilter, ::Integer; ::Bool) where T<:Number\nWavelets.Transforms.iwpt\nWavelets.Transforms.iwpt(::AbstractArray{T,2}, ::OrthoFilter, ::Integer; ::Bool) where T<:Number\nWavelets.Transforms.iwpt!\nWavelets.Transforms.iwpt!(::AbstractArray{T,2}, ::AbstractArray{T,2}, ::OrthoFilter, ::Integer; ::Bool) where T<:Number\nDWT.wpd\nDWT.wpd!\nDWT.iwpd\nDWT.iwpd!","category":"page"},{"location":"api/dwt/#Wavelets.Transforms.wpt","page":"DWT","title":"Wavelets.Transforms.wpt","text":"wpt\n\nPerform a discrete wavelet packet transform of the array x. See also: dwt, wavelet\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Wavelets.Transforms.wpt-Union{Tuple{T}, Tuple{AbstractMatrix{T}, OrthoFilter, Integer}} where T<:Number","page":"DWT","title":"Wavelets.Transforms.wpt","text":"wpt(x, wt[, L])\nwpt(x, wt, tree)\n\nReturns the wavelet packet transform (WPT) for L levels or by given quadratic tree.\n\nArguments\n\nx::AbstractVector{T} where T<:Number or x::AbstractArray{T,2} where T<:Number: Input vector/matrix. A vector input undergoes 1D wavelet decomposition whereas a matrix input undergoes 2D wavelet decomposition.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\ntree::BitVector: Quadtree to transform to be computed accordingly.\n\nReturns\n\n::Array{T,1} or ::Array{T,2}: Transformed signal. \n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nwt = wavelet(WT.haar)\nxw = wpt(x, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nwt = wavelet(WT.haar)\nxw = wpt(x, wt)\n\nSee also: wpt!, maketree\n\n\n\n\n\n","category":"method"},{"location":"api/dwt/#Wavelets.Transforms.wpt!","page":"DWT","title":"Wavelets.Transforms.wpt!","text":"wpt!\n\nSame as wpt but without array allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Wavelets.Transforms.wpt!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, OrthoFilter, Integer}} where T<:Number","page":"DWT","title":"Wavelets.Transforms.wpt!","text":"wpt!(y, x, wt[, L])\nwpt!(y, x, wt, tree)\n\nSame as wpt but without array allocation.\n\nArguments\n\ny::AbstractVector{T} where T<:Number or y::AbstractArray{T,2} where T<:Number: Allocated output vector/matrix.\nx::AbstractVector{T} where T<:Number or x::AbstractArray{T,2} where T<:Number: Input vector/matrix. A vector input undergoes 1D wavelet packet transform whereas a matrix input undergoes 2D wavelet packet transform.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\ntree::BitVector: Quadtree to transform to be computed accordingly.\n\nReturns\n\n::Array{T,1} or ::Array{T,2}: Transformed signal. \n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nxw = similar(x)\nwt = wavelet(WT.haar)\nwpt!(xw, x, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nxw = similar(x)\nwt = wavelet(WT.haar)\nwpt!(xw, x, wt)\n\nSee also: wpt, maketree\n\n\n\n\n\n","category":"method"},{"location":"api/dwt/#Wavelets.Transforms.iwpt","page":"DWT","title":"Wavelets.Transforms.iwpt","text":"iwpt\n\nPerform an inverse discrete wavelet packet transform of the array x. See also: idwt, wavelet\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Wavelets.Transforms.iwpt-Union{Tuple{T}, Tuple{AbstractMatrix{T}, OrthoFilter, Integer}} where T<:Number","page":"DWT","title":"Wavelets.Transforms.iwpt","text":"iwpt(xw, wt[, L])\niwpt(xw, wt, tree)\n\nReturns the inverse wavelet packet transform (IWPT) for L levels or by given quadratic tree.\n\nArguments\n\nxw::AbstractVector{T} where T<:Number or xw::AbstractArray{T,2} where T<:Number: Input vector/matrix. A vector input undergoes 1D wavelet reconstruction whereas a matrix input undergoes 2D wavelet reconstruction.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\ntree::BitVector: Quadtree to transform to be computed accordingly.\n\nReturns\n\n::Array{T,1} or ::Array{T,2}: Reconstructed signal. \n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nwt = wavelet(WT.haar)\nxw = wpt(x, wt)\n\n# 1D wavelet reconstruction\ny = iwpt(xw, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nwt = wavelet(WT.haar)\nxw = wpt(x, wt)\n\n# 2D wavelet reconstruction\ny = iwpt(xw, wt)\n\nSee also: iwpt!, wpt!, maketree\n\n\n\n\n\n","category":"method"},{"location":"api/dwt/#Wavelets.Transforms.iwpt!","page":"DWT","title":"Wavelets.Transforms.iwpt!","text":"iwpt!\n\nSame as iwpt but without array allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Wavelets.Transforms.iwpt!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, OrthoFilter, Integer}} where T<:Number","page":"DWT","title":"Wavelets.Transforms.iwpt!","text":"iwpt!(x̂, xw, wt[, L])\niwpt!(x̂, xw, wt, tree)\n\nSame as iwpt but without array allocation.\n\nArguments\n\nx̂::AbstractVector{T} where T<:Number or x̂::AbstractArray{T,2} where T<:Number: Allocated output vector/matrix.\nxw::AbstractVector{T} where T<:Number or xw::AbstractArray{T,2} where T<:Number: Input vector/matrix. A vector input undergoes 1D wavelet packet reconstruction whereas a matrix input undergoes 2D wavelet packet reconstruction.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\ntree::BitVector: Quadtree to transform to be computed accordingly.\n\nReturns\n\n::Array{T,1} or ::Array{T,2}: Reconstructed signal. \n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nxw = similar(x)\nwt = wavelet(WT.haar)\nwpt!(xw, x, wt)\n\n# 1D wavelet reconstruction\ny = similar(x)\niwpt!(y, xw, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nxw = similar(x)\nwt = wavelet(WT.haar)\nwpt!(xw, x, wt)\n\n# 2D wavelet reconstruction\ny = similar(x)\niwpt!(y, xw, wt)\n\nSee also: iwpt, wpt! maketree\n\n\n\n\n\n","category":"method"},{"location":"api/dwt/#WaveletsExt.DWT.wpd","page":"DWT","title":"WaveletsExt.DWT.wpd","text":"wpd(x, wt[, L])\n\nReturns the wavelet packet decomposition (WPD) for L levels for input signal x.\n\nArguments\n\nx::AbstractVector{T} where T<:Number or x::AbstractArray{T,2} where T<:Number: Input vector/matrix. A vector input undergoes 1D wavelet decomposition whereas a matrix input undergoes 2D wavelet decomposition.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\n\nReturns\n\n::Array{T,2} or ::Array{T,3}: Decomposed signal. For an input vector x, output is a 2D matrix where each column corresponds to a level of decomposition. For an input matrix x, output is a 3D array where each slice of dimension 3 corresponds to a level of decomposition.\n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nwt = wavelet(WT.haar)\nxw = wpd(x, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nwt = wavelet(WT.haar)\nxw = wpd(x, wt)\n\nSee also: wpd!, iwpd\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.wpd!","page":"DWT","title":"WaveletsExt.DWT.wpd!","text":"wpd!(y, x, wt[, L])\n\nSame as wpd but without array allocation.\n\nArguments\n\ny::AbstractArray{T,2} where T<:Number or y::AbstractArray{T,3} where T<:Number: An allocated array to write the outputs of x onto.\nx::AbstractVector{T} where T<:Number or x::AbstractArray{T,2} where T<:Number: Input vector/matrix. A vector input undergoes 1D wavelet decomposition whereas a matrix input undergoes 2D wavelet decomposition.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\n\nReturns\n\ny::AbstractArray{T,2} where T<:Number or y::AbstractArray{T,3} where T<:Number: Decomposed signal. For an input vector, output is a 2D matrix where each column corresponds to a level of decomposition. For an input matrix, output is a 3D array where each slice of dimension 3 corresponds to a level of decomposition.\n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nxw = Array{eltype(x)}(undef, (8,3))\nwt = wavelet(WT.haar)\nwpd!(xw, x, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nxw = Array{eltype(x)}(undef, (8,8,3))\nwt = wavelet(WT.haar)\nwpd!(xw, x, wt)\n\nSee also: wpd, iwpd\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.iwpd","page":"DWT","title":"WaveletsExt.DWT.iwpd","text":"iwpd(xw, wt[, L])\niwpd(xw, wt, tree)\n\nComputes the inverse wavelet packet decomposition (IWPD) for L levels or by given tree.\n\nArguments\n\nx̂::AbstractVector{T} where T<:Number or x̂::AbstractArray{T,2} where T<:Number: Allocated output vector/matrix for reconstructed signal.\nxw::AbstractArray{T,2} where T<:Number or xw::AbstractArray{T,3} where T<:Number: Input array. A 2D input undergoes 1D wavelet reconstruction whereas a 3D input undergoes 2D wavelet reconstruction.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: minimum(size(x)[1:end-1]) |> maxtransformlevels) Number of levels of wavelet decomposition.\ntree::BitVector: Binary tree or Quadtree for inverse transform to be computed accordingly.\n\nReturns\n\nx̂::Array{T,1} or x̂::Array{T,2}: Reconstructed signal. \n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nwt = wavelet(WT.haar)\nxw = wpd(x, wt)\n\n# 1D wavelet reconstruction\ny = iwpd(xw, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nwt = wavelet(WT.haar)\nxw = wpd(x, wt)\n\n# 2D wavelet reconstruction\ny = iwpd(xw, wt)\n\nSee also: iwpd!, iwpt\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.iwpd!","page":"DWT","title":"WaveletsExt.DWT.iwpd!","text":"iwpd(x̂, xw, wt[, L])\niwpd(x̂, xw, wt, tree)\n\nSame as iwpd but without array allocation.\n\nArguments\n\nx̂::AbstractVector{T} where T<:Number or x̂::AbstractArray{T,2} where T<:Number: Allocated output vector/matrix for reconstructed signal.\nxw::AbstractArray{T,2} where T<:Number or xw::AbstractArray{T,3} where T<:Number: Input array. A 2D input undergoes 1D wavelet reconstruction whereas a 3D input undergoes 2D wavelet reconstruction.\nwt::OrthoFilter: Wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels for wavelet decomposition.\ntree::BitVector: Binary tree or Quadtree to transform to be computed accordingly.\n\nReturns\n\nx̂::Array{T,1} or x̂::Array{T,2}: Reconstructed signal. \n\nExamples:\n\nusing Wavelets, WaveletsExt\n\n# 1D wavelet decomposition\nx = randn(8)\nwt = wavelet(WT.haar)\nxw = wpd(x, wt)\ny = similar(x)\n\n# 1D wavelet reconstruction\niwpd!(y, xw, wt)\n\n# 2D wavelet decomposition\nx = randn(8,8)\nwt = wavelet(WT.haar)\nxw = wpd(x, wt)\ny = similar(x)\n\n# 2D wavelet reconstruction\niwpd!(y, xw, wt)\n\nSee also: iwpd, iwpt\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Transforms-on-Multiple-Signals","page":"DWT","title":"Transforms on Multiple Signals","text":"","category":"section"},{"location":"api/dwt/","page":"DWT","title":"DWT","text":"DWT.dwtall\nDWT.idwtall\nDWT.wptall\nDWT.iwptall\nDWT.wpdall\nDWT.iwpdall","category":"page"},{"location":"api/dwt/#WaveletsExt.DWT.dwtall","page":"DWT","title":"WaveletsExt.DWT.dwtall","text":"dwtall(x, wt[, L])\n\nComputes the discrete wavelet transform (DWT) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input x.\n\nnote: Note\ndwt is currently available for 1-D, 2-D, and 3-D signals only. \n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet transforms. \n\nReturns\n\n::Array{T}: Slices of transformed signals. Signals are sliced the same way as the input signal x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# DWT on all signals in x\nxw = dwtall(x, wt)\n\nSee also: idwtall, wpdall, wptall\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.idwtall","page":"DWT","title":"WaveletsExt.DWT.idwtall","text":"idwtall(xw, wt[, L])\n\nComputes the inverse discrete wavelet transform (iDWT) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input xw.\n\nnote: Note\nidwt is currently available for 1-D, 2-D, and 3-D signals only. \n\nArguments\n\nxw::AbstractArray{T} where T<:Number: Input decomposed signals, where each slice corresponds to one signal. For a set of input signals xw of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xwᵢ)) Number of levels of wavelet transforms. \n\nReturns\n\n::Array{T}: Slices of reconstructed signals. Signals are sliced the same way as the input xw.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# DWT on all signals in x\nxw = dwtall(x, wt)\n\n# iDWT on all signals\nx̂ = idwtall(xw, wt)\n\nSee also: dwtall, iwpdall, iwptall\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.wptall","page":"DWT","title":"WaveletsExt.DWT.wptall","text":"wptall(x, wt[, L])\nwptall(x, wt, tree)\n\nComputes the wavelet packet transform (WPT) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input x.\n\nnote: Note\nwpt is currently available for 1-D and 2-D signals only.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet decomposition. \ntree::BitVector: (Default: Wavelets.maketree(xᵢ, :full)) Tree to follow for wavelet decomposition. Default value is only applicable for 1D signals.\n\nReturns\n\n::Array{T}: Slices of transformed signals. Signals are sliced the same way as the input signal x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# WPT on all signals in x\nxw = wptall(x, wt)\n\nSee also: wpdall, dwtall, wpt\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.iwptall","page":"DWT","title":"WaveletsExt.DWT.iwptall","text":"iwptall(xw, wt[, L])\niwptall(xw, wt, tree)\n\nComputes the inverse wavelet packet transform (iWPT) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input xw.\n\nnote: Note\niwpt is currently available for 1-D and 2-D signals only.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet decomposition. \ntree::BitVector: (Default: Wavelets.maketree(xᵢ, :full)) Tree to follow for wavelet decomposition. Default value is only applicable for 1D signals.\n\nReturns\n\n::Array{T}: Slices of transformed signals. Signals are sliced the same way as the input signal x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# WPT on all signals in x\nxw = wptall(x, wt)\n\n# iWPT on all signals on x\nx̂ = iwptall(xw, wt)\n\nSee also: wpdall, dwtall, wpt\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.wpdall","page":"DWT","title":"WaveletsExt.DWT.wpdall","text":"wpdall(x, wt[, L])\n\nComputes the wavelet packet decomposition (WPD) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input x.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: minimum(size(x)[1:end-1]) |> maxtransformlevels) Number of levels of wavelet decomposition. \n\nReturns\n\n::Array{T}: Array of decomposed signals. Signals are sliced by the final dimension.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# WPT on all signals in x\nxw = wpdall(x, wt)\n\nSee also: wptall, dwtall, wpd, wpd!\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.iwpdall","page":"DWT","title":"WaveletsExt.DWT.iwpdall","text":"iwpdall(xw, wt[, L; standard])\niwpdall(xw, wt, tree[; standard])\n\nComputes the inverse wavelet packet decomposition (IWPD) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input xw.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal decomposition. For a set of input signals x of dimension n, xw is sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet decomposition. \n\nKeyword Arguments\n\nstandard::Bool: (Default: true) Whether to compute the standard or non-standard wavelet transform. Only applicable for 2D signals.\n\nReturns\n\n::Array{T}: Array of decomposed signals. Signals are sliced by the final dimension.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# WPD on all signals in x\nxw = wpdall(x, wt)\n\n# IWPD on all signals\nx̂ = iwpdall(xw, wt)\n\nSee also: wptall, dwtall, wpd, wpd!\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#Private-API","page":"DWT","title":"Private API","text":"","category":"section"},{"location":"api/dwt/#Single-Step-Transforms","page":"DWT","title":"Single Step Transforms","text":"","category":"section"},{"location":"api/dwt/","page":"DWT","title":"DWT","text":"DWT.dwt_step\nDWT.dwt_step!\nDWT.idwt_step\nDWT.idwt_step!","category":"page"},{"location":"api/dwt/#WaveletsExt.DWT.dwt_step","page":"DWT","title":"WaveletsExt.DWT.dwt_step","text":"dwt_step(v, h, g)\n\nPerform one level of the discrete wavelet transform (DWT) on the vector v, which is the d-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nArguments\n\nv::AbstractVector{T} where T<:Number: Vector of coefficients from a node at level d.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::Vector{T}: Output from the low pass filter.\nw₂::Vector{T}: Output from the high pass filter.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of DWT\nDWT.dwt_step(v, h, g)\n\nSee also: dwt_step!, idwt_step\n\n\n\n\n\ndwt_step(v, h, g)\n\nCompute 1 step of 2D discrete wavelet transform (DWT).\n\nArguments\n\nv::AbstractArray{T,2} where T<:Number: Array of coefficients of size (nm).\nh::Array{S,1} where S<:Number: High pass filter.\ng::Array{S,1} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::Array{T,2}: Top left output. Result of low pass filter on columns + low pass filter on rows.\nw₂::Array{T,2}: Top left output. Result of low pass filter on columns + high pass filter on rows.\nw₃::Array{T,2}: Top left output. Result of high pass filter on columns + low pass filter on rows.\nw₄::Array{T,2}: Top left output. Result of high pass filter on columns + high pass filter on rows.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8,8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of DWT\nDWT.dwt_step(v, h, g)\n\nSee also: dwt_step, dwt_step!, idwt_step\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.dwt_step!","page":"DWT","title":"WaveletsExt.DWT.dwt_step!","text":"dwt_step!(w₂, w₂, v, h, g)\n\nSame as dwt_step but without array allocation.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number: Vector allocation for output from low pass filter.\nw₂::AbstractVector{T} where T<:Number: Vector allocation for output from high pass filter.\nv::AbstractVector{T} where T<:Number: Vector of coefficients from a node at level d.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::Vector{T}: Output from the low pass filter.\nw₂::Vector{T}: Output from the high pass filter.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\nw₁ = zeros(8)\nw₂ = zeros(8)\n\n# One step of DWT\nDWT.dwt_step!(w₁, w₂, v, 0, h, g)\n\nSee also: dwt_step, idwt_step\n\n\n\n\n\ndwt_step!(v, w₁, w₂, w₃, w₄, h, g, temp)\n\nSame as 2D version of dwt_step but without array allocation.\n\nArguments\n\nw₁::AbstractArray{T,2} where T<:Number: Array allocation for top left output.\nw₂::AbstractArray{T,2} where T<:Number: Array allocation for top right output.\nw₃::AbstractArray{T,2} where T<:Number: Array allocation for bottom left output.\nw₄::AbstractArray{T,2} where T<:Number: Array allocation for bottom right output.\nv::AbstractArray{T,2} where T<:Number: Array of coefficients to be transformed.\nh::Array{S,1} where S<:Number: High pass filter.\ng::Array{S,1} where S<:Number: Low pass filter.\ntemp::AbstractArray{T,2} where T<:Number: Array allocation for intermediate computations.\n\nReturns\n\nw₁::Array{T,2}: Top left output. Result of low pass filter on columns + low pass filter on rows.\nw₂::Array{T,2}: Top left output. Result of low pass filter on columns + high pass filter on rows.\nw₃::Array{T,2}: Top left output. Result of high pass filter on columns + low pass filter on rows.\nw₄::Array{T,2}: Top left output. Result of high pass filter on columns + high pass filter on rows.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8,8)\ntemp = similar(v)\nw₁ = Array{Float64,2}(undef, (4,4))\nw₂ = Array{Float64,2}(undef, (4,4))\nw₃ = Array{Float64,2}(undef, (4,4))\nw₄ = Array{Float64,2}(undef, (4,4))\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of DWT\nDWT.dwt_step!(w₁, w₂, w₃, w₄, v, h, g, temp)\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.idwt_step","page":"DWT","title":"WaveletsExt.DWT.idwt_step","text":"idwt_step(w₁, w₂, h, g)\n\nPerform one level of the inverse discrete wavelet transform (IDWT) on the vectors w₁ and w₂, which are the scaling and detail coefficients. The vectors h and g are the detail and scaling filters.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number: Vector allocation for output from low pass filter.\nw₂::AbstractVector{T} where T<:Number: Vector allocation for output from high pass filter.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nv::Vector{T}: Reconstructed coefficients.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of SDWT\nw₁, w₂ = DWT.dwt_step(v, h, g)\n\n# One step of ISDWT\nv̂ = DWT.idwt_step(w₁, w₂, h, g)\n\nSee also: idwt_step!\n\n\n\n\n\nidwt_step(w₁, w₂, w₃, w₄, h, g)\n\nComputes one step of inverse discrete wavelet transform on 2D-signals.\n\nArguments\n\nw₁::AbstractArray{T,2} where T<:Number: Top left child coefficients.\nw₂::AbstractArray{T,2} where T<:Number: Top right child coefficients.\nw₃::AbstractArray{T,2} where T<:Number: Bottom left child coefficients.\nw₄::AbstractArray{T,2} where T<:Number: Bottom right child coefficients.\nh::Array{S,1} where S<:Number: High pass filter.\ng::Array{S,1} where S<:Number: Low pass filter.\n\nReturns\n\n::Array{T,2}: Reconstructed coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/dwt/#WaveletsExt.DWT.idwt_step!","page":"DWT","title":"WaveletsExt.DWT.idwt_step!","text":"idwt_step!(v, w₁, w₂, h, g)\n\nSame as idwt_step but without array allocation.\n\nArguments\n\nv::AbstractVector{T} where T<:Number: Vector allocation for reconstructed coefficients.\nw₁::AbstractVector{T} where T<:Number: Vector allocation for output from low pass filter.\nw₂::AbstractVector{T} where T<:Number: Vector allocation for output from high pass filter.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nv::Vector{T}: Reconstructed coefficients.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nv̂ = similar(v)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of SDWT\nw₁, w₂ = DWT.dwt_step(v, h, g)\n\n# One step of ISDWT\nDWT.idwt_step!(v̂, w₁, w₂, h, g)\n\nSee also: idwt_step\n\n\n\n\n\nidwt_step!(v, w₁, w₂, w₃, w₄, h, g, temp)\n\nSame as 2D version of idwt_step but without array allocation.\n\nArguments\n\nv::AbstractArray{T,2} where T<:Number: Array allocation for inverse transformed output.\nw₁::AbstractArray{T,2} where T<:Number: Array allocation for top left coefficients.\nw₂::AbstractArray{T,2} where T<:Number: Array allocation for top right coefficients.\nw₃::AbstractArray{T,2} where T<:Number: Array allocation for bottom left coefficients.\nw₄::AbstractArray{T,2} where T<:Number: Array allocation for bottom right coefficients.\nh::Array{S,1} where S<:Number: High pass filter.\ng::Array{S,1} where S<:Number: Low pass filter.\ntemp::AbstractArray{T,2} where T<:Number: Array allocation for intermediate computations.\n\nReturns\n\nv::Array{T,2}: Reconstructed coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/tiwt/#Translation-Invariant-Wavelet-Transform","page":"TIWT","title":"Translation-Invariant Wavelet Transform","text":"","category":"section"},{"location":"api/tiwt/","page":"TIWT","title":"TIWT","text":"Modules = [TIWT]","category":"page"},{"location":"api/tiwt/#Public-API","page":"TIWT","title":"Public API","text":"","category":"section"},{"location":"api/tiwt/","page":"TIWT","title":"TIWT","text":"Modules = [TIWT]\nPrivate = false","category":"page"},{"location":"api/tiwt/#WaveletsExt.TIWT.itidwt-Union{Tuple{T}, Tuple{AbstractMatrix{T}, OrthoFilter}} where T<:Number","page":"TIWT","title":"WaveletsExt.TIWT.itidwt","text":"itidwt(xw, wt)\n\nComputes the inverse translation-invariant discrete wavelet transform (iTIDWT) on xw.\n\nArguments\n\nxw::AbstractArray{T,2} where T<:Number: TIDWT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\n\nReturns\n\n::Vector{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# TIDWT\nxw = tidwt(x, wt)\n\n# iTIDWT\nx̂ = itidwt(xw, wt)\n\nSee also: tidwt\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.itiwpd-Union{Tuple{T}, Tuple{AbstractMatrix{T}, OrthoFilter}, Tuple{AbstractMatrix{T}, OrthoFilter, Integer}} where T<:Number","page":"TIWT","title":"WaveletsExt.TIWT.itiwpd","text":"itiwpd(xw, wt[, L])\nitiwpd(xw, wt, tree)\n\nComputes the inverse translation-invariant wavelet packet decomposition (iTIWPD) on xw.\n\nArguments\n\nxw::AbstractArray{T,2} where T<:Number: TIDWT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(size(xw,1))) Depth of inverse decomposition.\ntree::BitVector: Representation of binary tree used as basis for the signal x.\n\nReturns\n\n::Vector{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# TIWPD\nxw = tiwpd(x, wt)\n\n# iTIWPD\nx̂ = itiwpd(xw, wt)\n\nSee also: tiwpd, itiwpt\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.itiwpt-Union{Tuple{T}, Tuple{AbstractMatrix{T}, OrthoFilter}} where T<:Number","page":"TIWT","title":"WaveletsExt.TIWT.itiwpt","text":"itiwpt(xw, wt)\n\nComputes the inverse translation-invariant wavelet packet transform (iTIWPT) on xw.\n\nArguments\n\nxw::AbstractArray{T,2} where T<:Number: TIDWT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\n\nReturns\n\n::Vector{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# TIWPT\nxw = tiwpt(x, wt)\n\n# iTIWPT\nx̂ = itiwpt(xw, wt)\n\nSee also: tiwpt, itidwt\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.tidwt-Union{Tuple{T}, Tuple{AbstractVector{T}, OrthoFilter}, Tuple{AbstractVector{T}, OrthoFilter, Integer}} where T<:Number","page":"TIWT","title":"WaveletsExt.TIWT.tidwt","text":"tidwt(x, wt[, L])\n\nComputes the translation-invariant discrete wavelet transform (TIDWT) for L levels.\n\nArguments\n\nx::AbstractVector{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Matrix{T}: Output from TIDWT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# TIDWT\nxw = tidwt(x, wt)\n\nSee also: itidwt\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.tiwpd-Union{Tuple{T}, Tuple{AbstractVector{T}, OrthoFilter}, Tuple{AbstractVector{T}, OrthoFilter, Integer}} where T<:Number","page":"TIWT","title":"WaveletsExt.TIWT.tiwpd","text":"tiwpd(x, wt[, L])\n\nComputes L levels of translation-invariant wavelet packet decomposition (TIWPD) on x.\n\nArguments\n\nx::AbstractVector{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Matrix{T}: Output from TIWPD on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# TIWPD\nxw = tiwpd(x, wt)\n\nSee also: itiwpd, tiwpt\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.tiwpt-Union{Tuple{T}, Tuple{AbstractVector{T}, OrthoFilter}, Tuple{AbstractVector{T}, OrthoFilter, Integer}} where T<:Number","page":"TIWT","title":"WaveletsExt.TIWT.tiwpt","text":"tiwpt(x, wt[, L])\n\nComputes L levels of translation-invariant wavelet packet transform (TIWPT) on x.\n\nArguments\n\nx::AbstractVector{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Matrix{T}: Output from TIWPT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# TIWPT\nxw = tiwpt(x, wt)\n\nSee also: itiwpt, tidwt\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#Private-API","page":"TIWT","title":"Private API","text":"","category":"section"},{"location":"api/tiwt/","page":"TIWT","title":"TIWT","text":"Modules = [TIWT]\nPublic = false","category":"page"},{"location":"api/tiwt/#WaveletsExt.TIWT.itidwt_step!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Integer, Vector{S}, Vector{S}}} where {T<:Number, S<:Number}","page":"TIWT","title":"WaveletsExt.TIWT.itidwt_step!","text":"itidwt_step!(v, w₁, w₂, d, h, g)\n\nSame as itidwt_step but without array allocation.\n\nArguments\n\nv::AbstractVector{T} where T<:Number: Output vector allocation.\nw₁::AbstractVector{T} where T<:Number: d+1-level scaling coefficients.\nw₂::AbstractVector{T} where T<:Number: d+1-level detail coefficients.\nd::Integer: Depth level of output coefficients.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nv::AbstractVector{T}: Output from inverse translation-invariant wavelet transform of w₁ and w₂.\n\nExamples\n\nusing WaveletsExt\n\n# Setup\nw₁, w₂ = randn(8), randn(8)\nv = similar(w₁)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, false)\n\n# One step of iTIDWT\ntidwt_step(v, w₁, w₂, 0, h, g)\n\nSee also: itidwt_step\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.itidwt_step-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Integer, Vector{S}, Vector{S}}} where {T<:Number, S<:Number}","page":"TIWT","title":"WaveletsExt.TIWT.itidwt_step","text":"itidwt_step(w₁, w₂, d, g, h)\n\nPerform one level of the inverse translation-invariant discrete wavelet transform (ITIDWT) on the vector w₁ and w₂, which are the d+1-th level scaling and detail coefficients respectivaly (Note the 0-th level scaling coefficients correspond to the raw signal). The vectors h and g are the high and low pass filters.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number: d+1-level scaling coefficients.\nw₂::AbstractVector{T} where T<:Number: d+1-level detail coefficients.\nd::Integer: Depth level of output coefficients.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nv::Vector{T}: Output of inverse translation-invariant wavelet transform.\n\nExamples\n\nusing WaveletsExt\n\n# Setup\nw₁, w₂ = randn(8), randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, false)\n\n# One step of iTIDWT\ntidwt_step(w₁, w₂, 0, h, g)\n\nSee also: itidwt_step!\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.tidwt_step!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Integer, Vector{S}, Vector{S}}} where {T<:Number, S<:Number}","page":"TIWT","title":"WaveletsExt.TIWT.tidwt_step!","text":"tidwt_step!(w₁, w₂, v, d, h, g)\n\nSame as tidwt_step but without array allocation.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number: Vector allocation for output from low pass filter.\nw₂::AbstractVector{T} where T<:Number: Vector allocation for output from high pass filter.\nv::AbstractVector{T} where T<:Number: Vector of coefficients from a node at level d.\nd::Integer: Depth level of v.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::Vector{T}: Output from the low pass filter.\nw₂::Vector{T}: Output from the high pass filter.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\nw₁ = zeros(8)\nw₂ = zeros(8)\n\n# One step of TIDWT\ntidwt_step!(w₁, w₂, v, 0, h, g)\n\nSee also: tidwt_step\n\n\n\n\n\n","category":"method"},{"location":"api/tiwt/#WaveletsExt.TIWT.tidwt_step-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, Integer, Vector{S}, Vector{S}}} where {T<:Number, S<:Number}","page":"TIWT","title":"WaveletsExt.TIWT.tidwt_step","text":"tidwt_step(v, d, h, g)\n\nPerforms one level of the translation-invariant discrete wavelet transform (TWDWT) on the vector v, which is the d-th level scaling coefficients (Note the 0-th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nArguments\n\nv::AbstractVector{T} where T<:Number: Vector of coefficients from a node at level d.\nd::Integer: Depth level of v.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::Vector{T}: Output from the low pass filter.\nw₂::Vector{T}: Output from the high pass filter.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of TIDWT\ntidwt_step(v, 0, h, g)\n\nSee also: tidwt_step!\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"api/visualizations/","page":"Visualizations","title":"Visualizations","text":"Modules = [Visualizations]","category":"page"},{"location":"api/visualizations/#Public-API","page":"Visualizations","title":"Public API","text":"","category":"section"},{"location":"api/visualizations/","page":"Visualizations","title":"Visualizations","text":"Modules = [Visualizations]\nPrivate = false","category":"page"},{"location":"api/visualizations/#WaveletsExt.Visualizations.plot_tfbdry","page":"Visualizations","title":"WaveletsExt.Visualizations.plot_tfbdry","text":"plot_tfbdry(tree[; start, nd_col, ln_col, bg_col])\n\nGiven a tree, output a visual representation of the leaf nodes, user will have the option to start the node count of each level with 0 or 1.\n\nArguments\n\ntree::BitVector: Tree for plotting the leaf nodes. Comes in the form of a BitVector.\ndepth::Integer: (Default: log2(length(tree)+1)-1 |> Int) Maximum depth to be displayed.\n\nKeyword Arguments\n\nstart::Integer: (Default: 0) Whether to zero-index or one-index the root of the tree.\nnd_col::Symbol: (Default: :white) Color of the leaf nodes.\nln_col::Symbol: (Default: :white) Color of lines in plot.\nbg_col::Symbol: (Default: :black) Color of background.\n\nReturns\n\n::Plots.Plot: Plot object with the visual representation of the leaf nodes.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Build a tree using Wavelets `maketree`\ntree = maketree(128, 7, :dwt)\n\n# Plot the leaf nodes\nplot_tfbdry(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/visualizations/#WaveletsExt.Visualizations.wiggle!-Tuple","page":"Visualizations","title":"WaveletsExt.Visualizations.wiggle!","text":"wiggle!(wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\nwiggle!(plt, wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\n\nPlot a set of shaded wiggles on the current displayed graphics or on top of plt. If there are no displayed graphics currently available, a new Plots.Plot object is generated to plot the shaded wiggles.\n\nArguments\n\nplt::Plots.Plot: Input plot to plot shaded wiggles.\nwav::AbstractArray{<:Number,2}: Matrix of waveform columns.\n\nKeyword Arguments\n\ntaxis::AbstractVector: (Default: 1:size(wav,1)) Time axis vector\nzaxis::AbstractVector: (Default: 1:size(wav,2)) Space axis vector\nsc::Real: (Default: 1) Scale factor/magnification.\nEdgeColor::Symbol: (Default: :black) Sets edge of wiggles color.\nFaceColor::Symbol: (Default: :black) Sets shading color of wiggles.\nOverlap::Bool: (Default: true) How signals are scaled.\ntrue  - Signals overlap (default);\nfalse - Signals are scaled so they do not overlap.\nOrient::Symbol: (Default: :across) Controls orientation of wiggles.\n:across - from left to right\n:down   - from top to down\nZDir::Symbol: (Default: :normal) Direction of space axis.\n:normal  - First signal at bottom (default)\n:reverse - First signal at top.\n\nReturns\n\n::Plots.Plot: Shaded wiggles on top of current plot object.\n\nExamples\n\nusing Plots, WaveletsExt\n\n# Generate random signals\nx = randn(16, 5)\n\n# ----- Build wiggles -----\n# Build onto existing plot\nplt = plot()\nwiggle!(x)\n\n# Build onto a specified plot\nwiggle!(plt, x)\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito. The previous MATLAB version contributors are Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC).  \n\nRevised by Naoki Saito, Feb. 05, 2018. Maintained by Zeng Fung Liew for newest Julia version compatibility. \n\nSee also: wiggle\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#WaveletsExt.Visualizations.wiggle-Tuple","page":"Visualizations","title":"WaveletsExt.Visualizations.wiggle","text":"wiggle(wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\nwiggle(plt, wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\n\nPlots a set of shaded wiggles.\n\nArguments\n\nplt::Plots.Plot: Input plot to plot shaded wiggles.\nwav::AbstractArray{<:Number,2}: Matrix of waveform columns.\n\nKeyword Arguments\n\ntaxis::AbstractVector: (Default: 1:size(wav,1)) Time axis vector\nzaxis::AbstractVector: (Default: 1:size(wav,2)) Space axis vector\nsc::Real: (Default: 1) Scale factor/magnification.\nEdgeColor::Symbol: (Default: :black) Sets edge of wiggles color.\nFaceColor::Symbol: (Default: :black) Sets shading color of wiggles.\nOverlap::Bool: (Default: true) How signals are scaled.\ntrue  - Signals overlap (default);\nfalse - Signals are scaled so they do not overlap.\nOrient::Symbol: (Default: :across) Controls orientation of wiggles.\n:across - from left to right\n:down   - from top to down\nZDir::Symbol: (Default: :normal) Direction of space axis.\n:normal  - First signal at bottom (default)\n:reverse - First signal at top.\n\nReturns\n\n::Plots.Plot: Shaded wiggles on top of current plot object.\n\nExamples\n\nusing Plots, WaveletsExt\n\n# Generate random signals\nx = randn(16, 5)\n\n# ----- Build wiggles -----\n# Method 1\nwiggle(x)\n\n# Method 2\np = Plot()\nwiggle(p, x)\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito. The previous MATLAB version contributors are Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC).  \n\nRevised by Naoki Saito, Feb. 05, 2018. Maintained by Zeng Fung Liew for newest Julia version compatibility. \n\nSee also: wiggle!\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#Private-API","page":"Visualizations","title":"Private API","text":"","category":"section"},{"location":"api/visualizations/","page":"Visualizations","title":"Visualizations","text":"Modules = [Visualizations]\nPublic = false","category":"page"},{"location":"api/visualizations/#WaveletsExt.Visualizations.treenodes_matrix-Tuple{BitVector}","page":"Visualizations","title":"WaveletsExt.Visualizations.treenodes_matrix","text":"treenodes_matrix(x)\n\nGiven a BitVector of nodes in a binary tree, output the matrix representation of the nodes.\n\nArguments\n\nx::BitVector: BitVector representing a binary tree, where an input is 1 if the corresponding node exists and has children, and 0 if the corresponding node does not exist/does not have children.\n\nReturns\n\n::BitMatrix: BitMatrix representation of the tree, where each column corresponds to a level of the binary tree. The inputs in the matrix are 1 if the corresponding node exists and has children, and 0 if the corresponding node does not exist/does not have children.\n\nVisualization\n\n# Binary tree\n      x\n     / \\\n    x   o\n   / \\\n  x   o\n / \\\no   o\n\n# BitVector representation\n[1,1,0,1,0,0,0]\n\n# BitMatrix representation\n[1 1 1 1;\n 1 1 0 0;\n 1 0 0 0]\n\nExamples\n\nusing Wavelets, WaveletsExt\n\ntree = maketree(8, 3, :dwt)\nWaveletsExt.Visualizations.treenodes_matrix(tree)\n\n\n\n\n\n","category":"method"},{"location":"manual/denoising/#denoising_manual","page":"Denoising","title":"Signal Denoising","text":"","category":"section"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"Wavelet denoising is an important step in signal analysis as it helps remove unnecessary high frequency noise while maintaining the most important features of the signal. Intuitively, signal denoising comes in the following simple steps:","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"Decompose a signal or a group of signals. One can choose to decompose signals into its best basis tree for more optimal results.\nFind a suitable threshold value. There are many ways to do so, with VisuShrink (D. Donoho, I. Johnstone) being one of the most popular approaches. The VisuShrink implementation in Wavelets.jl, along with the RelErrorShrink and the SureShrink implementations in WaveletsExt.jl give users more threshold selection options.\nThreshold the wavelet coefficients. There are various thresholding methods implemented in Wavelets.jl for this purpose, with Hard and Soft thresholding being the usual go-to method due to its simplistic approach.\nReconstruct the original signals using the thresholded coefficients.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"For more information and examples on wavelet denoising using WaveletsExt.jl, visit Wavelets Denoising Experiment repository under UCD4IDS for a step-by-step tutorial in a Pluto notebook. The following is a simple guide on denoisng using WaveletsExt.jl.","category":"page"},{"location":"manual/denoising/#Denoising-a-single-signal","page":"Denoising","title":"Denoising a single signal","text":"","category":"section"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"To denoise a single signal, one can use the denoise function from WaveletsExt.jl as shown below. Note the following key parameters:","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"x: Input signal.\ninputtype: Type of input. One can input an original signal :sig, or first transform the signal and type in one of :dwt, :wpt, :sdwt, :swpd, :acwt, and :acwpt.\nwt: Transform wavelet.\nL: Number of decomposition levels. Necessary for input types :sig, :dwt, and :sdwt.\ntree: Decomposition tree of the signals. Necessary for input types :wpt and :swpd.\ndnt: Denoise type. One should input either of VisuShrink, RelErrorShrink, or SureShrink.\nestnoise: Noise estimation. Can be a function or a value.\nsmooth: Smoothing method used.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"For more detailed information, visit the denoising API page.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"using Wavelets, WaveletsExt, Random, Plots\n\n# define function and wavelet\nx₀ = generatesignals(:heavisine, 8)\nx = x₀ + 0.8*randn(256)\nwt = wavelet(WT.db4)\n\n# best basis tree\nxw = wpd(x, wt)\nbt = bestbasistree(xw, BB())\ny = getbasiscoef(xw, bt)\n\n# denoise\nx̂ = denoise(y, :wpt, wt, tree=bt)\n\n# plot results\nnothing # hide\nplot([x₀ x x̂], title=\"Denoising Example\", label=[\"original\" \"noisy\" \"denoised\"],\n     lw=[3 1 2], lc=[:black :grey :red])","category":"page"},{"location":"manual/denoising/#Denoising-a-group-of-signals","page":"Denoising","title":"Denoising a group of signals","text":"","category":"section"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"Similar to the denoise function we saw previously, for denoising a group of signals, one can use the denoiseall function. The parameters used are the same, with the following addition:","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"bestTH: Method to determine the best threshold value for a group of signals. One can choose each signal's individual best threshold value, or use a function such as mean or median to generalize an overall best threshold value.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"For more detailed information, visit the denoising API page.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"using Wavelets, WaveletsExt, Random, Plots\n\n# define function and wavelet\nx = generatesignals(:heavisine, 8)\nX₀ = duplicatesignals(x, 6, 2, false)\nX = duplicatesignals(x, 6, 2, true, 0.8)\nwt = wavelet(WT.db4)\n\n# decomposition\ncoef = wpdall(X, wt)\n\n# best basis tree\nbt = bestbasistree(coef, JBB())\nY = getbasiscoefall(coef, bt)\n\n# denoise\nX̂ = denoiseall(Y, :wpt, wt, tree=bt)\n\n# plot results\nnothing # hide\nwiggle(X₀, sc=0.7, FaceColor=:white, ZDir=:reverse)\nwiggle!(X, sc=0.7, EdgeColor=:grey, FaceColor=:white, ZDir=:reverse)\nwiggle!(X̂, sc=0.7, EdgeColor=:red, FaceColor=:white, ZDir=:reverse)\nplot!(title=\"Group Denoising Example\")","category":"page"},{"location":"manual/localdiscriminantbasis/#ldb_manual","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"","category":"section"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Local Discriminant Basis is a feature extraction technique developed by N. Saito and R. Coifman in 1995. This algorithm follows the following basic steps:","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Decompose a set of multi-class signals using wavelet packet decomposition. A wavelet packet decomposition decomposes a signal into multiple nodes which resembles a binary tree.\nBased on the decomposed wavelet coefficients, build an energy map based on time-frequency or probability density.\nUsing the energy map, compute the discriminant measure and select a basis tree that best discriminates the different classes of signals.\nBased on the selected basis tree, extract the corresponding wavelet coefficients for each signal.\nCompute the discriminant power of each coefficient index. Select the top k set of coefficients to be used as features to be passed onto a classifier such as Linear Discriminant Analysis (LDA) and Classification and Regression Trees (CART).","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"A more in-depth tutorial can be found in the Pluto notebook here. For more information on LDB, please refer to the original paper \"Local Discriminant Basis and their Applications\" by Saito and Coifman here.","category":"page"},{"location":"manual/localdiscriminantbasis/#Example","page":"Local Discriminant Basis","title":"Example","text":"","category":"section"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"We first generate a multi-class dataset. WaveletsExt.jl has 2 built-in multi-class signals dataset, namely the triangular signals (:tri) and the cylinder-bell-funnel signals (:cbf).","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"using Wavelets, WaveletsExt, Plots\n\n# generates 100 signals for each class of cylinder-bell-funnel\nX, y = generateclassdata(ClassData(:cbf, 100, 100, 100));\n\n# view sample signals and how each class differs from one another\ncylinder = wiggle(X[:,1:5], sc=0.3)\nplot!(cylinder, title=\"Cylinder signals\")\nbell = wiggle(X[:,101:105], sc=0.3)\nplot!(bell, title=\"Bell signals\")\nfunnel = wiggle(X[:,201:205], sc=0.3)\nplot!(funnel, title=\"Funnel signals\")\nplot(cylinder, bell, funnel, layout=(3,1))","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Next, we define the parameters for our Local Discriminant Basis object. Here are a few key parameters to note:","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"wt: Type of wavelet used. Default is wavelet(WT.haar).\nmax_dec_level: Maximum decomposition level. Default is to decompose each signal all the way to its maximum possible depth.\ndm: Type of discriminant measure. Available choices are:\nAsymmetricRelativeEntropy() (default)\nSymmetricRelativeEntropy()\nLpEntropy()\nHellingerDistance()\nen: Type of energy map. Available choices are:\nTimeFrequency() (default)\nProbabilityDensity()\ndp: Type of discriminant power. Available choices are:\nBasisDiscriminantMeasure() (default)\nFishersClassSeparability()\nRobustFishersClassSeparability()\ntop_k: Max number of coefficients used in each node for the computation of discriminant power. The default setting uses all available coefficients for the computation.\nn_features: Number of features to be returned. All features/coefficients will be returned by default.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"wt = wavelet(WT.coif4);\nldb = LocalDiscriminantBasis(\n    wt=wt, \n    max_dec_level=7,\n    dm=SymmetricRelativeEntropy(), \n    en=TimeFrequency(),\n    dp=BasisDiscriminantMeasure(),\n    top_k=10,\n    n_features=10\n);\n\n# transform and extract the features using LDB\nX̂ = fit_transform(ldb, X, y);\nnothing # hide","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"After fitting our data, we will then also be able to conduct our own analysis. We can observe where the best basis is selected from using the plot_tfbdry function.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"plot_tfbdry(ldb.tree)","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Another thing we can do is observe the heatmap produced by the discriminant measure (ldb.DM).","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"heatmap(1:ldb.n, 0:ldb.max_dec_level, ldb.DM);\nplot!(title=\"Discriminant Measure Heatmap\")","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"To decide how many features we should select, we can use the elbow rule on the discriminant powers (ldb.DP). From the plot below, we can see that approximately 6 features should be chosen for the classification step.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"plot(ldb.DP[ldb.order], labels=\"discriminant power\");\nplot!(title=\"Plot of LDB Discriminant Power\")","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Knowing the 6 features we want to select, we can go one step further and examine the basis vectors generated by the coefficients of these 6 indices by defining the function below. In the illustration purpose of this tutorial, the basis vectors generated by the coefficients of the top 10 features are plotted below.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"function get_basisvectors(n::Integer, wt::DiscreteWavelet, tree::BitVector,\n        idx::Vector{<:Integer})\n\n    k = length(idx)\n    y = Array{Float64,2}(undef, (n,k))\n    for (i,j) in enumerate(idx)\n        x = zeros(n)\n        x[j] = 1\n        y[:,i] = iwpt(x, wt, tree)\n    end\n    return y\nend\n\nbases = get_basisvectors(128, ldb.wt, ldb.tree, ldb.order[1:10]);\nnothing # hide\nwiggle(bases, sc=0.3, ZDir=:reverse);\nplot!(title=\"Top 10 LDB vectors\")","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Since we have decided that 6 features are optimum for classification purposes, we can use the change_nfeatures function as below.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"X̂ = change_nfeatures(ldb, X̂, 6);\nnothing # hide","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"If we are curious, we can use the inverse_transform function to observe how the signals look like if they're generated from these 6 features.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"X̃  = inverse_transform(ldb, X̂);\n\n# view sample signals and how each class differs from one another\nnothing # hide\ncylinder = wiggle(X̃[:,1:5], sc=0.3)\nplot!(cylinder, title=\"Cylinder signals\")\nbell = wiggle(X̃[:,101:105], sc=0.3)\nplot!(bell, title=\"Bell signals\")\nfunnel = wiggle(X̃[:,201:205], sc=0.3)\nplot!(funnel, title=\"Funnel signals\")\nplot(cylinder, bell, funnel, layout=(3,1))","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"With that said, we are essentially done with the LDB step, and we can move on to the model fitting step using packages such as MLJ.jl and MultivariateStats.jl.","category":"page"},{"location":"api/bestbasis/#Best-Basis","page":"Best Basis","title":"Best Basis","text":"","category":"section"},{"location":"api/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Modules = [BestBasis]","category":"page"},{"location":"api/bestbasis/#Public-API","page":"Best Basis","title":"Public API","text":"","category":"section"},{"location":"api/bestbasis/#Cost-functions-and-computations","page":"Best Basis","title":"Cost functions and computations","text":"","category":"section"},{"location":"api/bestbasis/","page":"Best Basis","title":"Best Basis","text":"BestBasis.CostFunction\nBestBasis.LSDBCost\nBestBasis.JBBCost\nBestBasis.BBCost\nBestBasis.LoglpCost\nBestBasis.NormCost\nBestBasis.DifferentialEntropyCost\nBestBasis.ShannonEntropyCost\nBestBasis.LogEnergyEntropyCost\nBestBasis.coefcost\nBestBasis.tree_costs\nBestBasis.tree_costs(::AbstractMatrix{T}, ::AbstractVector{BitVector}, ::SIBB) where T<:Number","category":"page"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.CostFunction","page":"Best Basis","title":"WaveletsExt.BestBasis.CostFunction","text":"Cost function abstract type.\n\nSee also: LSDBCost, JBBCost, BBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LSDBCost","page":"Best Basis","title":"WaveletsExt.BestBasis.LSDBCost","text":"LSDBCost <: CostFunction\n\nCost function abstract type specifically for LSDB.\n\nSee also: CostFunction, JBBCost, BBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.JBBCost","page":"Best Basis","title":"WaveletsExt.BestBasis.JBBCost","text":"JBBCost <: CostFunction\n\nCost function abstract type specifically for JBB.\n\nSee also: CostFunction, LSDBCost, BBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.BBCost","page":"Best Basis","title":"WaveletsExt.BestBasis.BBCost","text":"BBCost <: CostFunction\n\nCost function abstract type specifically for BB.\n\nSee also: CostFunction, LSDBCost, JBBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LoglpCost","page":"Best Basis","title":"WaveletsExt.BestBasis.LoglpCost","text":"LoglpCost <: JBBCost\n\nlog ell^p information cost used for JBB. Typically, we set p=2 as in  Wickerhauser's original algorithm.\n\nSee also: CostFunction, JBBCost, NormCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.NormCost","page":"Best Basis","title":"WaveletsExt.BestBasis.NormCost","text":"NormCost <: JBBCost\n\np-norm information cost used for JBB.\n\nSee also: CostFunction, JBBCost, LoglpCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.DifferentialEntropyCost","page":"Best Basis","title":"WaveletsExt.BestBasis.DifferentialEntropyCost","text":"DifferentialEntropyCost <: LSDBCost\n\nDifferential entropy cost used for LSDB.\n\nSee also: CostFunction, LSDBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.ShannonEntropyCost","page":"Best Basis","title":"WaveletsExt.BestBasis.ShannonEntropyCost","text":"ShannonEntropyCost <: LSDBCost\n\nShannon entropy cost used for BB.\n\nSee also: CostFunction, BBCost,      LogEnergyEntropyCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LogEnergyEntropyCost","page":"Best Basis","title":"WaveletsExt.BestBasis.LogEnergyEntropyCost","text":"LogEnergyEntropyCost <: LSDBCost\n\nLog energy entropy cost used for BB.\n\nSee also: CostFunction, BBCost,      ShannonEntropyCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.coefcost","page":"Best Basis","title":"WaveletsExt.BestBasis.coefcost","text":"coefcost(x, et[, nrm])\n\nArguments\n\nx::AbstractArray{T} where T<:AbstractFloat: An array of values to compute the cost.\net::CostFunction: Type of cost function.\nnrm::T where T<:AbstractFloat: The norm of the x. Only applicable when et is a BBCost.\n\nReturns\n\n::T: Cost of x.\n\nSee also: bestbasistree\n\n\n\n\n\n","category":"function"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.tree_costs","page":"Best Basis","title":"WaveletsExt.BestBasis.tree_costs","text":"tree_costs(X, method)\n\nReturns the cost of each node in a binary tree in order to find the best basis.\n\nArguments\n\nX::AbstractArray{T} where T<:AbstractFloat: A set of decomposed signals, of sizes (n,L,k) for 1D signals or (n,m,L,k) for 2D signals, where:\nn: Length of signal (1D) or vertical length of signal (2D).\nm: Horizontal length of signal (2D).\nL: Number of decomposition levels plus 1 (for standard wavelet decomposition) or   number of nodes in the tree (for redundant transforms such as ACWT and SWT).\nk: Number of signals.\nmethod::BestBasisType: Type of best basis, ie. BB(), JBB() or LSDB().\n\nnote: Note\nFor standard best basis (BB()), only one signal is processed each time, and therefore the inputs X should have dimensions (n,L) or (n,m,L) instead.\n\nReturns\n\nVector{T}: A vector containing the costs at each node.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nX = generatesignals(:heavisine, 6) |> x -> duplicatesignals(x, 5, 2, true)\nwt = wavelet(WT.db4)\nXw = wpdall(X, wt)\n\ntree_costs(Xw, JBB())\ntree_costs(Xw, LSDB())\n\nSee also: bestbasistree, bestbasis_treeselection\n\n\n\n\n\ntree_costs(y, tree, method)\n\nComputes the cost for each node from the SIWPD decomposition.\n\nArguments\n\ny::AbstractArray{T,2} where T<:Number: A SIWPD decomposed signal.\ntree::AbstractVector{BitVector}: The full SIWPD tree.\nmethod::SIBB: The SIBB() method.\n\nReturns\n\nVector{Vector{Union{T,Nothing}}}: SIWPD best basis tree.\n\nwarning: Warning\nCurrent implementation works but is unstable, ie. we are still working on better syntax/more optimized computations/better data structure.\n\n\n\n\n\n","category":"function"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.tree_costs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{BitVector}, SIBB}} where T<:Number","page":"Best Basis","title":"WaveletsExt.BestBasis.tree_costs","text":"tree_costs(y, tree, method)\n\nComputes the cost for each node from the SIWPD decomposition.\n\nArguments\n\ny::AbstractArray{T,2} where T<:Number: A SIWPD decomposed signal.\ntree::AbstractVector{BitVector}: The full SIWPD tree.\nmethod::SIBB: The SIBB() method.\n\nReturns\n\nVector{Vector{Union{T,Nothing}}}: SIWPD best basis tree.\n\nwarning: Warning\nCurrent implementation works but is unstable, ie. we are still working on better syntax/more optimized computations/better data structure.\n\n\n\n\n\n","category":"method"},{"location":"api/bestbasis/#Best-basis-computation","page":"Best Basis","title":"Best basis computation","text":"","category":"section"},{"location":"api/bestbasis/","page":"Best Basis","title":"Best Basis","text":"BestBasis.BestBasisType\nBestBasis.LSDB\nBestBasis.JBB\nBestBasis.BB\nBestBasis.SIBB\nWavelets.Threshold.bestbasistree\nWavelets.Threshold.bestbasistree(::AbstractMatrix{T}, ::Integer, ::SIBB) where T<:Number\nBestBasis.bestbasistreeall","category":"page"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.BestBasisType","page":"Best Basis","title":"WaveletsExt.BestBasis.BestBasisType","text":"BestBasisType\n\nAbstract type for best basis. Current available types are:\n\nLSDB\nJBB\nBB\nSIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LSDB","page":"Best Basis","title":"WaveletsExt.BestBasis.LSDB","text":"LSDB([; cost, redundant])\n\nLeast Statistically Dependent Basis (LSDB). \n\nKeyword Arguments\n\ncost::LSDBCost: (Default: DifferentialEntropyCost()) Cost function for LSDB.\nredundant::Bool: (Default: false) Whether the performed wavelet transform is redundant. Set redundant=true when running LSDB with redundant wavelet transforms such as SWT or ACWT.\n\nSee also: BestBasisType, JBB, BB, SIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.JBB","page":"Best Basis","title":"WaveletsExt.BestBasis.JBB","text":"JBB([; cost, redundant])\n\nJoint Best Basis (JBB).\n\nKeyword Arguments\n\ncost::JBBCost: (Default: LoglpCost(2)) Cost function for JBB.\nredundant::Bool: (Default: false) Whether the performed wavelet transform is redundant. Set redundant=true when running LSDB with redundant wavelet transforms such as SWT or ACWT.\n\nSee also: BestBasisType, LSDB, BB, SIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.BB","page":"Best Basis","title":"WaveletsExt.BestBasis.BB","text":"BB([; cost, redundant])\n\nStandard Best Basis (BB). \n\nKeyword Arguments\n\ncost::BBCost: (Default: ShannonEntropyCost()) Cost function for BB.\nredundant::Bool: (Default: false) Whether the performed wavelet transform is redundant. Set redundant=true when running LSDB with redundant wavelet transforms such as SWT or ACWT.\n\nSee also: BestBasisType, LSDB, JBB, SIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.SIBB","page":"Best Basis","title":"WaveletsExt.BestBasis.SIBB","text":"SIBB([; cost])\n\nShift Invariant Best Basis (SIBB).\n\nKeyword Arguments\n\ncost::BBCost: (Default: ShannonEntropyCost()) Cost function for SIBB.\n\nSee also: BestBasisType, LSDB, JBB,      BB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#Wavelets.Threshold.bestbasistree","page":"Best Basis","title":"Wavelets.Threshold.bestbasistree","text":"bestbasistree(X[, method])\n\nExtension to the best basis tree function from Wavelets.jl. Given a set of decomposed signals, returns different types of best basis trees based on the methods specified. Available methods are the joint best basis (JBB), least statistically dependent basis (LSDB), individual regular best basis (BB), and shift-invariant best basis (SIBB).\n\nArguments\n\nX::AbstractArray{T} where T<:AbstractFloat: A set of decomposed signals, of sizes (n,L,k) for 1D signals or (n,m,L,k) for 2D signals, where:\nn: Length of signal (1D) or vertical length of signal (2D).\nm: Horizontal length of signal (2D).\nL: Number of decomposition levels plus 1 (for standard wavelet decomposition) or number of nodes in the tree (for redundant transforms such as ACWT and SWT).\nk: Number of signals.\nmethod::BestBasisType: Type of best basis, ie. BB(), JBB() or LSDB().\n\ntip: Tip\nFor standard best basis (BB()), this current function can only process one signal at a time, ie. the input X should have dimensions (n,L) or (n,m,L). To process multiple signals using one function, see bestbasistreeall.\n\nReturns\n\n::BitVector: Best basis tree.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nX = generatesignals(:heavisine, 6) |> x -> duplicatesignals(x, 5, 2, true)\nwt = wavelet(WT.db4)\nXw = wpdall(X, wt)\n\nbestbasistree(Xw, JBB())\nbestbasistree(Xw, LSDB())\n\nSee also: getbasiscoef, getbasiscoefall, tree_costs, delete_subtree!\n\n\n\n\n\nbestbasistree(y, d, method)\n\nComputes the best basis tree for the shift invariant wavelet packet decomposition (SIWPD).\n\nArguments\n\ny::AbstractArray{T,2} where T<:Number: A SIWPD decomposed signal.\nd::Integer: The number of depth computed for the decomposition.\nmethod::SIBB: The SIBB() method.\n\nReturns\n\nVector{BitVector}: SIWPD best basis tree.\n\nwarning: Warning\nCurrent implementation works but is unstable, ie. we are still working on better syntax/more optimized computations/better data structure.\n\n\n\n\n\n","category":"function"},{"location":"api/bestbasis/#Wavelets.Threshold.bestbasistree-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, SIBB}} where T<:Number","page":"Best Basis","title":"Wavelets.Threshold.bestbasistree","text":"bestbasistree(y, d, method)\n\nComputes the best basis tree for the shift invariant wavelet packet decomposition (SIWPD).\n\nArguments\n\ny::AbstractArray{T,2} where T<:Number: A SIWPD decomposed signal.\nd::Integer: The number of depth computed for the decomposition.\nmethod::SIBB: The SIBB() method.\n\nReturns\n\nVector{BitVector}: SIWPD best basis tree.\n\nwarning: Warning\nCurrent implementation works but is unstable, ie. we are still working on better syntax/more optimized computations/better data structure.\n\n\n\n\n\n","category":"method"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.bestbasistreeall","page":"Best Basis","title":"WaveletsExt.BestBasis.bestbasistreeall","text":"bestbasistreeall(X, method)\n\nCompute the standard best basis tree of a set of signals.\n\nArguments\n\nX::AbstractArray{T} where T<:AbstractFloat: A set of decomposed signals, of sizes (n,L,k) for 1D signals or (n,m,L,k) for 2D signals, where:\nn: Length of signal (1D) or vertical length of signal (2D).\nm: Horizontal length of signal (2D).\nL: Number of decomposition levels plus 1 (for standard wavelet decomposition) or   number of nodes in the tree (for redundant transforms such as ACWT and SWT).\nk: Number of signals.\nmethod::BB: Standard best basis method, eg. BB().\n\nReturns\n\n::BitMatrix: (nₜ,k) matrix where each column corresponds to a tree.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nX = generatesignals(:heavisine, 6) |> x -> duplicatesignals(x, 5, 2, true)\nwt = wavelet(WT.db4)\n\nXw = wpdall(X, wt)\nbestbasistreeall(Xw, BB())\n\nXw = swpdall(X, wt)\nbestbasistree(Xw, BB(redundant=true))\n\nSee also: bestbasistree\n\n\n\n\n\n","category":"function"},{"location":"api/bestbasis/#Private-API","page":"Best Basis","title":"Private API","text":"","category":"section"},{"location":"api/bestbasis/","page":"Best Basis","title":"Best Basis","text":"BestBasis.bestbasis_treeselection\nBestBasis.bestbasis_treeselection(::AbstractVector{Tc}, ::AbstractVector{Tt}) where {Tc<:AbstractVector{<:Union{Number,Nothing}}, Tt<:BitVector}\nBestBasis.delete_subtree!\n","category":"page"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.bestbasis_treeselection","page":"Best Basis","title":"WaveletsExt.BestBasis.bestbasis_treeselection","text":"bestbasis_treeselection(costs, n[, type])\nbestbasis_treeselection(costs, n, m[, type])\n\nComputes the best basis tree based on the given cost vector.\n\nArguments\n\ncosts::AbstractVector{T}: Vector containing costs for each node.\nn::Integer: Length of signals (for 1D cases) or vertical length of signals (for 2D cases).\nm::Integer: Horizontal length of signals (for 2D cases).\ntype::Symbol: (Default: :min) Criterion used to select the best tree. Supported types are :min and :max. Eg. Setting type = :min results in a basis tree with the lowest cost to be selected.\n\nReturns\n\n::BitVector: Best basis tree selected based on cost.\n\nSee also: bestbasistree, tree_costs\n\n\n\n\n\nbestbasis_treeselection(costs, tree)\n\nBest basis tree selection on SIWPD.\n\nArguments\n\ncosts::AbstractVector{Tc} where Tc<:AbstractVector{<:Union{Number, Nothing}}: Cost of each node.\ntree::AbstractVector{Tt} where Tt<:BitVector: SIWPD tree.\n\nwarning: Warning\nCurrent implementation works but is unstable, ie. we are still working on better syntax/more optimized computations/better data structure.\n\n\n\n\n\n","category":"function"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.bestbasis_treeselection-Union{Tuple{Tt}, Tuple{Tc}, Tuple{AbstractVector{Tc}, AbstractVector{Tt}}} where {Tc<:(AbstractVector{var\"#s36\"} where var\"#s36\"<:Union{Nothing, Number}), Tt<:BitVector}","page":"Best Basis","title":"WaveletsExt.BestBasis.bestbasis_treeselection","text":"bestbasis_treeselection(costs, tree)\n\nBest basis tree selection on SIWPD.\n\nArguments\n\ncosts::AbstractVector{Tc} where Tc<:AbstractVector{<:Union{Number, Nothing}}: Cost of each node.\ntree::AbstractVector{Tt} where Tt<:BitVector: SIWPD tree.\n\nwarning: Warning\nCurrent implementation works but is unstable, ie. we are still working on better syntax/more optimized computations/better data structure.\n\n\n\n\n\n","category":"method"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.delete_subtree!","page":"Best Basis","title":"WaveletsExt.BestBasis.delete_subtree!","text":"delete_subtree!(bt, i, tree_type)\n\nDeletes a subtree of the entire tree due to children's inferior costs.\n\nArguments\n\nbt::BitVector: Tree.\ni::Integer: Root of the subtree to be deleted.\ntree_type::Symbol: Type of tree (:binary or :quad).\n\nReturns\n\nbt::BitVector: Tree with deleted subtree.\n\nSee also: bestbasistree, bestbasis_treeselection\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#denoising_api","page":"Denoising","title":"Denoising","text":"","category":"section"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Modules = [Denoising]","category":"page"},{"location":"api/denoising/#Public-API","page":"Denoising","title":"Public API","text":"","category":"section"},{"location":"api/denoising/#Shrinking-Types-and-Constructors","page":"Denoising","title":"Shrinking Types and Constructors","text":"","category":"section"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Denoising.RelErrorShrink\nDenoising.SureShrink\nDenoising.SureShrink(::AbstractArray{T}, ::Bool, ::Union{BitVector, Nothing}, ::Wavelets.Threshold.THType) where T<:Number\nWavelets.Threshold.VisuShrink","category":"page"},{"location":"api/denoising/#WaveletsExt.Denoising.RelErrorShrink","page":"Denoising","title":"WaveletsExt.Denoising.RelErrorShrink","text":"RelErrorShrink(th, t) <: DNFT\n\nRelative Error Shrink method used in their paper \"Efficient Approximation and Denoising of Graph Signals using the Multiscale Basis Dictionary\" for IEEE Transactions on Signal and Information Processing over Networks, Vol 0, No. 0, 2016.\n\nAttributes\n\nth::Wavelets.Threshold.THType: (Default: Wavelets.HardTH()) Threshold type.\nt::AbstractFloat: (Default: 1.0) Threshold size.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nRelErrorShrink()                    # Using default th and t values\nRelErrorShrink(SoftTH())            # Using default t value\nRelErrorShrink(HardTH(), 0.5)       # Using user input th and t values\n\nSee also: SureShrink, VisuShrink\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#WaveletsExt.Denoising.SureShrink","page":"Denoising","title":"WaveletsExt.Denoising.SureShrink","text":"SureShrink(th, t) <: DNFT\n\nStein's Unbiased Risk Estimate (SURE) Shrink\n\nAttributes\n\nth::Wavelets.Threshold.THType: (Default: Wavelets.HardTH()) Threshold type.\nt::AbstractFloat: (Default: 1.0) Threshold size.\n\nSee also: RelErrorShrink, VisuShrink\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#WaveletsExt.Denoising.SureShrink-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}, Wavelets.Threshold.THType}} where T<:Number","page":"Denoising","title":"WaveletsExt.Denoising.SureShrink","text":"SureShrink(xw[, redundant, tree, th])\n\nStruct constructor for SureShrink based on the signal coefficients xw.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: Decomposed signal.\nredundant::Bool: (Default: false) Whether the transform type of xw is a redundant transform. Autocorrelation and stationary wavelet transforms are examples of redundant transforms.\ntree::Union{BitVector, Nothing}: (Default: nothing) The basis tree for decomposing xw. Must be provided if xw is decomposed using wpt, swpd, or acwpd.\nth::Wavelets.Threshold.THType: (Default: HardTH()) Threshold type.\n\nReturns\n\n::SureShrink: SUREShrink object.\n\nExamples\n\nSureShrink(xw)                  # `xw` is output of dwt, wpt\nSureShrink(xw, true)            # `xw` is output of sdwt, acdwt, swpt, acwpt\nSureShrink(xw, true, tree)      # `xw` is output of swpd, acwpd\n\nSee also: SureShrink, surethreshold\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#Wavelets.Threshold.VisuShrink","page":"Denoising","title":"Wavelets.Threshold.VisuShrink","text":"VisuShrink(n, th)\n\nExtension to the VisuShrink struct constructor from Wavelets.jl.\n\nArguments\n\nn::Integer: Signal length.\nth::Wavelets.Threshold.THType: Threshold type.\n\nReturns\n\n::Wavelets.Threshold.VisuShrink: VisuShrink object.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nVisuShrink(128, SoftTH())\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#Threshold-Determination-and-Noise-Estimation","page":"Denoising","title":"Threshold Determination and Noise Estimation","text":"","category":"section"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Wavelets.Threshold.noisest\nDenoising.relerrorthreshold","category":"page"},{"location":"api/denoising/#Wavelets.Threshold.noisest","page":"Denoising","title":"Wavelets.Threshold.noisest","text":"noisest(x, redundant[, tree])\n\nExtension to the noisest function from Wavelets.jl. Estimates the standard deviation of a signal's noise assuming that the noise is distributed normally. This function is generally used in combination with VisuShrink and SureShrink in the denoise/denoiseall functions. \n\nArguments\n\nx::AbstractArray{T}: Decomposed signal.\nredundant::Bool: Whether the transform type of xw is a redundant transform. Autocorrelation and stationary wavelet transforms are examples of redundant transforms.\ntree::Union{BitVector, Nothing}: (Default: nothing) The basis tree for decomposing xw. Must be provided if xw is decomposed using wpt, swpd, or acwpd.\n\nReturns\n\n::AbstractFloat: Estimated standard deviation of the noise of the signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\nx = randn(128)\nwt = wavelet(WT.haar)\n\n# noise estimate for dwt transformation\ny = dwt(x, wt)\nnoise = noisest(y, false)\n\n# noise estimate for wpt transformation\ntree = maketree(x, :full)\ny = wpt(x, wt, tree)\nnoise = noisest(y, false, tree)\n\n# noise estimate for sdwt transformation\ny = sdwt(x, wt)\nnoise = noisest(y, true)\n\n# noise estimate for swpd transformation\ny = swpd(x, wt)\nnoise = noisest(y, true, tree)\n\nSee also: relerrorthreshold, VisuShrink, SureShrink\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#WaveletsExt.Denoising.relerrorthreshold","page":"Denoising","title":"WaveletsExt.Denoising.relerrorthreshold","text":"relerrorthreshold(coef, [redundant, tree, elbows; makeplot])\n\nTakes in a set of expansion coefficients, 'plot' the threshold vs relative error curve and select the best threshold value based on the elbow method. If one wants to see the resulting plot from this computation, simply set makeplot=true.\n\nArguments\n\ncoef::AbstractArray{T} where T<:Number: Decomposed signal.\nredundant::Bool: (Default: false) Whether the transform type of xw is a redundant transform. Autocorrelation and stationary wavelet transforms are examples of redundant transforms.\ntree::Union{BitVector, Nothing}: (Default: nothing) The basis tree for decomposing xw. Must be provided if xw is decomposed using swpd or acwpd.\nelbows::Integer: (Default: 2) Number of elbows used to determine the best threshold value.\n\nKeyword Arguments\n\nmakeplot::Bool: (Default: false) Whether to return the plot that was used to determine the best threshold value.\n\nReturns\n\n::AbstractFloat: Best threshold value.\n::GR.Plot: Plot that was used to determine the best threshold value. Only returned if makeplot = true.\n\nExamples\n\nx = randn(128)\nwt = wavelet(WT.haar)\n\n# noise estimate for dwt transformation\ny = dwt(x, wt)\nnoise = relerrorthreshold(y, false)\n\n# noise estimate for wpt transformation\ntree = maketree(x, :full)\ny = wpt(x, wt, tree)\nnoise = relerrorthreshold(y, false, tree)\n\n# noise estimate for sdwt transformation\ny = sdwt(x, wt)\nnoise = relerrorthreshold(y, true)\n\n# noise estimate for swpd transformation\ny = swpd(x, wt)\nnoise = relerrorthreshold(y, true, tree)\n\nSee also: noisest, RelErrorShrink\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#Denoising-Functions","page":"Denoising","title":"Denoising Functions","text":"","category":"section"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Wavelets.Threshold.denoise\nDenoising.denoiseall","category":"page"},{"location":"api/denoising/#Wavelets.Threshold.denoise","page":"Denoising","title":"Wavelets.Threshold.denoise","text":"denoise(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),\n    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),\n    estnoise=noisest, smooth=:regular])\n\nExtension of the denoise function from Wavelets.jl. Denoise a signal of  input type inputtype.\n\nArguments:\n\nx::AbstractArray{<:Number}: input signals/coefficients.\ninputtype::Symbol: input type of x. Current accepted types of inputs are\n:sig: original signals; x should be a 2-D array with each column    representing a signal.\n:dwt: dwt-transformed signal coefficients; x should be a 1-D array    with each column representing the coefficients of a signal.\n:wpt: wpt-transformed signal coefficients; x should be a 1-D array    with each column representing the coefficients of a signal.\n:sdwt: sdwt-transformed signal coefficients; x should be a 2-D array   with each column representing the coefficients of a node.\n:swpd: swpd-transformed signal coefficients; x should be a 2-D array   with each column representing the coefficients of a node.\n:acwt: acwt-transformed signal coefficients from    AutocorrelationShell.jl; x should be a 2-D array with each column    representing the coefficients of a node.\n:acwpt: acwpt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 2-D array with each column    representing the coefficients of a node.\nwt::Union{DiscreteWavelet, Nothing}: the discrete wavelet to be used for   decomposition (for input type :sig) and reconstruction. nothing can    be supplied if no reconstruction is necessary.\nL::Integer: the number of decomposition levels. Necessary for input types   :sig, :dwt, and :sdwt. Default value is set to be    maxtransformlevels(size(x,1)).\ntree::BitVector: the decomposition tree of the signals. Necessary for input   types :wpt and :swpd. Default value is set to be    maketree(size(x,1), L, :dwt).\ndnt::DNFT: denoise type. Default type is set to be VisuShrink(size(x,1)).\nestnoise::Union{Function, Vector{<:Number}}: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the noisest function.\nsmooth::Symbol: the smoothing method used. :regular smoothing thresholds   all given coefficients, whereas :undersmooth smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be :regular.\n\nSee also: denoiseall, noisest,      relerrorthreshold\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#WaveletsExt.Denoising.denoiseall","page":"Denoising","title":"WaveletsExt.Denoising.denoiseall","text":"denoiseall(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),\n    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),\n    estnoise=noisest, bestTH=nothing, smooth=:regular])\n\nDenoise multiple signals of input type inputtype. \n\nArguments:\n\nx::AbstractArray{<:Number}: input signals/coefficients.\ninputtype::Symbol: input type of x. Current accepted types of inputs are\n:sig: original signals; x should be a 2-D array with each column    representing a signal.\n:dwt: dwt-transformed signal coefficients; x should be a 2-D array    with each column representing the coefficients of a signal.\n:wpt: wpt-transformed signal coefficients; x should be a 2-D array    with each column representing the coefficients of a signal.\n:sdwt: sdwt-transformed signal coefficients; x should be a 3-D array   with each 2-D slice representing the coefficients of a signal.\n:swpd: swpd-transformed signal coefficients; x should be a 3-D array   with each 2-D slice representing the coefficients of a signal.\n:acwt: acwt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 3-D array with each 2-D slice    representing the coefficients of a signal.\n:acwpt: acwpt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 3-D array with each 2-D slice    representing the coefficients of a signal.\nwt::Union{DiscreteWavelet, Nothing}: the discrete wavelet to be used for   decomposition (for input type :sig) and reconstruction. nothing can    be supplied if no reconstruction is necessary.\nL::Integer: the number of decomposition levels. Necessary for input types   :sig, :dwt, and :sdwt. Default value is set to be    maxtransformlevels(size(x,1)).\ntree::BitVector: the decomposition tree of the signals. Necessary for input   types :wpt and :swpd. Default value is set to be    maketree(size(x,1), L, :dwt).\ndnt::DNFT: denoise type. Default type is set to be VisuShrink(size(x,1)).\nestnoise::Union{Function, Vector{<:Number}}: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the noisest function.\nbestTH::Union{Function, Nothing}: method to determine the best threshold    value for a group of signals. If nothing is given, then each signal will   be denoised by its respective best threshold value determined from the    parameters dnt and estnoise; otherwise some function can be passed   to determine the best threshold value from a vector of threshold values, eg:   mean and median. Default is set to be nothing.\nsmooth::Symbol: the smoothing method used. :regular smoothing thresholds   all given coefficients, whereas :undersmooth smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be :regular.\n\nSee alse: denoise, noisest, relerrorthreshold\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#Private-API","page":"Denoising","title":"Private API","text":"","category":"section"},{"location":"api/denoising/#Helper-Functions-for-Threshold-Determination-and-Noise-Estimation","page":"Denoising","title":"Helper Functions for Threshold Determination and Noise Estimation","text":"","category":"section"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Denoising.surethreshold\nDenoising.orth2relerror\nDenoising.findelbow\nDenoising.relerrorplot","category":"page"},{"location":"api/denoising/#WaveletsExt.Denoising.surethreshold","page":"Denoising","title":"WaveletsExt.Denoising.surethreshold","text":"surethreshold(coef, redundant[, tree])\n\nDetermination of the t value used for SureShrink. t is defined as the threshold value when the standard deviation of the noisy signal is 1.\n\nArguments\n\ncoef::AbstractArray{T} where T<:Number: Coefficients of decomposed signal.\nredundant::Bool: Whether the transform type of xw is a redundant transform. Autocorrelation and stationary wavelet transforms are examples of redundant transforms.\ntree::Union{BitVector, Nothing}: (Default: nothing) The basis tree for decomposing xw. Must be provided if xw is decomposed using wpt, swpd, or acwpd.\n\nReturns\n\n::AbstractFloat: t value used for SureShrink.\n\nSee also: SureShrink\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#WaveletsExt.Denoising.orth2relerror","page":"Denoising","title":"WaveletsExt.Denoising.orth2relerror","text":"orth2relerror(orth)\n\nGiven a vector 'orth' of orthonormal expansion coefficients, return a vector of relative approximation errors when retaining the 1,2,...,N largest coefficients in magnitude.\n\nArguments\n\north::AbstractVector{T} where T<:Number: Vector of coefficients.\n\nReturns\n\n::Vector{T}: Relative errors.\n\nSee also: RelErrorShrink, relerrorthreshold, findelbow\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#WaveletsExt.Denoising.findelbow","page":"Denoising","title":"WaveletsExt.Denoising.findelbow","text":"findelbow(x, y)\n\nGiven the x and y coordinates of a curve, return the elbow.\n\nArguments\n\nx::AbstractVector{T} where T<:Number: x-coordinates.\ny::AbstractVector{T} where T<:Number: y-coordinates.\n\nReturns\n\n::Integer: Index of the elbow point.\n::Vector{T}: Length of adjacent sides.\n::Vector{T}: The y-coordinates going in the direction of (x₁, y₁) to (xₙ, yₙ)\n\nSee also: RelErrorShrink, relerrorthreshold, orth2relerror\n\n\n\n\n\n","category":"function"},{"location":"api/denoising/#WaveletsExt.Denoising.relerrorplot","page":"Denoising","title":"WaveletsExt.Denoising.relerrorplot","text":"relerrorplot(x, y, ix, A, v)\n\nRelative error plot used for threshold determination using the elbow rule.\n\nArguments\n\nx::Vector{T} where T<:Number: x-coordinates.\ny::Vector{T} where T<:Number: y-coordinates.\nix::Vector{<:Integer}: Indices for elbow points.\nA::Vector{S} where {S<:Vector{T}, T<:Number}: Length of adjacent sides.\nv::Vector{S} where {S<:Vector{T}, T<:Number}: The y-coordinates going in the direction of (x[1], y[1]) to (x[ix], y[ix])\n\nReturns\n\n::Plot: Relative error plot.\n\nSee also: relerrorthreshold, findelbow\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#Stationary-Wavelet-Transform","page":"SWT","title":"Stationary Wavelet Transform","text":"","category":"section"},{"location":"api/swt/","page":"SWT","title":"SWT","text":"Modules = [SWT]","category":"page"},{"location":"api/swt/#Public-API","page":"SWT","title":"Public API","text":"","category":"section"},{"location":"api/swt/#Transforms-on-1-Signal","page":"SWT","title":"Transforms on 1 Signal","text":"","category":"section"},{"location":"api/swt/","page":"SWT","title":"SWT","text":"SWT.sdwt\nSWT.sdwt!\nSWT.isdwt\nSWT.isdwt!\nSWT.swpt\nSWT.swpt!\nSWT.iswpt\nSWT.iswpt!\nSWT.swpd\nSWT.swpd!\nSWT.iswpd\nSWT.iswpd!","category":"page"},{"location":"api/swt/#WaveletsExt.SWT.sdwt","page":"SWT","title":"WaveletsExt.SWT.sdwt","text":"sdwt(x, wt[, L])\n\nComputes the stationary discrete wavelet transform (SDWT) for L levels.\n\nArguments\n\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Original signal,   preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Matrix{T} or ::Array{T,3}: Output from SDWT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SDWT\nxw = sdwt(x, wt)\n\nSee also: swpd, swpt, isdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.sdwt!","page":"SWT","title":"WaveletsExt.SWT.sdwt!","text":"sdwt!(xw, x, wt[, L])\n\nSame as sdwt but without array allocation.\n\nArguments\n\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: An allocated array of dimension (n,L+1) to write the outputs of x onto.\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\nxw::Array{T,2} or xw::Array{T,3}: Output from SDWT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine, 7)\nwt = wavelet(WT.haar)\n\n# SDWT\nxw = Matrix{Float64}(undef, (128,5))\nsdwt!(xw, x, wt, 4)\n\nSee also: sdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwt","page":"SWT","title":"WaveletsExt.SWT.isdwt","text":"isdwt(xw, wt[, sm])\n\nComputes the inverse stationary discrete wavelet transform (iSDWT) on xw.\n\nArguments\n\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: SDWT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\n::Vector{T} or ::Matrix{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SDWT\nxw = sdwt(x, wt)\n\n#  Shift-based iSDWT\nx̂ = isdwt(xw, wt, 5)\n\n# Average-based iSDWT\nx̃ = isdwt(xw, wt)\n\nSee also: isdwt_step, iswpt, sdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwt!","page":"SWT","title":"WaveletsExt.SWT.isdwt!","text":"isdwt!(x, xw, wt[, sm])\n\nSame as isdwt but with no array allocation.\n\nArguments\n\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Allocation for reconstructed signal.\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: SDWT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\nx::Vector{T} or x::Matrix{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SDWT\nxw = sdwt(x, wt)\n\n#  Shift-based iSDWT\nx̂ = similar(x)\nisdwt!(x̂, xw, wt, 5)\n\n# Average-based iSDWT\nisdwt(x̂, xw, wt)\n\nSee also: isdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpt","page":"SWT","title":"WaveletsExt.SWT.swpt","text":"swpt(x, wt[, L])\n\nComputes L levels of stationary wavelet packet transform (SWPT) on x.\n\nArguments\n\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Matrix{T} or ::Array{T,3}: Output from SWPT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPT\nxw = swpt(x, wt)\n\nSee also: sdwt, swpd\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpt!","page":"SWT","title":"WaveletsExt.SWT.swpt!","text":"swpt!(xw, x, wt[, L])\n\nSame as swpt but without array allocation.\n\nArguments\n\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: Allocation for transformed signal.\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\nxw::Matrix{T} or xw::Array{T,3}: Output from SWPT on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPT\nxw = Array{Float64,2}(undef, (128,128))\nswpt!(xw, x, wt)\n\nSee also: swpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswpt","page":"SWT","title":"WaveletsExt.SWT.iswpt","text":"iswpt(xw, wt[, sm])\n\nComputes the inverse stationary wavelet packet transform (iSWPT) on xw.\n\nArguments\n\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: SWPT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\n::Vector{T} or ::Matrix{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPT\nxw = swpt(x, wt)\n\n# Shift-based iSWPT\nx̂ = iswpt(xw, wt, 5)\n\n# Average-based iSWPT\nx̃ = iswpt(xw, wt)\n\nSee also: isdwt_step, isdwt, swpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswpt!","page":"SWT","title":"WaveletsExt.SWT.iswpt!","text":"iswpt!(x, xw, wt[, sm])\n\nSame as iswpt but with no array allocation.\n\nArguments\n\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Allocation for inverse transform.\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: SWPT-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\nx::Vector{T} or x::Matrix{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPT\nxw = swpt(x, wt)\n\n# Shift-based iSWPT\nx̂ = similar(x)\niswpt!(x̂, xw, wt, 5)\n\n# Average-based iSWPT\niswpt!(x̂, xw, wt)\n\nSee also: iswpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpd","page":"SWT","title":"WaveletsExt.SWT.swpd","text":"swpd(x, wt[, L])\n\nComputes L levels of stationary wavelet packet decomposition (SWPD) on x.\n\nArguments\n\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\n::Matrix{T} or ::Array{T,3}: Output from SWPD on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPD\nxw = swpd(x, wt)\n\nSee also: iswpd, swpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpd!","page":"SWT","title":"WaveletsExt.SWT.swpd!","text":"swpd!(xw, x, wt[, L])\n\nSame as swpd but without array allocation.\n\nArguments\n\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: Allocation for transformed signal.\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Original signal, preferably of size 2ᴷ where K in mathbbN.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x)) Number of levels of decomposition.\n\nReturns\n\nxw::Matrix{T} or xw::Array{T,3}: Output from SWPD on x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPD\nxw = Matrix{T}(undef, (128, 255))\nswpd!(xw, x, wt)\n\nSee also: swpd\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswpd","page":"SWT","title":"WaveletsExt.SWT.iswpd","text":"iswpd(xw, wt, L, sm)\niswpd(xw, wt[, L])\niswpd(xw, wt, tree[, sm])\n\nComputes the inverse stationary wavelet packet transform (iSWPT) on xw.\n\nnote: Note\nThis function might not be very useful if one is looking to reconstruct a raw decomposed signal. The purpose of this function would be better utilized in applications such as denoising, where a signal is decomposed (swpd) and thresholded (denoise/denoiseall) before being reconstructed.\n\nArguments\n\nxw::AbstractArray{T,2} or x::AbstractArray{T,3} where T<:Number: SWPD-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x) or minimum(size(xw)[1:end-1]) |> maxtransformlevels) Number of levels of decomposition used for reconstruction.\ntree::BitVector: Binary/Quad tree for inverse transform to be computed accordingly. \nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\n::Vector{T} or ::Matrix{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPD\nxw = swpt(x, wt)\n\n# Shift-based iSWPD\nx̂ = iswpd(xw, wt, maxtransformlevels(xw,1), 5)\n\n# Average-based iSWPD\nx̃ = iswpd(xw, wt)\n\nSee also: isdwt_step, iswpt, swpd, iswpd!\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswpd!","page":"SWT","title":"WaveletsExt.SWT.iswpd!","text":"iswpd!(x, xw, wt, L, sm)\niswpd!(x, xw, wt[, L])\niswpd!(x, xw, wt, tree, sm)\niswpd!(x, xw, wt, tree)\n\nSame as iswpd but with no array allocation.\n\nArguments\n\nx::AbstractVector{T} or x::AbstractMatrix{T} where T<:Number: Allocated array for output.\nxw::AbstractArray{T,2} or xw::AbstractArray{T,3} where T<:Number: SWPD-transformed array.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: maxtransformlevels(x) or minimum(size(xw)[1:end-1]) |> maxtransformlevels) Number of levels of decomposition used for reconstruction.\ntree::BitVector: Binary/Quad tree for inverse transform to be computed accordingly. \nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\nx::Vector{T} or x::Matrix{T}: Inverse transformed signal.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nx = generatesignals(:heavysine)\nwt = wavelet(WT.haar)\n\n# SWPD\nxw = swpd(x, wt)\n\n# ISWPD\nx̂ = similar(x)\niswpd!(x̂, xw, wt, 4, 5)\niswpd!(x̂, xw, wt, maketree(x), 5)\niswpd!(x̂, xw, wt, 4)\niswpd!(x̂, xw, wt, maketree(x))\n\nSee also: iswpd\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#Transforms-on-Multiple-Signals","page":"SWT","title":"Transforms on Multiple Signals","text":"","category":"section"},{"location":"api/swt/","page":"SWT","title":"SWT","text":"SWT.sdwtall\nSWT.isdwtall\nSWT.swptall\nSWT.iswptall\nSWT.swpdall\nSWT.iswpdall","category":"page"},{"location":"api/swt/#WaveletsExt.SWT.sdwtall","page":"SWT","title":"WaveletsExt.SWT.sdwtall","text":"sdwtall(x, wt[, L])\n\nComputes the stationary discrete wavelet transform (SDWT) on each slice of signal.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input N-1-D signals, where each signal is sliced at dimension N.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of transformed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# SDWT on all signals in x\nxw = sdwtall(x, wt)\n\nSee also: sdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwtall","page":"SWT","title":"WaveletsExt.SWT.isdwtall","text":"isdwtall(xw[, wt])\nisdwtall(xw, wt, sm)\n\nComputes the inverse stationary discrete wavelet transform (ISDWT) on each slice of signal.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: SDWT-transformed signal.\nwt::OrthoFilter: (Default: nothing) Orthogonal wavelet filter.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of reconstructed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# SDWT on all signals in x\nxw = sdwtall(x, wt)\n\n# ISDWT on all signals in xw\nx̂ = isdwtall(xw)\n\nSee also: isdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swptall","page":"SWT","title":"WaveletsExt.SWT.swptall","text":"swptall(x, wt[, L])\n\nComputes the stationary wavelet packet transform (SWPT) on each slice of signal.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input N-1-D signals, where each signal is sliced at dimension N.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of transformed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# SWPT on all signals in x\nxw = swptall(x, wt)\n\nSee also: swpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswptall","page":"SWT","title":"WaveletsExt.SWT.iswptall","text":"iswptall(xw[, wt])\niswptall(xw, wt, sm)\n\nComputes the inverse stationary wavelet packet transform (ISWPT) on each slice of signal.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: SWPT-transformed signal.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of reconstructed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# SWPT on all signals in x\nxw = swptall(x, wt)\n\n# ISWPT on all signals in xw\nx̂ = iswptall(xw)\n\nSee also: iswpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpdall","page":"SWT","title":"WaveletsExt.SWT.swpdall","text":"swpdall(x, wt[, L])\n\nComputes the stationary wavelet packet decomposition (SWPD) on each slice of signal.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input N-1-D signals, where each signal is sliced at dimension N.\nwt::OrthoFilter: Orthogonal wavelet filter.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of transformed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# SWPD on all signals in x\nxw = swpdall(x, wt)\n\nSee also: swpd\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswpdall","page":"SWT","title":"WaveletsExt.SWT.iswpdall","text":"iswpdall(xw, wt, L, sm)\niswpdall(xw, wt[, L])\niswpdall(xw, wt, tree, sm)\niswpdall(xw, wt, tree)\n\nComputes the inverse autocorrelation wavelet packet decomposition (ISWPD) on each slice of signal.\n\nArguments\n\nxw::AbstractArray{T} where T<:Number: SWPD-transformed signal.\nwt::Union{OrthoFilter, Nothing}: (Default: nothing) Orthogonal wavelet filter.\nL::Integer: (Default: minimum(size(xw)[1:end-2]) |> maxtransformlevels) Number of levels of wavelet transforms.\ntree::BitVector: Binary tree for inverse transform to be computed accordingly.\nsm::Integer: If sm is included as an argument, the sm-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.\n\nReturns\n\n::Array{T}: Slices of reconstructed signals.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# SWPD on all signals in x\nxw = swpdall(x, wt)\n\n# ISWPD on all signals in xw\nx̂ = iswpdall(xw)\nx̂ = iswpdalll(xw, maketree(x))\nx̂ = iswpdall(xw, 5)\n\nSee also: iswpd\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#Private-API","page":"SWT","title":"Private API","text":"","category":"section"},{"location":"api/swt/#Single-Step-Transforms","page":"SWT","title":"Single Step Transforms","text":"","category":"section"},{"location":"api/swt/","page":"SWT","title":"SWT","text":"SWT.sdwt_step\nSWT.sdwt_step!\nSWT.isdwt_step\nSWT.isdwt_step!","category":"page"},{"location":"api/swt/#WaveletsExt.SWT.sdwt_step","page":"SWT","title":"WaveletsExt.SWT.sdwt_step","text":"sdwt_step(v, d, h, g)\n\nPerform one level of the stationary discrete wavelet transform (SDWT) on the vector v, which is the d-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nArguments\n\nv::AbstractArray{T} where T<:Number: Array of coefficients from a node at level d.\nd::Integer: Depth level of v.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Output from low pass filter (1D case); or output from low + low pass filter (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Output from high pass filter (1D case); or output from low + high pass filter (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Output from high + low pass filter (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Output from high + high pass filter (2D case).\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of SDWT\nSWT.sdwt_step(v, 0, h, g)\n\nSee also: sdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.sdwt_step!","page":"SWT","title":"WaveletsExt.SWT.sdwt_step!","text":"sdwt_step!(w₁, w₂, v, d, h, g)\n\nSame as sdwt_step but without array allocation.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Vector allocation for output from low pass filter (1D case); or matrix allocation for output from low + low pass filter (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Vector allocation for output from high pass filter (1D case); or matrix allocation for output from low + high pass filter (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Matrix allocation for output from high + low pass filter (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Matrix allocation for output from high + high pass filter (2D case).\nv::AbstractArray{T} where T<:Number: Array of coefficients from a node at level d.\nd::Integer: Depth level of v.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Output from low pass filter (1D case); or output from low + low pass filter (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Output from high pass filter (1D case); or output from low + high pass filter (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Output from high + low pass filter (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Output from high + high pass filter (2D case).\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\nw₁ = zeros(8)\nw₂ = zeros(8)\n\n# One step of SDWT\nSWT.sdwt_step!(w₁, w₂, v, 0, h, g)\n\nSee also: sdwt_step\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwt_step","page":"SWT","title":"WaveletsExt.SWT.isdwt_step","text":"isdwt_step(w₁, w₂, d, h, g)\nisdwt_step(w₁, w₂, d, sv, sw, h, g)\n\nPerform one level of the inverse stationary discrete wavelet transform (ISDWT) on the vectors w₁ and w₂, which are the d+1-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nnote: Note\nOne can decide to choose the average-based inverse transform or the shift-based inverse transform. For shift based, one needs to specify the shifts of the parent and children nodes; for the average based, the output is the average of all possible shift-based inverse transform outputs.\n\nArguments\n\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Coefficients of left child node (1D case); or coefficients from top left child node (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Coefficients of right child node (1D case); or coefficients from top right child node (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Coefficients from bottom left child node (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Coefficients from bottom right child node (2D case).\nd::Integer: Depth level of parent node of w₁ and w₂.\nsv::Integer: Shift of parent node v.\nsw::Integer: Shift of children nodes w₁ and w₂.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nReturns\n\nv::Vector{T}: Reconstructed coefficients.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of SDWT\nw₁, w₂ = SWT.sdwt_step(v, 0, h, g)\n\n# One step of ISDWT\nv̂ = SWT.isdwt_step(w₁, w₂, 0, h, g)         # Average based\nṽ = SWT.isdwt_step(w₁, w₂, 0, 0, 1, h, g)   # Shift based\n\nSee also: isdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwt_step!","page":"SWT","title":"WaveletsExt.SWT.isdwt_step!","text":"isdwt_step!(v, w₁, w₂, d, h, g)\nisdwt_step!(v, w₁, w₂, d, sv, sw, h, g[; add2out])\n\nSame as isdwt_step but without array allocation.\n\nArguments\n\nv::AbstractArray{T} where T<:Number: Array allocation for reconstructed coefficients.\nw₁::AbstractVector{T} where T<:Number or w₁::AbstractMatrix{T} where T<:Number: Coefficients of left child node (1D case); or coefficients from top left child node (2D case).\nw₂::AbstractVector{T} where T<:Number or w₂::AbstractMatrix{T} where T<:Number: Coefficients of right child node (1D case); or coefficients from top right child node (2D case).\nw₃::AbstractVector{T} where T<:Number or w₃::AbstractMatrix{T} where T<:Number: Coefficients from bottom left child node (2D case).\nw₄::AbstractVector{T} where T<:Number or w₄::AbstractMatrix{T} where T<:Number: Coefficients from bottom right child node (2D case).\nd::Integer: Depth level of parent node of w₁ and w₂.\nsv::Integer: Shift of parent node v.\nsw::Integer: Shift of children nodes w₁ and w₂.\nh::Vector{S} where S<:Number: High pass filter.\ng::Vector{S} where S<:Number: Low pass filter.\n\nKeyword Arguments\n\nadd2out::Bool: (Default: false) Whether to add computed result directly to output v or rewrite computed result to v.\n\nReturns\n\nv::Array{T}: Reconstructed coefficients.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Setup\nv = randn(8)\nv̂ = similar(v)\nṽ = similar(v)\nwt = wavelet(WT.haar)\ng, h = WT.makereverseqmfpair(wt, true)\n\n# One step of SDWT\nw₁, w₂ = SWT.sdwt_step(v, 0, h, g)\n\n# One step of ISDWT\nSWT.isdwt_step!(v̂, w₁, w₂, 0, h, g)          # Average based\nSWT.isdwt_step!(ṽ, w₁, w₂, 0, 0, 1, h, g)    # Shift based\n\nSee also: isdwt_step\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/UCD4IDS/WaveletsExt.jl.git\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star UCD4IDS/WaveletsExt.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#WaveletsExt.jl","page":"Home","title":"WaveletsExt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a Julia extension package to Wavelets.jl (WaveletsExt is short for Wavelets Extension). It contains additional functionalities that complement Wavelets.jl, namely","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multi-dimensional wavelet transforms\nRedundant wavelet transforms\nAutocorrelation Wavelet Transforms (ACWT)\nStationary Wavelet Transforms (SWT)\nShift Invariant Wavelet Transforms (SIWT)\nBest basis algorithms\nJoint best basis (JBB)\nLeast statistically dependent basis (LSDB)\nDenoising methods\nRelative Error Shrink (RelErrorShrink)\nStein Unbiased Risk Estimator Shrink (SUREShrink)\nWavelet transform based feature extraction techniques\nLocal Discriminant Basis (LDB).","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is written and maintained by Zeng Fung Liew and Shozen Dan under the supervision of Professor Naoki Saito at the University of California, Davis.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is part of the official Julia Registry. It can be install via the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.6) pkg> add WaveletsExt","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"WaveletsExt\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load the WaveletsExt module along with Wavelets.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Wavelets, WaveletsExt","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Coifman, R.R., Wickerhauser, M.V. (1992). Entropy-based algorithms for best basis selection. DOI: 10.1109/18.119732","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Saito, N. (1998). The least statistically-dependent basis and its applications. DOI: 10.1109/ACSSC.1998.750958","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Beylkin, G., Saito, N. (1992). Wavelets, their autocorrelation functions, and multiresolution representations of signals. DOI: 10.1117/12.131585","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] Nason, G.P., Silverman, B.W. (1995) The Stationary Wavelet Transform and some Statistical Applications. DOI: 10.1007/978-1-4612-2544-7_17 ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] Donoho, D.L., Johnstone, I.M. (1995). Adapting to Unknown Smoothness via Wavelet Shrinkage. DOI: 10.1080/01621459.1995.10476626 ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6] Saito, N., Coifman, R.R. (1994). Local Discriminant Basis. DOI: 10.1117/12.188763","category":"page"},{"location":"","page":"Home","title":"Home","text":"[7] Saito, N., Coifman, R.R. (1995). Local discriminant basis and their applications. DOI: 10.1007/BF01250288","category":"page"},{"location":"","page":"Home","title":"Home","text":"[8] Saito, N., Marchand, B. (2012). Earth Mover's Distance-Based Local Discriminant Basis. DOI: 10.1007/978-1-4614-4145-8_12","category":"page"},{"location":"","page":"Home","title":"Home","text":"[9] Cohen, I., Raz, S., Malah, D. (1997). Orthonormal shift-invariant wavelet packet decomposition and representation. DOI: 10.1016/S0165-1684(97)00007-8","category":"page"},{"location":"","page":"Home","title":"Home","text":"[10] Irion, J., Saito, N. (2017). Efficient Approximation and Denoising of Graph Signals Using the Multiscale Basis Dictionaries. DOI: 10.1109/TSIPN.2016.2632039","category":"page"},{"location":"manual/bestbasis/#bestbasis_manual","page":"Best Basis","title":"Extracting the best bases from signals","text":"","category":"section"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"The Wavelets.jl's package contains a best basis algorithm (via bestbasistree) that search for the basis tree within a single signal x such that the Shannon's Entropy or the Log Energy Entropy of the basis of the signal is minimized, ie. min_b in B M_x(b), where  ","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"B is the collection of bases for the signal x,\nb is a basis for the signal x, and\nM_x() is the information cost (eg. Shannon's entropy or Log Energy entropy) for","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"the basis of signal x. ","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"However, the challenge arises when there is a need to work on a group of signals X and find a single best basis b that minimizes the information cost M_x for all x in X, ie. min_b in B sum_x in X M_x(b)","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"A brute force search is not ideal as its computational time grows exponentially to the number and size of the signals. Here, we have the two efficient algorithms for the estimation of an overall best basis:","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Joint Best Basis (JBB),\nLeast Statistically Dependent Basis (LSDB)","category":"page"},{"location":"manual/bestbasis/#Best-basis-representations","page":"Best Basis","title":"Best basis representations","text":"","category":"section"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"To represent a best basis tree in the most memory efficient way, Wavelets.jl uses Julia's BitVector data structure to represent a binary tree that corresponds to the bases of 1D signals. The indices of the BitVectors correspond to nodes of the trees as follows:","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Figure 1: Binary tree structure Figure 2: Binary tree indexing\n(Image: ) (Image: )","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"where L corresponds to a low pass filter and H corresponds to a high pass filter.","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Similarly, a quadtree, used to represent the basis of a 2D wavelet transform, uses a BitVector with the following indexing:","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Figure 3: Quadtree structure Figure 4: Quadtree indexing\n(Image: ) (Image: )","category":"page"},{"location":"manual/bestbasis/#Examples","page":"Best Basis","title":"Examples","text":"","category":"section"},{"location":"manual/bestbasis/#Best-Basis-of-each-signal","page":"Best Basis","title":"Best Basis of each signal","text":"","category":"section"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Assume we are given a large amount of signals to transform to its best basis, one may use the following approach.","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"using Wavelets, WaveletsExt, Plots\n\n# Generate 4 HeaviSine signals\nx = generatesignals(:heavisine, 7)\nX = duplicatesignals(x, 4, 2, true, 0.5)\n\n# Construct wavelet\nwt = wavelet(WT.haar)\n\n# Decomposition of all signals\nxw = wpdall(X, wt)\n\n# Best basis trees, each column corresponds to 1 tree\ntrees = bestbasistreeall(xw, BB()); \nnothing # hide","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"One can then view the selected nodes from the best basis trees using the plot_tfbdry function as shown below.","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"# Plot each tree\np1 = plot_tfbdry(trees[:,1])\nplot!(p1, title=\"Signal 1 best basis\")\np2 = plot_tfbdry(trees[:,2])\nplot!(p2, title=\"Signal 2 best basis\")\np3 = plot_tfbdry(trees[:,3])\nplot!(p3, title=\"Signal 3 best basis\")\np4 = plot_tfbdry(trees[:,4])\nplot!(p4, title=\"Signal 4 best basis\")\n\n# Draw all plots\nplot(p1, p2, p3, p4, layout=(2,2))","category":"page"},{"location":"manual/bestbasis/#Generalized-Best-Basis-Algorithm","page":"Best Basis","title":"Generalized Best Basis Algorithm","text":"","category":"section"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Similarly, we can also find the best basis of the signals using Joint Best Basis (JBB) and Least Statistically Dependent Basis (LSDB). Note that these algorithms return 1 basis tree that generalizes the best basis over the entire set of signals.","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"# JBB\ntree = bestbasistree(xw, JBB())\np5 = plot_tfbdry(tree)\n\n# LSDB\ntree = bestbasistree(xw, LSDB())\np6 = plot_tfbdry(tree)\n\n# Show results\nplot!(p5, title=\"JBB\")\nplot!(p6, title=\"LSDB\")\nplot(p5, p6, layout=(1,2))","category":"page"},{"location":"manual/bestbasis/#si_bestbasis","page":"Best Basis","title":"Best Basis of Shift-Invariant Wavelet Packet Decomposition","text":"","category":"section"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"One can think of searching for the best basis of the shift-invariant wavelet packet decomposition as a problem of finding min_b in B sum_x in X M_x(b), where X is all the possible shifted versions of an original signal y. One can compute the best basis tree as follows:","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"xw = siwpd(x, wt)\n\n# SIBB\ntree = bestbasistree(xw, 7, SIBB());\nnothing #hide","category":"page"},{"location":"manual/bestbasis/","page":"Best Basis","title":"Best Basis","text":"warning: Warning\nSIWPD is still undergoing large changes in terms of data structures and efficiency improvements. Syntax changes may occur in the next patch updates.","category":"page"}]
}
