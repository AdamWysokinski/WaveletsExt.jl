var documenterSearchIndex = {"docs":
[{"location":"api/siwpd/#Shift-Invariant-Wavelet-Packet-Decomposition","page":"SIWPD","title":"Shift Invariant Wavelet Packet Decomposition","text":"","category":"section"},{"location":"api/siwpd/","page":"SIWPD","title":"SIWPD","text":"Modules = [SIWPD]","category":"page"},{"location":"api/siwpd/","page":"SIWPD","title":"SIWPD","text":"Modules = [SIWPD]","category":"page"},{"location":"api/siwpd/#WaveletsExt.SIWPD.makesiwpdtree-Tuple{Integer, Integer, Integer}","page":"SIWPD","title":"WaveletsExt.SIWPD.makesiwpdtree","text":"makesiwpdtree(n, L, d)\n\nReturns the multi-level, multi-depth binary tree corresponding to the Shift- Invariant Wavelet Packet Decomposition. \n\n\n\n\n\n","category":"method"},{"location":"api/siwpd/#WaveletsExt.SIWPD.siwpd-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer, Integer}} where T<:Number","page":"SIWPD","title":"WaveletsExt.SIWPD.siwpd","text":"siwpd(x, wt[, L=maxtransformlevels(x), d=L])\n\nComputes the Shift-Invariant Wavelet Packet Decomposition originally developed by Cohen, Raz & Malah on the vector x using the discrete wavelet filter wt for L levels with depth d.\n\n\n\n\n\n","category":"method"},{"location":"manual/transforms/#transforms_manual","page":"Transforms","title":"Wavelet Transforms and Their Best Bases","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"As an extension to Wavelets.jl's wavelet packet transform and best basis functions wpt and bestbasistree, WaveletsExt goes one step further and brings a full decomposition function wpd and redundant transforms in the form of Stationary Wavelet Transform, Autocorrelation Wavelet Transform, and Shift-Invariant Wavelet Transform. Additionally, more advanced best basis algorithms for a group of signals such as the Joint Best Basis (JBB) and Least Statistically Dependent Basis (LSDB) are also included here.","category":"page"},{"location":"manual/transforms/#Regular-Wavelet-Packet-Transform","page":"Transforms","title":"Regular Wavelet Packet Transform","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The standard best basis algorithm on the wavelet packet transform from Wavelets.jl can be performed as follows:","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = generatesignals(:heavysine, 8)\nwt = wavelet(WT.db4)\n\n# best basis tree\ntree = bestbasistree(x, wt)\n\n# decomposition\ny = wpt(x, wt, tree); \nnothing # hide","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"However, in the case where there is a large amount of signals to transform to its best basis, one may find the following approach more convenient.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# generate 10 Heavy Sine signals\nX = duplicatesignals(x, 10, 2, true, 0.5)\n\n# decomposition of all signals\nxw = cat([wpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis trees, each column corresponds to 1 tree\ntrees = bestbasistree(xw, BB()); \nnothing # hide","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Additionally, one can view the selected nodes from the best basis trees using the plot_tfbdry function as shown below.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# plot_tfbdry(trees[:,1])","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"We can also view the JBB and LSDB trees using a similar syntax. Unlike the previous best basis algorithm, JBB and LSDB do not generate a tree for each individual signal, as they search for the best tree that generalizes the group of signal as a whole.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Joint Best Basis (JBB)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# joint best basis\ntree = bestbasistree(xw, JBB())\nnothing # hide\n# plot_tfbdry(tree)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Least Statistically Dependent Basis (LSDB)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# least statistically dependent basis\ntree = bestbasistree(xw, LSDB())\nnothing # hide\n# plot_tfbdry(tree)","category":"page"},{"location":"manual/transforms/#Stationary-and-Autocorrelation-Wavelet-Transforms","page":"Transforms","title":"Stationary and Autocorrelation Wavelet Transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The Stationary Wavelet Transform (SWT) was developed by G.P. Nason and B.W. Silverman in the 1990s. One can use the discrete SWT as shown below, or the SWT decomposition shown after.","category":"page"},{"location":"manual/transforms/#Example","page":"Transforms","title":"Example","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# discrete swt\ny = sdwt(x, wt)\n\n# view the transform\nnothing # hide\n# wiggle(y, sc=0.7)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The SWT decomposition and its best basis search is highly similar with that of the regular wavelet transforms.","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Regular best basis algorithm","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# decomposition of all signals\nxw = cat([swpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis trees, each column corresponds to 1 tree\ntrees = bestbasistree(xw, BB(redundant=true)); \nnothing # hide\n# plot_tfbdry(trees[:,1])","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Joint Best Basis (JBB)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# best basis trees, each column corresponds to 1 tree\ntree = bestbasistree(xw, JBB(redundant=true)); \nnothing # hide\n# plot_tfbdry(tree)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"Least Statistically Dependent Basis (LSDB)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# best basis trees, each column corresponds to 1 tree\ntree = bestbasistree(xw, LSDB(redundant=true)); \nnothing # hide\n# plot_tfbdry(tree)","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"In fact, this same exact procedures can be implemented with the Autocorrelation wavelet transforms, since they're both redundant types of transform. To implement the autocorrelation transforms, simply change sdwt to acwt, and swpd to acwpt.","category":"page"},{"location":"manual/transforms/#Shift-Invariant-Wavelet-Packet-Decomposition","page":"Transforms","title":"Shift-Invariant Wavelet Packet Decomposition","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"The Shift-Invariant Wavelet Decomposition (SIWPD) is developed by I. Cohen. While it is also a type of redundant transform, it does not follow the same methodology as the SWT and the ACWT. One can compute the SIWPD of a single signal as follows.","category":"page"},{"location":"manual/transforms/#Example-2","page":"Transforms","title":"Example","text":"","category":"section"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"# decomposition\nxw = siwpd(x, wt)\n\n# best basis tree\ntree = bestbasistree(xw, 8, SIBB());\nnothing # hide","category":"page"},{"location":"manual/transforms/","page":"Transforms","title":"Transforms","text":"As of right now, there is not too many functions written based on the SIWPD, as it does not follow the conventional style of wavelet transforms. There is a lot of ongoing work to develop more functions catered for the SIWPD such as it's inverse transforms and group-implementations.","category":"page"},{"location":"api/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/utils/#WaveletsExt.Utils.ClassData","page":"Utils","title":"WaveletsExt.Utils.ClassData","text":"ClassData(type, s₁, s₂, s₃)\n\nBased on the input type, generates 3 classes of signals with sample sizes s₁, s₂, and s₃ respectively. Accepted input types are:  \n\n:tri: Triangular signals of length 32\n:cbf: Cylinder-Bell-Funnel signals of length 128\n\nBased on N. Saito and R. Coifman in \"Local Discriminant Basis and their Applications\" in the Journal of Mathematical Imaging and Vision, Vol. 5, 337-358 (1995).\n\nSee also: generateclassdata\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#Wavelets.Util.maxtransformlevels-Tuple{AbstractArray, Integer}","page":"Utils","title":"Wavelets.Util.maxtransformlevels","text":"maxtransformlevels(n)\n\nmaxtransformlevels(x[, dims])\n\nExtension function from Wavelets.jl. Finds the max number of transform levels for an array x. If dims is provided for a multidimensional array, then it finds the max transform level for that corresponding dimension.\n\nArguments\n\nx::AbstractArray: Input array.\ndims::Integer: Dimension used for wavelet transform.\nn::Integer: Length of input vector.\n\nReturns\n\n::Integer: Max number of transform levels.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Define random signal\nx = randn(64, 128)\n\n# Max transform levels and their corresponding return values\nmaxtransformlevels(128)     # 7\nmaxtransformlevels(x)       # 6\nmaxtransformlevels(x, 2)    # 7\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.coarsestscalingrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.coarsestscalingrange","text":"coarsestscalingrange(x, tree[, redundant=false])\n\ncoarsestscalingrange(n, tree[, redundant=false])\n\nGiven a binary tree, returns the index range of the coarsest scaling  coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.duplicatesignals-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Integer}, Tuple{AbstractVector{T}, Integer, Integer, Bool}, Tuple{AbstractVector{T}, Integer, Integer, Bool, Real}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.duplicatesignals","text":"duplicatesignals(x, N, k[, noise=false, t=1])\n\nGiven a signal x, returns N shifted versions of the signal, each with shifts of multiples of k. \n\nSetting noise = true allows randomly generated Gaussian noises of μ = 0,  σ² = t to be added to the circularly shifted signals.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.finestdetailrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.finestdetailrange","text":"finestdetailrange(x, tree[, redundant=false])\n\nfinestdetailrange(n, tree[, redundant=false])\n\nGiven a binary tree, returns the index range of the coarsest scaling  coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.generateclassdata","page":"Utils","title":"WaveletsExt.Utils.generateclassdata","text":"generateclassdata(c[, shuffle=false])\n\nGenerates 3 classes of data given a ClassData struct as an input. Returns a matrix  containing the 3 classes of signals and a vector containing their corresponding labels.\n\nBased on N. Saito and R. Coifman in \"Local Discriminant Basis and their Applications\" in the Journal of Mathematical Imaging and Vision, Vol. 5, 337-358 (1995).\n\nSee also: ClassData\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#WaveletsExt.Utils.generatesignals-Tuple{Symbol, Integer}","page":"Utils","title":"WaveletsExt.Utils.generatesignals","text":"generatesignals(fn, L)\n\nGenerates a signal of length 2ᴸ given the function symbol fn. Current accepted inputs  below are based on D. Donoho and I. Johnstone in \"Adapting to Unknown Smoothness via Wavelet  Shrinkage\" Preprint Stanford, January 93, p 27-28.  \n\n:blocks\n:bumps\n:heavysine\n:doppler\n:quadchirp\n:mishmash\n\nThe code for this function is adapted and translated based on MATLAB's Wavelet Toolbox's  wnoise function.\n\nExamples\n\ngeneratesignals(:bumps, 8)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.getleaf-Tuple{BitVector}","page":"Utils","title":"WaveletsExt.Utils.getleaf","text":"getleaf(tree)\n\nReturns the leaf nodes of a tree.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.left-Tuple{Integer}","page":"Utils","title":"WaveletsExt.Utils.left","text":"left(i)\n\nGiven the node index i, returns the index of its left node.\n\nSee also: right\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.nodelength-Tuple{Integer, Integer}","page":"Utils","title":"WaveletsExt.Utils.nodelength","text":"nodelength(N, L)\n\nReturns the node length at level L of a signal of length N. Level L == 0  corresponds to the original input signal.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.psnr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.psnr","text":"psnr(x, x₀)\n\nReturns the peak signal to noise ratio (PSNR) between original signal x₀ and noisy signal x.\n\nSee also: relativenorm, snr, ssim\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.relativenorm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Real}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.relativenorm","text":"relativenorm(x, x₀[, p=2]) where T<:Number\n\nReturns the relative norm of base p between original signal x₀ and noisy signal x.\n\nSee also: psnr, snr, ssim\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.right-Tuple{Integer}","page":"Utils","title":"WaveletsExt.Utils.right","text":"right(i)\n\nGiven the node index i, returns the index of its right node.\n\nSee also: left\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.snr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.snr","text":"snr(x, x₀)\n\nReturns the signal to noise ratio (SNR) between original signal x₀ and noisy  signal x.\n\nSee also: relativenorm, psnr, ssim\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#WaveletsExt.Utils.ssim-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}} where T<:Number","page":"Utils","title":"WaveletsExt.Utils.ssim","text":"ssim(x, x₀)\n\nWrapper for assess_ssim function from ImageQualityIndex.jl.\n\nReturns the Structural Similarity Index Measure (SSIM) between the original  signal/image x₀ and noisy signal/image x.\n\nSee also: relativenorm, psnr, snr\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#Local-Discriminant-Basis","page":"LDB","title":"Local Discriminant Basis","text":"","category":"section"},{"location":"api/ldb/","page":"LDB","title":"LDB","text":"Modules = [LDB]","category":"page"},{"location":"api/ldb/","page":"LDB","title":"LDB","text":"Modules = [LDB]","category":"page"},{"location":"api/ldb/#WaveletsExt.LDB.AsymmetricRelativeEntropy","page":"LDB","title":"WaveletsExt.LDB.AsymmetricRelativeEntropy","text":"AsymmetricRelativeEntropy <: ProbabilityDensityDM\n\nAsymmetric Relative Entropy discriminant measure for the Probability Density and Time Frequency based energy maps. This measure is also known as cross entropy  and Kullback-Leibler divergence.\n\nEquation: D(pq) = sum p(x) log fracp(x)q(x)\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.BasisDiscriminantMeasure","page":"LDB","title":"WaveletsExt.LDB.BasisDiscriminantMeasure","text":"BasisDiscriminantMeasure <: DiscriminantPower\n\nThis is the discriminant measure of a single basis function computed in a  previous step to construct the energy maps.\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.DiscriminantMeasure","page":"LDB","title":"WaveletsExt.LDB.DiscriminantMeasure","text":"Discriminant measure for Local Discriminant Basis. Current available subtypes are:\n\nProbabilityDensityDM\nSignaturesDM\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.DiscriminantPower","page":"LDB","title":"WaveletsExt.LDB.DiscriminantPower","text":"Discriminant Power measure for the Local Discriminant Basis. Current available measures are\n\nBasisDiscriminantMeasure\nFishersClassSeparability\nRobustFishersClassSeparability\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.EarthMoverDistance","page":"LDB","title":"WaveletsExt.LDB.EarthMoverDistance","text":"EarthMoverDistance <: SignaturesDM\n\nEarth Mover Distance discriminant measure for the Signatures energy map.\n\nEquation:  E(PQ) = fracsum_k=1^m+n+1 hat p_k - hat q_k (r_k+1 - r_k)w_Sigma\n\nwhere r_1 r_2 ldots r_m+n is the sorted list of p_1 ldots p_m  q_1 ldots q_n and hat p_k = sum_p_i leq r_k w_p_i,  hat q_k = sum_q)i leq r_k w_q_i.\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.EnergyMap","page":"LDB","title":"WaveletsExt.LDB.EnergyMap","text":"Energy map for Local Discriminant Basis. Current available types are:\n\nTimeFrequency\nProbabilityDensity\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.FishersClassSeparability","page":"LDB","title":"WaveletsExt.LDB.FishersClassSeparability","text":"FishersClassSeparability <: DiscriminantPower\n\nThe Fisher's class separability of the expansion coefficients in the basis  function.\n\nEquation: fracsum_c=1^C pi_c(rm mean_i(alpha_lambdai^(c)) - rm mean_c(rm mean_i(alpha_lambdai^(c))))^2sum_c=1^C pi_c rm var_i(alpha_lambdai^(c))\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.HellingerDistance","page":"LDB","title":"WaveletsExt.LDB.HellingerDistance","text":"HellingerDistance <: ProbabilityDensityDM\n\nHellinger Distance discriminant measure for the Probability Density energy  map.\n\nEquation: H(pq) = sum_i=1^n (sqrtp_i - sqrtq_i)^2\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.LocalDiscriminantBasis","page":"LDB","title":"WaveletsExt.LDB.LocalDiscriminantBasis","text":"LocalDiscriminantBasis\n\nClass type for the Local Discriminant Basis (LDB), a feature selection algorithm developed by N. Saito and R. Coifman in \"Local Discriminant Bases and Their Applications\" in the Journal of Mathematical Imaging and Vision, Vol 5, 337-358 (1995). This struct contains the following field values: \n\nParameters and Attributes:\n\nwt::DiscreteWavelet: a discrete wavelet for transform purposes\nmax_dec_level::Union{Integer, Nothing}: max level of wavelet packet   decomposition to be computed.\ndm::DiscriminantMeasure: the discriminant measure for the LDB algorithm.    Supported measures are the AsymmetricRelativeEntropy(), LpDistance(),   SymmetricRelativeEntropy(), and HellingerDistance()\nen::EnergyMap: the type of energy map used. Supported maps are    TimeFrequency(), ProbabilityDensity(), and Signatures().\ndp::DiscriminantPower(): the measure of discriminant power among expansion   coefficients. Supported measures are BasisDiscriminantMeasure(),   FishersClassSeparability(), and RobustFishersClassSeparability(). \ntop_k::Union{Integer, Nothing}: the top-k coefficients used in each node to    determine the discriminant measure.\nn_features::Union{Integer, Nothing}: the dimension of output after    undergoing feature selection and transformation.\nn::Union{Integer, Nothing}: length of signal\n`Γ::Union{AbstractArray{<:AbstractFloat}, \n\nAbstractArray{NamedTuple{(:coef, :weight), Tuple{S1, S2}}} where {S1<:Array{T}      where T<:AbstractFloat, S2<:Union{AbstractFloat, Array{<:AbstractFloat}}},     Nothing}`: computed energy map\n\nDM::Union{AbstractArray{<:AbstractFloat}, Nothing}: computed discriminant   measure\ncost::Union{AbstractVector{<:AbstractFloat}, Nothing}: computed wavelet   packet decomposition (WPD) tree cost based on the discriminant measure DM.\ntree::Union{BitVector, Nothing}: computed best WPD tree based on the    discriminant measure DM.\nDP::Union{AbstractVector{<:AbstractFloat}, Nothing}: computed discriminant    power\norder::Union{AbstractVector{Integer}, Nothing}: ordering of DP by    descending order.\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.LocalDiscriminantBasis-Tuple{}","page":"LDB","title":"WaveletsExt.LDB.LocalDiscriminantBasis","text":"LocalDiscriminantBasis([; \n    wt=wavelet(WT.haar),\n    max_dec_level=nothing,\n    dm=AsymmetricRelativeEntropy(), em=TimeFrequency(), \n    dp=BasisDiscriminantMeasure(), top_k=nothing,\n    n_features=nothing]\n)\n\nClass constructor for LocalDiscriminantBasis. \n\nArguments:\n\nwt::DiscreteWavelet: Wavelet used for decomposition of signals. Default is   set to be wavelet(WT.haar).\nmax_dec_level::Union{Integer, Nothing}: max level of wavelet packet   decomposition to be computed. When max_dec_level=nothing, the maximum   transform levels will be used. Default is set to be nothing.\ndm::DiscriminantMeasure: the discriminant measure for the LDB algorithm.    Supported measures are the AsymmetricRelativeEntropy(), LpDistance(),    SymmetricRelativeEntropy(), and HellingerDistance(). Default is set to   be AsymmetricRelativeEntropy().\nen::EnergyMap: the type of energy map used. Supported maps are    TimeFrequency() and ProbabilityDensity(). Default is set to be    TimeFrequency().\ndp::DiscriminantPower=BasisDiscriminantMeasure(): the measure of    discriminant power among expansion coefficients. Supported measures are    BasisDiscriminantMeasure(), FishersClassSeparability(), and    RobustFishersClassSeparability(). Default is set to be BasisDiscriminantMeasure().\ntop_k::Union{Integer, Nothing}: the top-k coefficients used in each node to    determine the discriminant measure. When top_k=nothing, all coefficients    are used to determine the discriminant measure. Default is set to be    nothing.\nn_features::Union{Integer, Nothing}: the dimension of output after    undergoing feature selection and transformation. When n_features=nothing,   all features will be returned as output. Default is set to be nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.LpDistance","page":"LDB","title":"WaveletsExt.LDB.LpDistance","text":"LpDistance <: ProbabilityDensityDM\n\nell^p Distance discriminant measure for the Probability Density and Time  Frequency based energy maps. The default p value is set to 2.\n\nEquation: W(qr) = q-r_p^p = sum_i=1^n (q_i - r_i)^p\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.ProbabilityDensity","page":"LDB","title":"WaveletsExt.LDB.ProbabilityDensity","text":"ProbabilityDensity <: EnergyMap\n\nAn energy map based on probability density, a measure based on the differences  among the pdfs of Z_i. Since we do not know the true density functions of the coefficients, the PDFs are estimated using the Average Shifted Histogram (ASH).\n\nSee also: EnergyMap, TimeFrequency, Signatures\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.ProbabilityDensityDM","page":"LDB","title":"WaveletsExt.LDB.ProbabilityDensityDM","text":"Discriminant measure for Probability Density and Time Frequency based energy  maps. Current available measures are:\n\nAsymmetricRelativeEntropy\nSymmetricRelativeEntropy\nLpDistance\nHellingerDistance\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.RobustFishersClassSeparability","page":"LDB","title":"WaveletsExt.LDB.RobustFishersClassSeparability","text":"RobustFishersClassSeparability <: DiscriminantPower\n\nThe robust version of Fisher's class separability of the expansion coefficients  in the basis function.\n\nEquation: fracsum_c=1^C pi_c(rm med_i(alpha_lambdai^(c)) - rm med_c(rm med_i(alpha_lambdai^(c))))^2sum_c=1^C pi_c rm mad_i(alpha_lambdai^(c))\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.Signatures","page":"LDB","title":"WaveletsExt.LDB.Signatures","text":"Signatures <: EnergyMap\n\nAn energy map based on signatures, a measure that uses the Earth Mover's Distance (EMD) to compute the discriminating  power of a coordinate. Signatures provide us with a fully data-driven representation, which can be efficiently used with EMD. This representation is more efficient than a histogram and is able to represent complex data structure with fewer samples.\n\nHere, a signature for the coefficients in the j-th level, k-th node, l-th index of class c is defined as\n\ns_jkl^(c) = (alpha_ijkl^(c) w_ijkl^(c))_i=1^N_c\n\nwhere alpha_ijkl^(c) and w_ijkl^(c) are the expansion  coefficients and weights at location (jkl) for signal i of class c respectively. Currently, the two valid types of weights are :equal and :pdf.\n\nArgumemts\n\nweight::Symbol: Type of weight to be used to compute w_ijkl^(c).   Available methods are :equal and pdf. Default is set to :equal.\n\nSee also: EnergyMap, TimeFrequency,     ProbabilityDensity\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.SignaturesDM","page":"LDB","title":"WaveletsExt.LDB.SignaturesDM","text":"Discriminant measure for Signatures based energy maps. Current available measures are:\n\nEarthMoverDistance\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.SymmetricRelativeEntropy","page":"LDB","title":"WaveletsExt.LDB.SymmetricRelativeEntropy","text":"SymmetricRelativeEntropy <: ProbabilityDensityDM\n\nSymmetric Relative Entropy discriminant measure for the Probability Density and  Time Frequency energy maps. Similar idea to the Asymmetric Relative Entropy, but  this aims to make the measure more symmetric.\n\nEquation: Denote the Asymmetric Relative Entropy as D_A(pq), then\n\nD(pq) = D_A(pq) + D_A(qp) = sum p(x) log fracp(x)q(x) + q(x) log fracq(x)p(x)\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.TimeFrequency","page":"LDB","title":"WaveletsExt.LDB.TimeFrequency","text":"TimeFrequency <: EnergyMap\n\nAn energy map based on time frequencies, a measure based on the differences of  derived quantities from projection Z_i, such as mean class energies or  cumulants.\n\nSee also: EnergyMap, ProbabilityDensity,     Signatures\n\n\n\n\n\n","category":"type"},{"location":"api/ldb/#WaveletsExt.LDB.change_nfeatures-Union{Tuple{T}, Tuple{LocalDiscriminantBasis, AbstractMatrix{T}, Integer}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.change_nfeatures","text":"change_nfeatures(f, x, n_features)\n\nChange the number of features from f.n_features to n_features. \n\nNote that if the input n_features is larger than f.n_features, it results in the regeneration of signals based on the current f.n_features before  reselecting the features. This will cause additional features to be less  accurate and effective.\n\nSee also: LocalDiscriminantBasis, fit!, fit_transform,     transform, inverse_transform\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.discriminant_measure-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, ProbabilityDensityDM}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.discriminant_measure","text":"discriminant_measure(Γ, dm)\n\nReturns the discriminant measure of each node calculated from the energy maps.\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.discriminant_power-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector, BasisDiscriminantMeasure}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.discriminant_power","text":"discriminant_power(D, tree, dp)\n\nReturns the discriminant power of each leaf from the local discriminant basis (LDB) tree. \n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.energy_map-Union{Tuple{T}, Tuple{S}, Tuple{AbstractArray{S, 3}, AbstractVector{T}, TimeFrequency}} where {S<:Number, T}","page":"LDB","title":"WaveletsExt.LDB.energy_map","text":"energy_map(Xw, y, method)\n\nReturns the Time Frequency Energy map or the Probability Density Energy map depending on the input method (TimeFrequency() or ProbabilityDensity()).\n\nSee also: EnergyMap. TimeFrequency,      ProbabilityDensity\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.fit!-Union{Tuple{T}, Tuple{S}, Tuple{LocalDiscriminantBasis, AbstractMatrix{S}, AbstractVector{T}}} where {S<:Number, T}","page":"LDB","title":"WaveletsExt.LDB.fit!","text":"fit!(f, X, y)\n\nFits the Local Discriminant Basis feature selection algorithm f onto the  signals X (or the decomposed signals Xw) with labels y.\n\nSee also: LocalDiscriminantBasis, fit_transform,     transform, inverse_transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.fit_transform-Union{Tuple{T}, Tuple{S}, Tuple{LocalDiscriminantBasis, AbstractMatrix{S}, AbstractVector{T}}} where {S<:Number, T}","page":"LDB","title":"WaveletsExt.LDB.fit_transform","text":"fit_transform(f, X, y)\n\nFit and transform the signals X with labels y based on the LDB class f.\n\nSee also: LocalDiscriminantBasis, fit!,     transform, inverse_transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.inverse_transform-Union{Tuple{T}, Tuple{LocalDiscriminantBasis, AbstractMatrix{T}}} where T<:Number","page":"LDB","title":"WaveletsExt.LDB.inverse_transform","text":"inverse_transform(f, x)\n\nCompute the inverse transform on the feature matrix x to form the original signal based on the LDB class f.\n\nSee also: LocalDiscriminantBasis, fit!,     fit_transform, transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/ldb/#WaveletsExt.LDB.transform-Union{Tuple{T}, Tuple{LocalDiscriminantBasis, AbstractMatrix{T}}} where T","page":"LDB","title":"WaveletsExt.LDB.transform","text":"transform(f, X)\n\nExtract the LDB features on signals X.\n\nSee also: LocalDiscriminantBasis, fit!,      fit_transform, inverse_transform, change_nfeatures\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#Autocorrelation-Wavelet-Transform","page":"ACWT","title":"Autocorrelation Wavelet Transform","text":"","category":"section"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"Modules = [ACWT]","category":"page"},{"location":"api/acwt/","page":"ACWT","title":"ACWT","text":"Modules = [ACWT]","category":"page"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpt","page":"ACWT","title":"WaveletsExt.ACWT.acwpt","text":"acwpt(x, wt[, L=maxtransformlevels(x)])\n\nPerforms a discrete autocorrelation wavelet packet transform for a given signal x. The wavelet type wt determines the transform type. Refer to Wavelet.jl for a list of available methods.\n\nExamples\n\nacwpt(x, wavelet(WT.db4))\n\nacwpt(x, wavelet(WT.db4), 4)\n\nSee also: acwt, acwpt_step, iacwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwpt_step","page":"ACWT","title":"WaveletsExt.ACWT.acwpt_step","text":"acwpt_step(W, i, d, Qmf, Pmf)\n\nPerforms one level of the autocorrelation discrete wavelet packet transform  (ACWPT) on the i-th node at depth d in the array W. The vectors Qmf and  Pmf are the detail and scaling filters.\n\nSee also: acwpt, iacwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwt","page":"ACWT","title":"WaveletsExt.ACWT.acwt","text":"acwt(x, wt[, L=maxtransformlevels(x)])\n\nacwt(x, wt[, Lrow=maxtransformlevels(x[1,:]), Lcol=maxtransformlevels(x[:,1])])\n\nPerforms a discrete autocorrelation wavelet transform for a given signal x. The signal can be 1D or 2D. The wavelet type wt determines the transform type. Refer to Wavelet.jl for a list of available methods.\n\nExamples\n\nacwt(x, wavelet(WT.db4))\n\nacwt(x, wavelet(WT.db4), 4) # level 4 decomposition\n\nSee also: acwt_step, iacwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.acwt_step","page":"ACWT","title":"WaveletsExt.ACWT.acwt_step","text":"acwt_step(v, j, h, g)\n\nPerforms one level of the autocorrelation discrete wavelet transform (ACWT) on the  vector v, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nReturns a tuple (v, w) of the scaling and detail coefficients at level j+1.\n\nSee also: acwt, iacwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.autocorr-Tuple{Wavelets.WT.OrthoFilter}","page":"ACWT","title":"WaveletsExt.ACWT.autocorr","text":"autocorr(f::OrthoFilter)\n\nGenerates the autocorrelation filter for a given wavelet filter.\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#WaveletsExt.ACWT.hacwt-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Wavelets.WT.OrthoFilter}, Tuple{AbstractMatrix{T}, Wavelets.WT.OrthoFilter, Integer}} where T<:Number","page":"ACWT","title":"WaveletsExt.ACWT.hacwt","text":"hacwt(x, wt[, L=maxtransformlevels(x,2)])\n\nComputes the column-wise discrete autocorrelation transform coeficients for 2D signals.\n\nSee also: vacwt\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwpt","page":"ACWT","title":"WaveletsExt.ACWT.iacwpt","text":"iacwpt(xw, tree, i)\n\nPerforms the inverse autocorrelation discrete wavelet packet transform, with respect to a decomposition tree.\n\nSee also: acwpt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwt","page":"ACWT","title":"WaveletsExt.ACWT.iacwt","text":"iacwt(xw::AbstractArray{<:Number,2})\n\niacwt(xw::AbstractArray{<:Number,4})\n\nPerforms the inverse autocorrelation discrete wavelet transform.  Can be used for both the 1D and 2D case.\n\nSee also: iacwt!, acwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.iacwt!","page":"ACWT","title":"WaveletsExt.ACWT.iacwt!","text":"iacwt!(xw::AbstractArray{<:Number,2})\n\nSame as iacwt but performs the inverse autocorrelation discrete wavelet transform in place.\n\nSee also: iacwt, acwt\n\n\n\n\n\n","category":"function"},{"location":"api/acwt/#WaveletsExt.ACWT.make_acqmfpair-Tuple{Wavelets.WT.OrthoFilter}","page":"ACWT","title":"WaveletsExt.ACWT.make_acqmfpair","text":"make_acqmfpair(f::OrthoFilter)\n\nGenerates the autocorrelation quadratic mirror filters.\n\nSee also: make_acreverseqmfpair\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#WaveletsExt.ACWT.make_acreverseqmfpair-Tuple{Wavelets.WT.OrthoFilter}","page":"ACWT","title":"WaveletsExt.ACWT.make_acreverseqmfpair","text":"make_acreverseqmfpair(f::OrthoFilter)\n\nGenerates the reverse autocorrelation quadratic mirror filters.\n\nSee also: make_acqmfpair\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#WaveletsExt.ACWT.pfilter-Tuple{Wavelets.WT.OrthoFilter}","page":"ACWT","title":"WaveletsExt.ACWT.pfilter","text":"pfilter(f::OrthoFilter)\n\nGenerates the high-pass autocorrelation filter\n\nSee also: qfilter\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#WaveletsExt.ACWT.qfilter-Tuple{Wavelets.WT.OrthoFilter}","page":"ACWT","title":"WaveletsExt.ACWT.qfilter","text":"qfilter(f::OrthoFilter)\n\nGenerates the low-pass autocorrelation filter.\n\nSee also: pfilter\n\n\n\n\n\n","category":"method"},{"location":"api/acwt/#WaveletsExt.ACWT.vacwt-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Wavelets.WT.OrthoFilter}, Tuple{AbstractMatrix{T}, Wavelets.WT.OrthoFilter, Integer}} where T<:Number","page":"ACWT","title":"WaveletsExt.ACWT.vacwt","text":"vacwt(x, wt[, L=maxtransformlevels(x)])\n\nComputes the row-wise discrete autocorrelation transform coeficients for 2D signals.\n\nSee also: hacwt\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"api/visualizations/","page":"Visualizations","title":"Visualizations","text":"Modules = [Visualizations]","category":"page"},{"location":"api/visualizations/","page":"Visualizations","title":"Visualizations","text":"Modules = [Visualizations]","category":"page"},{"location":"api/visualizations/#WaveletsExt.Visualizations.plot_tfbdry-Tuple{BitVector}","page":"Visualizations","title":"WaveletsExt.Visualizations.plot_tfbdry","text":"plot_tfbdry(tree[; start, nodecolor])\n\nGiven a tree, output a visual representation of the leaf nodes, user will have the option to start the node count of each level with 0 or 1.\n\nArguments\n\ntree::BitVector: Tree for plotting the leaf nodes. Comes in the form of a BitVector.\nstart::Integer: (Default: 0) Whether to zero-index or one-index the root of the tree.\nnodecolor::Symbol: (Default: :white) Color of the leaf nodes.\n\nReturns\n\n::Plots.Plot: Plot object with the visual representation of the leaf nodes.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Build a tree using Wavelets `maketree`\ntree = maketree(128, 7, :dwt)\n\n# Plot the leaf nodes\nplot_tfbdry(tree)\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#WaveletsExt.Visualizations.treenodes_matrix-Tuple{BitVector}","page":"Visualizations","title":"WaveletsExt.Visualizations.treenodes_matrix","text":"treenodes_matrix(x)\n\nGiven a BitVector of nodes in a binary tree, output the matrix representation  of the nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#WaveletsExt.Visualizations.wiggle!-Tuple","page":"Visualizations","title":"WaveletsExt.Visualizations.wiggle!","text":"wiggle!(wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\n\nPlot a set of shaded wiggles on the current displayed graphics. If there are no displayed graphics currently available, a new Plots.Plot object is generated to plot the shaded wiggles.\n\nArguments\n\nwav::AbstractArray{<:Number,2}: Matrix of waveform columns.\ntaxis::AbstractVector: (Default: 1:size(wav,1)) Time axis vector\nzaxis::AbstractVector: (Default: 1:size(wav,2)) Space axis vector\nsc::Real: (Default: 1) Scale factor/magnification.\nEdgeColor::Symbol: (Default: :black) Sets edge of wiggles color.\nFaceColor::Symbol: (Default: :black) Sets shading color of wiggles.\nOverlap::Bool: (Default: true) How signals are scaled.\ntrue  - Signals overlap (default);\nfalse - Signals are scaled so they do not overlap.\nOrient::Symbol: (Default: :across) Controls orientation of wiggles.\n:across - from left to right\n:down   - from top to down\nZDir::Symbol: (Default: :normal) Direction of space axis.\n:normal  - First signal at bottom (default)\n:reverse - First signal at top.\n\nReturns\n\n::Plots.Plot: Shaded wiggles on top of current plot object.\n\nExamples\n\nusing Plots, WaveletsExt\n\n# Generate random signals\nx = randn(16, 5)\n\n# Build wiggles on `plt`\nplt = plot()\nwiggle!(x)\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito. The previous MATLAB version contributors are Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC).  \n\nRevised by Naoki Saito, Feb. 05, 2018. Maintained by Zeng Fung Liew for newest Julia version compatibility. \n\nSee also: wiggle\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#WaveletsExt.Visualizations.wiggle!-Union{Tuple{T}, Tuple{Plots.Plot, AbstractMatrix{T}}} where T<:Number","page":"Visualizations","title":"WaveletsExt.Visualizations.wiggle!","text":"wiggle!(plt, wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\n\nPlot a set of shaded wiggles onto plt.\n\nArguments\n\nplt::Plots.Plot: Input plot to plot shaded wiggles.\nwav::AbstractArray{<:Number,2}: Matrix of waveform columns.\ntaxis::AbstractVector: (Default: 1:size(wav,1)) Time axis vector\nzaxis::AbstractVector: (Default: 1:size(wav,2)) Space axis vector\nsc::Real: (Default: 1) Scale factor/magnification.\nEdgeColor::Symbol: (Default: :black) Sets edge of wiggles color.\nFaceColor::Symbol: (Default: :black) Sets shading color of wiggles.\nOverlap::Bool: (Default: true) How signals are scaled.\ntrue  - Signals overlap (default);\nfalse - Signals are scaled so they do not overlap.\nOrient::Symbol: (Default: :across) Controls orientation of wiggles.\n:across - from left to right\n:down   - from top to down\nZDir::Symbol: (Default: :normal) Direction of space axis.\n:normal  - First signal at bottom (default)\n:reverse - First signal at top.\n\nReturns\n\nplt::Plots.Plot: Same plot object with shaded wiggles.\n\nExamples\n\nusing Plots, WaveletsExt\n\n# Generate random signals\nx = randn(16, 5)\n\n# Build wiggles on `plt`\nplt = plot()\nwiggle!(plt, x)\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito. The previous MATLAB version contributors are Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC).  \n\nRevised by Naoki Saito, Feb. 05, 2018. Maintained by Zeng Fung Liew for newest Julia version compatibility. \n\nSee also: wiggle\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#WaveletsExt.Visualizations.wiggle-Tuple","page":"Visualizations","title":"WaveletsExt.Visualizations.wiggle","text":"wiggle(wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\n\nPlots a set of shaded wiggles.\n\nArguments\n\nwav::AbstractArray{<:Number,2}: Matrix of waveform columns.\ntaxis::AbstractVector: (Default: 1:size(wav,1)) Time axis vector\nzaxis::AbstractVector: (Default: 1:size(wav,2)) Space axis vector\nsc::Real: (Default: 1) Scale factor/magnification.\nEdgeColor::Symbol: (Default: :black) Sets edge of wiggles color.\nFaceColor::Symbol: (Default: :black) Sets shading color of wiggles.\nOverlap::Bool: (Default: true) How signals are scaled.\ntrue  - Signals overlap (default);\nfalse - Signals are scaled so they do not overlap.\nOrient::Symbol: (Default: :across) Controls orientation of wiggles.\n:across - from left to right\n:down   - from top to down\nZDir::Symbol: (Default: :normal) Direction of space axis.\n:normal  - First signal at bottom (default)\n:reverse - First signal at top.\n\nReturns\n\n::Plots.Plot: Shaded wiggles on top of current plot object.\n\nExamples\n\nusing Plots, WaveletsExt\n\n# Generate random signals\nx = randn(16, 5)\n\n# Build wiggles\nwiggle(x)\n\nTranslated by Nicholas Hausch -- MATLAB file provided by Naoki Saito. The previous MATLAB\nversion contributors are Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC).  \n\nRevised by Naoki Saito, Feb. 05, 2018. Maintained by Zeng Fung Liew for newest Julia version\ncompatibility. \n\n**See also:** [`wiggle!`](@ref)\n\n\n\n\n\n","category":"method"},{"location":"api/visualizations/#WaveletsExt.Visualizations.wiggle-Tuple{Plots.Plot, Vararg{Any, N} where N}","page":"Visualizations","title":"WaveletsExt.Visualizations.wiggle","text":"wiggle(plt, wav[; taxis, zaxis, sc, EdgeColor, FaceColor, Orient, Overlap, ZDir])\n\nPlots a set of shaded wiggles on top of the existing plot plt and return the output in a newly generated plot object.\n\nArguments\n\nplt::Plots.Plot: Input plot to plot shaded wiggles.\nwav::AbstractArray{<:Number,2}: Matrix of waveform columns.\ntaxis::AbstractVector: (Default: 1:size(wav,1)) Time axis vector\nzaxis::AbstractVector: (Default: 1:size(wav,2)) Space axis vector\nsc::Real: (Default: 1) Scale factor/magnification.\nEdgeColor::Symbol: (Default: :black) Sets edge of wiggles color.\nFaceColor::Symbol: (Default: :black) Sets shading color of wiggles.\nOverlap::Bool: (Default: true) How signals are scaled.\ntrue  - Signals overlap (default);\nfalse - Signals are scaled so they do not overlap.\nOrient::Symbol: (Default: :across) Controls orientation of wiggles.\n:across - from left to right\n:down   - from top to down\nZDir::Symbol: (Default: :normal) Direction of space axis.\n:normal  - First signal at bottom (default)\n:reverse - First signal at top.\n\nReturns\n\n::Plots.Plot: Same plot object with shaded wiggles.\n\nExamples\n\nusing Plots, WaveletsExt\n\n# Generate random signals\nx = randn(16, 5)\n\n# Build wiggles on top of `plt`\nplt = plot()\nplt_new = wiggle(plt, x)    # plt remains the way it is\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito. The previous MATLAB version contributors are Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC).\n\nRevised by Naoki Saito, Feb. 05, 2018. Maintained by Zeng Fung Liew for newest Julia version compatibility. \n\nSee also: wiggle!\n\n\n\n\n\n","category":"method"},{"location":"manual/denoising/#denoising_manual","page":"Denoising","title":"Signal Denoising","text":"","category":"section"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"Wavelet denoising is an important step in signal analysis as it helps remove unnecessary high frequency noise while maintaining the most important features of the signal. Intuitively, signal denoising comes in the following simple steps:","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"Decompose a signal or a group of signals. One can choose to decompose signals into its best basis tree for more optimal results.\nFind a suitable threshold value. There are many ways to do so, with VisuShrink method by D. Donoho and I. Johnstone being one of the most popular approaches. The VisuShrink implementation in Wavelets.jl, along with the RelErrorShrink and the SureShrink implementations in WaveletsExt.jl give users more threshold selection options.\nThreshold the wavelet coefficients. There are various thresholding methods implemented in Wavelets.jl for this purpose, with Hard and Soft thresholding being the usual go-to method due to its simplistic approach.\nReconstruct the original signals using the thresholded coefficients.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"For more information and examples on wavelet denoising using WaveletsExt.jl, visit Wavelets Denoising Experiment repository under UCD4IDS for a step-by-step tutorial in a Pluto notebook. The following is a simple guide on denoisng using WaveletsExt.jl.","category":"page"},{"location":"manual/denoising/#Denoising-a-single-signal","page":"Denoising","title":"Denoising a single signal","text":"","category":"section"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"To denoise a single signal, one can use the denoise function from WaveletsExt.jl as shown below. Note the following key parameters:","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"x: Input signal.\ninputtype: Type of input. One can input an original signal :sig, or first transform the signal and type in one of :dwt, :wpt, :sdwt, :swpd, :acwt, and :acwpt.\nwt: Transform wavelet.\nL: Number of decomposition levels. Necessary for input types :sig, :dwt, and :sdwt.\ntree: Decomposition tree of the signals. Necessary for input types :wpt and :swpd.\ndnt: Denoise type. One should input either of VisuShrink, RelErrorShrink, or SureShrink.\nestnoise: Noise estimation. Can be a function or a value.\nsmooth: Smoothing method used.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"For more detailed information, visit the denoising API page.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"using Wavelets, WaveletsExt, Random, Plots\n\n# define function and wavelet\nx₀ = generatesignals(:heavysine, 8)\nx = x₀ + 0.8*randn(256)\nwt = wavelet(WT.db4)\n\n# best basis tree\nbt = bestbasistree(wpd(x, wt), BB())\ny = bestbasiscoef(x, wt, bt)\n\n# denoise\nx̂ = denoise(y, :wpt, wt, tree=bt)\n\n# plot results\nnothing # hide\n# plot([x₀ x x̂], title=\"Denoising Example\", label=[\"original\" \"noisy\" \"denoised\"],\n#      lw=[3 1 2], lc=[:black :grey :red])","category":"page"},{"location":"manual/denoising/#Denoising-a-group-of-signals","page":"Denoising","title":"Denoising a group of signals","text":"","category":"section"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"Similar to the denoise function we saw previously, for denoising a group of signals, one can use the denoiseall function. The parameters used are the same, with the following addition:","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"bestTH: Method to determine the best threshold value for a group of signals. One can choose each signal's individual best threshold value, or use a function such as mean or median to generalize an overall best threshold value.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"For more detailed information, visit the denoising API page.","category":"page"},{"location":"manual/denoising/","page":"Denoising","title":"Denoising","text":"using Wavelets, WaveletsExt, Random, Plots\n\n# define function and wavelet\nx = generatesignals(:heavysine, 8)\nX₀ = duplicatesignals(x, 6, 2, false)\nX = duplicatesignals(x, 6, 2, true, 0.8)\nwt = wavelet(WT.db4)\n\n# decomposition\ncoef = cat([wpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis tree\nbt = bestbasistree(coef, JBB())\nY = bestbasiscoef(coef, bt)\n\n# denoise\nX̂ = denoiseall(Y, :wpt, wt, tree=bt)\n\n# plot results\nnothing # hide\n# wiggle(X₀, sc=0.7, FaceColor=:white, ZDir=:reverse)\n# wiggle!(X, sc=0.7, EdgeColor=:grey, FaceColor=:white, ZDir=:reverse)\n# wiggle!(X̂, sc=0.7, EdgeColor=:red, FaceColor=:white, ZDir=:reverse)\n# plot!(title=\"Group Denoising Example\")","category":"page"},{"location":"manual/localdiscriminantbasis/#ldb_manual","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"","category":"section"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Local Discriminant Basis is a feature extraction technique developed by N. Saito and R. Coifman in 1995. This algorithm follows the following basic steps:","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Decompose a set of multi-class signals using wavelet packet decomposition. A wavelet packet decomposition decomposes a signal into multiple nodes which resembles a binary tree.\nBased on the decomposed wavelet coefficients, build an energy map based on time-frequency or probability density.\nUsing the energy map, compute the discriminant measure and select a basis tree that best discriminates the different classes of signals.\nBased on the selected basis tree, extract the corresponding wavelet coefficients for each signal.\nCompute the discriminant power of each coefficient index. Select the top k set of coefficients to be used as features to be passed onto a classifier such as Linear Discriminant Analysis (LDA) and Classification and Regression Trees (CART).","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"A more in-depth tutorial can be found in the Pluto notebook here. For more information on LDB, please refer to the original paper \"Local Discriminant Basis and their Applications\" by Saito and Coifman here.","category":"page"},{"location":"manual/localdiscriminantbasis/#Example","page":"Local Discriminant Basis","title":"Example","text":"","category":"section"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"We first generate a multi-class dataset. WaveletsExt.jl has 2 built-in multi-class signals dataset, namely the triangular signals (:tri) and the cylinder-bell-funnel signals (:cbf).","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"using Wavelets, WaveletsExt, Plots\n\n# generates 100 signals for each class of cylinder-bell-funnel\nX, y = generateclassdata(ClassData(:cbf, 100, 100, 100));\n\n# view sample signals and how each class differs from one another\nnothing # hide\n# cylinder = wiggle(X[:,1:5], sc=0.3)\n# plot!(cylinder, title=\"Cylinder signals\")\n# bell = wiggle(X[:,101:105], sc=0.3)\n# plot!(bell, title=\"Bell signals\")\n# funnel = wiggle(X[:,201:205], sc=0.3)\n# plot!(funnel, title=\"Funnel signals\")\n# plot(cylinder, bell, funnel, layout=(3,1))","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Next, we define the parameters for our Local Discriminant Basis object. Here are a few key parameters to note:","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"wt: Type of wavelet used. Default is wavelet(WT.haar).\nmax_dec_level: Maximum decomposition level. Default is to decompose each signal all the way to its maximum possible depth.\ndm: Type of discriminant measure. Available choices are:\nAsymmetricRelativeEntropy() (default)\nSymmetricRelativeEntropy()\nLpEntropy()\nHellingerDistance()\nen: Type of energy map. Available choices are:\nTimeFrequency() (default)\nProbabilityDensity()\ndp: Type of discriminant power. Available choices are:\nBasisDiscriminantMeasure() (default)\nFishersClassSeparability()\nRobustFishersClassSeparability()\ntop_k: Max number of coefficients used in each node for the computation of discriminant power. The default setting uses all available coefficients for the computation.\nn_features: Number of features to be returned. All features/coefficients will be returned by default.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"wt = wavelet(WT.coif4);\nldb = LocalDiscriminantBasis(\n    wt=wt, \n    max_dec_level=7,\n    dm=SymmetricRelativeEntropy(), \n    en=TimeFrequency(),\n    dp=BasisDiscriminantMeasure(),\n    top_k=10,\n    n_features=10\n);\n\n# transform and extract the features using LDB\nX̂ = fit_transform(ldb, X, y);\nnothing # hide","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"After fitting our data, we will then also be able to conduct our own analysis. We can observe where the best basis is selected from using the plot_tfbdry function.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"# plot_tfbdry(ldb.tree)","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Another thing we can do is observe the heatmap produced by the discriminant measure (ldb.DM).","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"# heatmap(1:ldb.n, 0:ldb.max_dec_level, ldb.DM);\n# plot!(title=\"Discriminant Measure Heatmap\")","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"To decide how many features we should select, we can use the elbow rule on the discriminant powers (ldb.DP). From the plot below, we can see that approximately 6 features should be chosen for the classification step.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"# plot(ldb.DP[ldb.order], labels=\"discriminant power\");\n# plot!(title=\"Plot of LDB Discriminant Power\")","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Knowing the 6 features we want to select, we can go one step further and examine the basis vectors generated by the coefficients of these 6 indices by defining the function below. In the illustration purpose of this tutorial, the basis vectors generated by the coefficients of the top 10 features are plotted below.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"function get_basisvectors(n::Integer, wt::DiscreteWavelet, tree::BitVector,\n        idx::Vector{<:Integer})\n\n    k = length(idx)\n    y = Array{Float64,2}(undef, (n,k))\n    for (i,j) in enumerate(idx)\n        x = zeros(n)\n        x[j] = 1\n        y[:,i] = iwpt(x, wt, tree)\n    end\n    return y\nend\n\nbases = get_basisvectors(128, ldb.wt, ldb.tree, ldb.order[1:10]);\nnothing # hide\n# wiggle(bases, sc=0.3, ZDir=:reverse);\n# plot!(title=\"Top 10 LDB vectors\")","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"Since we have decided that 6 features are optimum for classification purposes, we can use the change_nfeatures function as below.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"X̂ = change_nfeatures(ldb, X̂, 6);\nnothing # hide","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"If we are curious, we can use the inverse_transform function to observe how the signals look like if they're generated from these 6 features.","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"X̃  = inverse_transform(ldb, X̂);\n\n# view sample signals and how each class differs from one another\nnothing # hide\n# cylinder = wiggle(X̃[:,1:5], sc=0.3)\n# plot!(cylinder, title=\"Cylinder signals\")\n# bell = wiggle(X̃[:,101:105], sc=0.3)\n# plot!(bell, title=\"Bell signals\")\n# funnel = wiggle(X̃[:,201:205], sc=0.3)\n# plot!(funnel, title=\"Funnel signals\")\n# plot(cylinder, bell, funnel, layout=(3,1))","category":"page"},{"location":"manual/localdiscriminantbasis/","page":"Local Discriminant Basis","title":"Local Discriminant Basis","text":"With that said, we are essentially done with the LDB step, and we can move on to the model fitting step using packages such as MLJ.jl and MultivariateStats.jl.","category":"page"},{"location":"api/bestbasis/#Best-Basis","page":"Best Basis","title":"Best Basis","text":"","category":"section"},{"location":"api/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Modules = [BestBasis]","category":"page"},{"location":"api/bestbasis/","page":"Best Basis","title":"Best Basis","text":"Modules = [BestBasis]","category":"page"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.BB","page":"Best Basis","title":"WaveletsExt.BestBasis.BB","text":"BB([; cost=LoglpCost(2), redundant=false])\n\nBest Basis (BB). Set redundant=true when running BB with redundant wavelet  transforms such as SWT or ACWT.\n\nSee also: BestBasisType, LSDB, JBB,      SIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.BBCost","page":"Best Basis","title":"WaveletsExt.BestBasis.BBCost","text":"BBCost <: CostFunction\n\nCost function abstract type specifically for BB.\n\nSee also: CostFunction, LSDBCost, JBBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.BestBasisType","page":"Best Basis","title":"WaveletsExt.BestBasis.BestBasisType","text":"Abstract type for best basis. Current available types are:\n\nLSDB\nJBB\nBB\nSIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.CostFunction","page":"Best Basis","title":"WaveletsExt.BestBasis.CostFunction","text":"Cost function abstract type.\n\nSee also: LSDBCost, JBBCost, BBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.DifferentialEntropyCost","page":"Best Basis","title":"WaveletsExt.BestBasis.DifferentialEntropyCost","text":"DifferentialEntropyCost <: LSDBCost\n\nDifferential entropy cost used for LSDB.\n\nSee also: CostFunction, LSDBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.JBB","page":"Best Basis","title":"WaveletsExt.BestBasis.JBB","text":"JBB([; cost=LoglpCost(2), redundant=false])\n\nJoint Best Basis (JBB). Set redundant=true when running JBB with redundant  wavelet transforms such as SWT or ACWT.\n\nSee also: BestBasisType, LSDB, BB,      SIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.JBBCost","page":"Best Basis","title":"WaveletsExt.BestBasis.JBBCost","text":"JBBCost <: CostFunction\n\nCost function abstract type specifically for JBB.\n\nSee also: CostFunction, LSDBCost, BBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LSDB","page":"Best Basis","title":"WaveletsExt.BestBasis.LSDB","text":"LSDB([; cost=DifferentialEntropyCost(), redundant=false])\n\nLeast Statistically Dependent Basis (LSDB). Set redundant=true when running LSDB with redundant wavelet transforms such as SWT or ACWT.\n\nSee also: BestBasisType, JBB, BB,      SIBB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LSDBCost","page":"Best Basis","title":"WaveletsExt.BestBasis.LSDBCost","text":"LSDBCost <: CostFunction\n\nCost function abstract type specifically for LSDB.\n\nSee also: CostFunction, JBBCost, BBCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LogEnergyEntropyCost","page":"Best Basis","title":"WaveletsExt.BestBasis.LogEnergyEntropyCost","text":"LogEnergyEntropyCost <: LSDBCost\n\nLog energy entropy cost used for BB.\n\nSee also: CostFunction, BBCost,      ShannonEntropyCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.LoglpCost","page":"Best Basis","title":"WaveletsExt.BestBasis.LoglpCost","text":"LoglpCost <: JBBCost\n\nlog ell^p information cost used for JBB. Typically, we set p=2 as in  Wickerhauser's original algorithm.\n\nSee also: CostFunction, JBBCost, NormCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.NormCost","page":"Best Basis","title":"WaveletsExt.BestBasis.NormCost","text":"NormCost <: JBBCost\n\np-norm information cost used for JBB.\n\nSee also: CostFunction, JBBCost, LoglpCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.SIBB","page":"Best Basis","title":"WaveletsExt.BestBasis.SIBB","text":"SIBB([; cost=ShannonEntropyCost()])\n\nShift Invariant Best Basis (SIBB).\n\nSee also: BestBasisType, LSDB, JBB,      BB\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.ShannonEntropyCost","page":"Best Basis","title":"WaveletsExt.BestBasis.ShannonEntropyCost","text":"ShannonEntropyCost <: LSDBCost\n\nShannon entropy cost used for BB.\n\nSee also: CostFunction, BBCost,      LogEnergyEntropyCost\n\n\n\n\n\n","category":"type"},{"location":"api/bestbasis/#Wavelets.Threshold.bestbasistree-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T<:AbstractFloat","page":"Best Basis","title":"Wavelets.Threshold.bestbasistree","text":"bestbasistree(X[, method])\n\nExtension to the best basis tree function from Wavelets.jl. Given a set of  decomposed signals, returns different types of best basis trees based on the  methods specified. Available methods are the joint best basis (JBB),  least statistically dependent basis (LSDB), individual regular  best basis (BB), and shift-invariant best basis (SIBB).\n\nExamples\n\nbestbasistree(X, JBB())\n\nbestbasistree(X, SIBB())\n\nSee also: bestbasiscoef\n\n\n\n\n\n","category":"method"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.bestbasis_treeselection-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}, Tuple{AbstractVector{T}, Integer, Symbol}} where T<:AbstractFloat","page":"Best Basis","title":"WaveletsExt.BestBasis.bestbasis_treeselection","text":"bestbasis_treeselection(costs, n[, type=:min])\n\nComputes the best tree based on the given cost vector.\n\nSee also: bestbasistree, tree_costs\n\n\n\n\n\n","category":"method"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.bestbasiscoef-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector}} where T<:AbstractFloat","page":"Best Basis","title":"WaveletsExt.BestBasis.bestbasiscoef","text":"bestbasiscoef(X, tree)\n\nbestbasiscoef(X, wt, tree)\n\nReturns the expansion coefficients based on the given tree(s) and wavelet packet decomposition (WPD) expansion coefficients. If the WPD expansion coefficients  were not provided, the expansion coefficients can be obtained by providing the signals and wavelet.\n\nSee also: bestbasistree, bestbasis_treeselection\n\n\n\n\n\n","category":"method"},{"location":"api/bestbasis/#WaveletsExt.BestBasis.tree_costs-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T<:AbstractFloat","page":"Best Basis","title":"WaveletsExt.BestBasis.tree_costs","text":"tree_costs(X, method)\n\nReturns the cost of each node in a binary tree in order to find the best basis.\n\nSee also: bestbasistree, bestbasis_treeselection\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#denoising_api","page":"Denoising","title":"Denoising","text":"","category":"section"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Modules = [Denoising]","category":"page"},{"location":"api/denoising/","page":"Denoising","title":"Denoising","text":"Modules = [Denoising]","category":"page"},{"location":"api/denoising/#Wavelets.Threshold.VisuShrink-Tuple{Integer, Wavelets.Threshold.THType}","page":"Denoising","title":"Wavelets.Threshold.VisuShrink","text":"VisuShrink(n, th)\n\nExtension to the VisuShrink struct constructor from Wavelets.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#WaveletsExt.Denoising.RelErrorShrink","page":"Denoising","title":"WaveletsExt.Denoising.RelErrorShrink","text":"RelErroShrink(th, t) <: DNFT\n\nRelative Error Shrink method used in their paper \"Efficient Approximation and  Denoising of Graph Signals using the Multiscale Basis Dictionary\" for IEEE  Transactions on Signal and Information Processing over Networks, Vol 0, No. 0, \n\n\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#WaveletsExt.Denoising.RelErrorShrink-2","page":"Denoising","title":"WaveletsExt.Denoising.RelErrorShrink","text":"RelErrorShrink([th=HardTH()])\n\nStruct constructor for Relative Error Shrink.\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#WaveletsExt.Denoising.SureShrink","page":"Denoising","title":"WaveletsExt.Denoising.SureShrink","text":"SureShrink(th, t) <: DNFT\n\nStein's Unbiased Risk Estimate (SURE) Shrink\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#WaveletsExt.Denoising.SureShrink-2","page":"Denoising","title":"WaveletsExt.Denoising.SureShrink","text":"SureShrink(x[, tree=nothing, th=SteinTH()])\n\nStruct constructor for SureShrink based on the signal coefficients x.\n\nSee also: surethreshold\n\n\n\n\n\n","category":"type"},{"location":"api/denoising/#Wavelets.Threshold.denoise-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T<:Number, S<:Wavelets.Threshold.DNFT}","page":"Denoising","title":"Wavelets.Threshold.denoise","text":"denoise(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),\n    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),\n    estnoise=noisest, smooth=:regular])\n\nExtension of the denoise function from Wavelets.jl. Denoise a signal of  input type inputtype.\n\nArguments:\n\nx::AbstractArray{<:Number}: input signals/coefficients.\ninputtype::Symbol: input type of x. Current accepted types of inputs are\n:sig: original signals; x should be a 2-D array with each column    representing a signal.\n:dwt: dwt-transformed signal coefficients; x should be a 1-D array    with each column representing the coefficients of a signal.\n:wpt: wpt-transformed signal coefficients; x should be a 1-D array    with each column representing the coefficients of a signal.\n:sdwt: sdwt-transformed signal coefficients; x should be a 2-D array   with each column representing the coefficients of a node.\n:swpd: swpd-transformed signal coefficients; x should be a 2-D array   with each column representing the coefficients of a node.\n:acwt: acwt-transformed signal coefficients from    AutocorrelationShell.jl; x should be a 2-D array with each column    representing the coefficients of a node.\n:acwpt: acwpt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 2-D array with each column    representing the coefficients of a node.\nwt::Union{DiscreteWavelet, Nothing}: the discrete wavelet to be used for   decomposition (for input type :sig) and reconstruction. nothing can    be supplied if no reconstruction is necessary.\nL::Integer: the number of decomposition levels. Necessary for input types   :sig, :dwt, and :sdwt. Default value is set to be    maxtransformlevels(size(x,1)).\ntree::BitVector: the decomposition tree of the signals. Necessary for input   types :wpt and :swpd. Default value is set to be    maketree(size(x,1), L, :dwt).\ndnt::DNFT: denoise type. Default type is set to be VisuShrink(size(x,1)).\nestnoise::Union{Function, Vector{<:Number}}: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the noisest function.\nsmooth::Symbol: the smoothing method used. :regular smoothing thresholds   all given coefficients, whereas :undersmooth smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be :regular.\n\nSee also: denoiseall, noisest,      relerrorthreshold\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#Wavelets.Threshold.noisest-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T<:Number","page":"Denoising","title":"Wavelets.Threshold.noisest","text":"noisest(x, redundant[, tree=nothing])\n\nExtension to the noisest function from Wavelets.jl. Estimates the noise of a signal from its coefficients.\n\nExamples\n\nx = randn(128)\nwt = wavelet(WT.haar)\n\n# noise estimate for dwt transformation\ny = dwt(x, wt)\nnoise = noisest(y, false)\n\n# noise estimate for wpt transformation\ntree = maketree(x, :full)\ny = wpt(x, wt, tree)\nnoise = noisest(y, false, tree)\n\n# noise estimate for sdwt transformation\ny = sdwt(x, wt)\nnoise = noisest(y, true)\n\n# noise estimate for swpd transformation\ny = swpd(x, wt)\nnoise = noisest(y, true, tree)\n\nSee also: relerrorthreshold, VisuShrink,      SureShrink\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#WaveletsExt.Denoising.denoiseall-Union{Tuple{S}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T1<:Number, T2<:Number, S<:Wavelets.Threshold.DNFT}","page":"Denoising","title":"WaveletsExt.Denoising.denoiseall","text":"denoiseall(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),\n    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),\n    estnoise=noisest, bestTH=nothing, smooth=:regular])\n\nDenoise multiple signals of input type inputtype. \n\nArguments:\n\nx::AbstractArray{<:Number}: input signals/coefficients.\ninputtype::Symbol: input type of x. Current accepted types of inputs are\n:sig: original signals; x should be a 2-D array with each column    representing a signal.\n:dwt: dwt-transformed signal coefficients; x should be a 2-D array    with each column representing the coefficients of a signal.\n:wpt: wpt-transformed signal coefficients; x should be a 2-D array    with each column representing the coefficients of a signal.\n:sdwt: sdwt-transformed signal coefficients; x should be a 3-D array   with each 2-D slice representing the coefficients of a signal.\n:swpd: swpd-transformed signal coefficients; x should be a 3-D array   with each 2-D slice representing the coefficients of a signal.\n:acwt: acwt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 3-D array with each 2-D slice    representing the coefficients of a signal.\n:acwpt: acwpt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 3-D array with each 2-D slice    representing the coefficients of a signal.\nwt::Union{DiscreteWavelet, Nothing}: the discrete wavelet to be used for   decomposition (for input type :sig) and reconstruction. nothing can    be supplied if no reconstruction is necessary.\nL::Integer: the number of decomposition levels. Necessary for input types   :sig, :dwt, and :sdwt. Default value is set to be    maxtransformlevels(size(x,1)).\ntree::BitVector: the decomposition tree of the signals. Necessary for input   types :wpt and :swpd. Default value is set to be    maketree(size(x,1), L, :dwt).\ndnt::DNFT: denoise type. Default type is set to be VisuShrink(size(x,1)).\nestnoise::Union{Function, Vector{<:Number}}: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the noisest function.\nbestTH::Union{Function, Nothing}: method to determine the best threshold    value for a group of signals. If nothing is given, then each signal will   be denoised by its respective best threshold value determined from the    parameters dnt and estnoise; otherwise some function can be passed   to determine the best threshold value from a vector of threshold values, eg:   mean and median. Default is set to be nothing.\nsmooth::Symbol: the smoothing method used. :regular smoothing thresholds   all given coefficients, whereas :undersmooth smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be :regular.\n\nSee alse: denoise, noisest, relerrorthreshold\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#WaveletsExt.Denoising.findelbow-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"Denoising","title":"WaveletsExt.Denoising.findelbow","text":"findelbow(x, y)\n\nGiven the x and y coordinates of a curve, return the elbow.\n\nSee also: RelErrorShrink, relerrorthreshold,     orth2relerror\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#WaveletsExt.Denoising.orth2relerror-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Number","page":"Denoising","title":"WaveletsExt.Denoising.orth2relerror","text":"orth2relerror(orth)\n\nGiven a vector 'orth' of orthonormal expansion coefficients, return a  vector of relative approximation errors when retaining the 1,2,...,N  largest coefficients in magnitude.\n\nSee also: RelErrorShrink, relerrorthreshold,      findelbow\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#WaveletsExt.Denoising.relerrorthreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}, Integer}} where T<:Number","page":"Denoising","title":"WaveletsExt.Denoising.relerrorthreshold","text":"relerrorthreshold(coef, redundant[, tree, elbows=2; makeplot=false])\n\nTakes in a set of expansion coefficients, 'plot' the threshold vs relative error  curve and select the best threshold value based on the elbow method. If one  wants to see the resulting plot from this computation, simply set  makeplot=true.\n\nExamples\n\nx = randn(128)\nwt = wavelet(WT.haar)\n\n# noise estimate for dwt transformation\ny = dwt(x, wt)\nnoise = relerrorthreshold(y, false)\n\n# noise estimate for wpt transformation\ntree = maketree(x, :full)\ny = wpt(x, wt, tree)\nnoise = relerrorthreshold(y, false, tree)\n\n# noise estimate for sdwt transformation\ny = sdwt(x, wt)\nnoise = relerrorthreshold(y, true)\n\n# noise estimate for swpd transformation\ny = swpd(x, wt)\nnoise = relerrorthreshold(y, true, tree)\n\nSee also: noisest, RelErrorShrink\n\n\n\n\n\n","category":"method"},{"location":"api/denoising/#WaveletsExt.Denoising.surethreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T<:Number","page":"Denoising","title":"WaveletsExt.Denoising.surethreshold","text":"surethreshold(coef, redundant[, tree=nothing])\n\nDetermination of the t value used for SureShrink.\n\nSee also: SureShrink\n\n\n\n\n\n","category":"method"},{"location":"api/swt/#Stationary-Wavelet-Transform","page":"SWT","title":"Stationary Wavelet Transform","text":"","category":"section"},{"location":"api/swt/","page":"SWT","title":"SWT","text":"Modules = [SWT]","category":"page"},{"location":"api/swt/","page":"SWT","title":"SWT","text":"Modules = [SWT]","category":"page"},{"location":"api/swt/#WaveletsExt.SWT.isdwt","page":"SWT","title":"WaveletsExt.SWT.isdwt","text":"isdwt(xw, wt[, ε])\n\nPerforms the inverse stationary discrete wavelet transform (ISDWT) on the sdwt transform coefficients with respect to the Boolean Vector ε which represents  the shifts to be used. If ε is not provided, the average-basis ISDWT will be  computed instead.\n\nExamples\n\n# decompose signal\nxw = sdwt(x, wt, 5)\n\n# ε-based reconstruction\ny = isdwt(xw, wt, BitVector([0,1,0,0,0]))\n\n# average-based reconstruction\ny = isdwt(xw, wt)\n\nSee also: iswpt, sdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwt_step","page":"SWT","title":"WaveletsExt.SWT.isdwt_step","text":"isdwt_step(v1, w1, j, s0, s1, g, h)\n\nPerform one level of the inverse stationary discrete wavelet transform (ISDWT)  on the vector v1 and w1, which is the j-th level scaling coefficients (Note  the 0th level scaling coefficients is the raw signal). The vectors h and g  are the detail and scaling filters.\n\nReturns a vector v0 of the scaling and detail coefficients at level j-1.\n\nSee also: isdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.isdwt_step!","page":"SWT","title":"WaveletsExt.SWT.isdwt_step!","text":"isdwt_step!(v0, v1, w1, j, s0, s1, g, h)\n\nSame as isdwt_step but without array allocation.\n\nSee also: isdwt_step\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.iswpt","page":"SWT","title":"WaveletsExt.SWT.iswpt","text":"iswpt(xw, wt, ε[, L=maxtransformlevels(size(xw,1))])\n\niswpt(xw, wt, ε, tree)\n\niswpt(xw, wt[, L=maxtransformlevels(size(xw,1))])\n\niswpt(xw, wt, tree)\n\nPerforms the inverse stationary wavelet packet transform (ISWPT) on the swpd transform coefficients with respect to a given Boolean Vector that represents a binary tree and the BitVector ε which represents the shifts to be used. If ε is not provided, the average-basis ISWPT will be computed instead.\n\nExamples\n\n# decompose signal\nxw = swpd(x, wt, 5)\n\n# best basis tree\nbt = bestbasistree(xw, BB(redundant=true))\n\n# ε-based reconstruction\ny = iswpt(xw, wt, BitVector([0,0,0,1,0]), 5)\ny = iswpt(xw, wt, BitVector([0,0,0,1,0]), bt)\n\n# average-based reconstruction\ny = iswpt(xw, wt, 5)\ny = iswpt(xw, wt, bt)\n\nSee also: isdwt, swpd\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.sdwt","page":"SWT","title":"WaveletsExt.SWT.sdwt","text":"sdwt(x, wt[, L=maxtransformlevels(x)])\n\nPerform a stationary discrete wavelet transform (SDWT) of the array x. The wavelet type wt determines the transform type and the wavelet class, see  wavelet. \n\nThe number of transform levels L can be 1 ≤ L ≤ maxtransformlevels(x). Default value is set to maxtransformlevels(x).\n\nReturns the n × (L+1) matrix (where n is the length of x) with the detail coefficients for level j in column (L-j+2). The scaling coefficients are in the 1st column.\n\nExamples\n\nxw = sdwt(x, wt, 5)\n\nSee also: swpd, swpt, isdwt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.sdwt_step","page":"SWT","title":"WaveletsExt.SWT.sdwt_step","text":"sdwt_step(v, j, h, g)\n\nPerform one level of the stationary discrete wavelet transform (SDWT) on the  vector v, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nReturns a tuple (v, w) of the scaling and detail coefficients at level j+1.\n\nSee also: sdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.sdwt_step!","page":"SWT","title":"WaveletsExt.SWT.sdwt_step!","text":"sdwt_step!(v1, w1, v, j, h, g)\n\nSame as sdwt_step but without array allocation.\n\nSee also: sdwt_step\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpd","page":"SWT","title":"WaveletsExt.SWT.swpd","text":"swpd(x, wt[, L=maxtransformlevels(x)])\n\nPerform a stationary wavelet packet decomposition (SPWD) of the array x. The  wavelet type wt determines the transform type and the wavelet class, see  wavelet.\n\nThe number of transform levels L can be 1 ≤ L ≤ maxtransformlevels(x). Default value is set to maxtransformlevels(x).\n\nReturns the n × (2⁽ᴸ⁺¹⁾-1) matrix (where n is the length of x) with each  column representing the nodes in the binary tree.\n\nExamples\n\nxw = swpd(x, wt, 5)\n\nSee also: swpt, sdwt, iswpt\n\n\n\n\n\n","category":"function"},{"location":"api/swt/#WaveletsExt.SWT.swpt","page":"SWT","title":"WaveletsExt.SWT.swpt","text":"swpt(x, wt[, L=maxtransformlevels(x)])\n\nswpt(x, wt, tree)\n\nswpt(x, h, g, tree)\n\nswpt(x, h, g, tree, i)\n\nPerforms the stationary wavelet packet transform (SWPT) of the vector x of  length N = 2ᴸ. The wavelet type wt determines the transform type and the  wavelet class, see wavelet.\n\nThe number of transform levels L can be 1 ≤ L ≤ maxtransformlevels(x). Default value is set to maxtransformlevels(x).\n\nReturns the expansion coefficients of the SWPT of the size N × k. Each column  represents a leaf node from tree. Number of returned columns can vary between  1 ≤ k ≤ N depending on the input tree.\n\nNote: If one wants to compute the stationary wavelet packet transform on a  signal, yet hopes to reconstruct the original signal later on, please use the  swpd function instead.\n\nSee also: sdwt, swpd\n\n\n\n\n\n","category":"function"},{"location":"api/wpd/#Wavelet-Packet-Decomposition","page":"WPD","title":"Wavelet Packet Decomposition","text":"","category":"section"},{"location":"api/wpd/","page":"WPD","title":"WPD","text":"Modules = [WPD]","category":"page"},{"location":"api/wpd/","page":"WPD","title":"WPD","text":"Modules = [WPD]","category":"page"},{"location":"api/wpd/#WaveletsExt.WPD.dwtall-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{Any, N} where N}} where T<:Number","page":"WPD","title":"WaveletsExt.WPD.dwtall","text":"dwtall(x, wt[, L])\n\nComputes the discrete wavelet transform (DWT) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input x.\n\nNote: dwt is currently available for 1-D, 2-D, and 3-D signals only. \n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet transforms. \n\nReturns\n\n::Array{T}: Slices of transformed signals. Signals are sliced the same way as the input signal x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# DWT on all signals in x\nxw = dwtall(x, wt)\n\n\n\n\n\n","category":"method"},{"location":"api/wpd/#WaveletsExt.WPD.wpd","page":"WPD","title":"WaveletsExt.WPD.wpd","text":"wpd(x, wt[, L=maxtransformlevels(x)])\n\nwpd(x, wt, hqf, gqf[, L=maxtransformlevels(x)])\n\nReturns the wavelet packet decomposition WPD) for L levels for input signal(s)  x.\n\nSee also: wpd!\n\n\n\n\n\n","category":"function"},{"location":"api/wpd/#WaveletsExt.WPD.wpd!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet, Integer}} where T<:Number","page":"WPD","title":"WaveletsExt.WPD.wpd!","text":"wpd!(y, x, wt[, L=maxtransformlevels(x)])\n\nwpd!(y, x, wt, hqf, gqf[, L=maxtransformlevels(x)])\n\nSame as wpd but without array allocation.\n\nSee also: wpd\n\n\n\n\n\n","category":"method"},{"location":"api/wpd/#WaveletsExt.WPD.wpdall-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{Any, N} where N}} where T<:Number","page":"WPD","title":"WaveletsExt.WPD.wpdall","text":"wpdall(x, wt[, L])\n\nwpdall(y, x, wt, hqf, gqf[, L])\n\nComputes the wavelet packet decomposition (WPD) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input x.\n\nNote: wpd is currently available for 1-D signals only.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet decomposition. \n\nReturns\n\n::Array{T}\n\n\n\n\n\n","category":"method"},{"location":"api/wpd/#WaveletsExt.WPD.wptall-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Vararg{Any, N} where N}} where T<:Number","page":"WPD","title":"WaveletsExt.WPD.wptall","text":"wptall(x, wt)\n\nwptall(x, wt, L)\n\nwptall(x, wt, tree)\n\nComputes the wavelet packet transform (WPT) on each slice of signal. Signals are sliced on the n-th dimension for an n-dimensional input x.\n\nNote: wpt is currently available for 1-D signals only.\n\nArguments\n\nx::AbstractArray{T} where T<:Number: Input signals, where each slice corresponds to one signal. For a set of input signals x of dimension n, signals are sliced on the n-th dimension.\nwt::OrthoFilter: Wavelet used.\nL::Integer: (Default: Wavelets.maxtransformlevels(xᵢ)) Number of levels of wavelet decomposition. \ntree::BitVector: (Default: Wavelets.maketree(xᵢ, :full)) Tree to follow for wavelet decomposition. \n\nReturns\n\n::Array{T}: Slices of transformed signals. Signals are sliced the same way as the input signal x.\n\nExamples\n\nusing Wavelets, WaveletsExt\n\n# Generate random signals\nx = randn(32, 5)\n# Create wavelet\nwt = wavelet(WT.db4)\n\n# WPT on all signals in x\nxw = wptall(x, wt)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/UCD4IDS/WaveletsExt.jl.git\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star UCD4IDS/WaveletsExt.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#WaveletsExt.jl","page":"Home","title":"WaveletsExt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a Julia extension package to Wavelets.jl (WaveletsExt is short for Wavelets Extension). It contains additional functionalities that complement Wavelets.jl, which include multiple best basis algorithms, denoising methods, Local Discriminant Basis (LDB), Stationary Wavelet Transform, and the Shift Invariant Wavelet Decomposition.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is written and maintained by Zeng Fung Liew and Shozen Dan under the supervision of Professor Naoki Saito at the University of California, Davis.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is part of the official Julia Registry. It can be install via the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.6) pkg> add WaveletsExt","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"WaveletsExt\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load the WaveletsExt module along with Wavelets.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Wavelets, WaveletsExt","category":"page"},{"location":"#Wavelet-Packet-Decomposition","page":"Home","title":"Wavelet Packet Decomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In contrast to Wavelets.jl's wpt function, wpd outputs expansion coefficients of all levels of a given signal. Each column represents a level in the decomposition tree.","category":"page"},{"location":"","page":"Home","title":"Home","text":"y = wpd(x, wavelet(WT.db4))","category":"page"},{"location":"#Stationary-Wavelet-Transform","page":"Home","title":"Stationary Wavelet Transform","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The redundant and non-orthogonal transform by Nason-Silverman can be implemented using either sdwt (for stationary discrete wavelet transform) or swpd (for stationary wavelet packet decomposition). Similarly, the reconstruction of signals can be computed using isdwt and iswpt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# stationary discrete wavelet transform\ny = sdwt(x, wavelet(WT.db4))\nz = isdwt(y, wavelet(WT.db4))\n\n# stationary wavelet packet decomposition\ny = swpd(x, wavelet(WT.db4))\nz = iswpt(y, wavelet(WT.db4))","category":"page"},{"location":"#Best-Basis","page":"Home","title":"Best Basis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In addition to the best basis algorithm by M.V. Wickerhauser implemented in Wavelets.jl, WaveletsExt.jl contains the implementation of the Joint Best Basis (JBB) by Wickerhauser an the Least Statistically-Dependent Basis (LSDB) by N. Saito.","category":"page"},{"location":"","page":"Home","title":"Home","text":"y = cat([wpd(x[:,i], wt) for i in N]..., dims=3)    # x has size (2^L, N)\n\n# individual best basis trees\nbbt = bestbasistree(y, BB())\n# joint best basis\nbbt = bestbasistree(y, JBB())\n# least statistically dependent basis\nbbt = bestbasistree(y, LSDB())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given a BitVector representing a best basis tree, one can obtain the corresponding expansion coefficients using bestbasiscoef.","category":"page"},{"location":"","page":"Home","title":"Home","text":"coef = bestbasiscoef(y, bbt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on the different wavelet transforms and best basis algorithms, please refer to its manual.","category":"page"},{"location":"#Signal-Denoising","page":"Home","title":"Signal Denoising","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WaveletsExt.jl includes additional signal denoising and thresholding methods that complement those written in Wavelets.jl. One can denoise a signal as using the denoise Wavelets.jl extension function as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x̂ = denoise(y, :wpt, wt, tree=bt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, for cases where there are multiple signals to be denoised, one can use the denoiseall function as below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"X̂ = denoiseall(Y, :wpt, wt, tree=bt)","category":"page"},{"location":"#Local-Discriminant-Basis","page":"Home","title":"Local Discriminant Basis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Local Discriminant Basis (LDB) is a feature extraction method developed by N. Saito and R. Coifman and can be accessed as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# generate data\nX, y = generateclassdata(ClassData(:tri, 5, 5, 5))\nwt = wavelet(WT.haar)\n\n# LDB\nf = LocalDiscriminantBasis(wt, top_k=5, n_features=5)\nXt = fit_transform(f, X, y)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on how to use LDB, please refer to its manual.","category":"page"}]
}
