var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [ACWT, BestBasis, Denoising, LDB, SIWPD, SWT, Utils, Visualizations, WPD]\nOrder = [:module, :function, :type]","category":"page"},{"location":"api/#WaveletsExt.ACWT.acwpt","page":"API","title":"WaveletsExt.ACWT.acwpt","text":"acwpt(x, wt[, L=maxtransformlevels(x)])\n\nPerforms a discrete autocorrelation wavelet packet transform for a given signal x. The wavelet type wt determines the transform type. Refer to Wavelet.jl for a list of available methods.\n\nExamples\n\nacwpt(x, wavelet(WT.db4))\n\nacwpt(x, wavelet(WT.db4), 4)\n\nSee also: acwt, acwpt_step, iacwpt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.ACWT.acwt","page":"API","title":"WaveletsExt.ACWT.acwt","text":"acwt(x, wt[, L=maxtransformlevels(x)])\n\nacwt(x, wt[, Lrow=maxtransformlevels(x[1,:]), Lcol=maxtransformlevels(x[:,1])])\n\nPerforms a discrete autocorrelation wavelet transform for a given signal x. The signal can be 1D or 2D. The wavelet type wt determines the transform type. Refer to Wavelet.jl for a list of available methods.\n\nExamples\n\nacwt(x, wavelet(WT.db4))\n\nacwt(x, wavelet(WT.db4), 4) # level 4 decomposition\n\nSee also: acwt_step, iacwt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.ACWT.acwt_step","page":"API","title":"WaveletsExt.ACWT.acwt_step","text":"acwt_step(v, j, h, g)\n\nPerforms one level of the autocorrelation discrete wavelet transform (ACWT) on the  vector v, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nReturns a tuple (v, w) of the scaling and detail coefficients at level j+1.\n\nSee also: acwt, iacwt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.ACWT.autocorr-Tuple{Wavelets.WT.OrthoFilter}","page":"API","title":"WaveletsExt.ACWT.autocorr","text":"autocorr(f::OrthoFilter)\n\nGenerates the autocorrelation filter for a given wavelet filter.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.ACWT.hacwt","page":"API","title":"WaveletsExt.ACWT.hacwt","text":"hacwt(x, wt[, L=maxtransformlevels(x)])\n\nComputes the column-wise discrete autocorrelation transform coeficients for 2D signals.\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.ACWT.iacwt","page":"API","title":"WaveletsExt.ACWT.iacwt","text":"iacwt(xw::AbstractArray{<:Number,2})\n\niacwt(xw::AbstractArray{<:Number,4})\n\nPerforms the inverse autocorrelation discrete wavelet transform.  Can be used for both the 1D and 2D case.\n\nSee also: iacwt!, acwt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.ACWT.make_acqmfpair-Tuple{Wavelets.WT.OrthoFilter}","page":"API","title":"WaveletsExt.ACWT.make_acqmfpair","text":"acmakeqmfpair(f::OrthoFilter)\n\nGenerates the autocorrelation quadratic mirror filters.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.ACWT.make_acreverseqmfpair-Tuple{Wavelets.WT.OrthoFilter}","page":"API","title":"WaveletsExt.ACWT.make_acreverseqmfpair","text":"makereverseqmfpair(f::OrthoFilter)\n\nGenerates the reverse autocorrelation quadratic mirror filters.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.ACWT.pfilter-Tuple{Wavelets.WT.OrthoFilter}","page":"API","title":"WaveletsExt.ACWT.pfilter","text":"pfilter(f::OrthoFilter)\n\nGenerates the high-pass autocorrelation filter \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.ACWT.qfilter-Tuple{Wavelets.WT.OrthoFilter}","page":"API","title":"WaveletsExt.ACWT.qfilter","text":"qfilter(f::OrthoFilter)\n\nGenerates the low-pass autocorrelation filter\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.ACWT.vacwt","page":"API","title":"WaveletsExt.ACWT.vacwt","text":"vacwt(x, wt[, L=maxtransformlevels(x)])\n\nComputes the row-wise discrete autocorrelation transform coeficients for 2D signals.\n\n\n\n\n\n","category":"function"},{"location":"api/#Wavelets.Threshold.bestbasistree-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T<:AbstractFloat","page":"API","title":"Wavelets.Threshold.bestbasistree","text":"bestbasistree(X[, method])\n\nExtension to the best basis tree function from Wavelets.jl. Given a set of  decomposed signals, returns different types of best basis trees based on the  methods specified. Available methods are the joint best basis (JBB()), least  statistically dependent basis (LSDB()), and individual regular best basis  (BB()).\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.BestBasis.bestbasis_treeselection-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T<:AbstractFloat","page":"API","title":"WaveletsExt.BestBasis.bestbasis_treeselection","text":"bestbasis_treeselection(costs, n)\n\nComputes the best tree based on the given cost vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.BestBasis.bestbasiscoef-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector}} where T<:AbstractFloat","page":"API","title":"WaveletsExt.BestBasis.bestbasiscoef","text":"bestbasiscoef(X, tree)\nbestbasiscoef(X, wt, tree)\n\nReturns the expansion coefficients based on the given tree(s) and wavelet packet decomposition (WPD) expansion coefficients. If the WPD expansion coefficients  were not provided, the expansion coefficients can be obtained by providing the signals and wavelet.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.BestBasis.tree_costs-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, LSDB}} where T<:AbstractFloat","page":"API","title":"WaveletsExt.BestBasis.tree_costs","text":"tree_costs(X, method)\n\nReturns the cost of each node in a binary tree in order to find the best basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Wavelets.Threshold.denoise-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T<:Number, S<:Wavelets.Threshold.DNFT}","page":"API","title":"Wavelets.Threshold.denoise","text":"denoise(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),\n    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),\n    estnoise=noisest, smooth=:regular])\n\nExtension of the denoise function from Wavelets.jl. Denoise a signal of  input type inputtype.\n\nArguments:\n\nx::AbstractArray{<:Number}: input signals/coefficients.\ninputtype::Symbol: input type of x. Current accepted types of inputs are\n:sig: original signals; x should be a 2-D array with each column    representing a signal.\n:dwt: dwt-transformed signal coefficients; x should be a 1-D array    with each column representing the coefficients of a signal.\n:wpt: wpt-transformed signal coefficients; x should be a 1-D array    with each column representing the coefficients of a signal.\n:sdwt: sdwt-transformed signal coefficients; x should be a 2-D array   with each column representing the coefficients of a node.\n:swpd: swpd-transformed signal coefficients; x should be a 2-D array   with each column representing the coefficients of a node.\n:acwt: acwt-transformed signal coefficients from    AutocorrelationShell.jl; x should be a 2-D array with each column    representing the coefficients of a node.\n:acwpt: acwpt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 2-D array with each column    representing the coefficients of a node.\nwt::Union{DiscreteWavelet, Nothing}: the discrete wavelet to be used for   decomposition (for input type :sig) and reconstruction. nothing can    be supplied if no reconstruction is necessary.\nL::Integer: the number of decomposition levels. Necessary for input types   :sig, :dwt, and :sdwt. Default value is set to be    maxtransformlevels(size(x,1)).\ntree::BitVector: the decomposition tree of the signals. Necessary for input   types :wpt and :swpd. Default value is set to be    maketree(size(x,1), L, :dwt).\ndnt::DNFT: denoise type. Default type is set to be VisuShrink(size(x,1)).\nestnoise::Union{Function, Vector{<:Number}}: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the noisest function.\nsmooth::Symbol: the smoothing method used. :regular smoothing thresholds   all given coefficients, whereas :undersmooth smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be :regular.\n\nSee also: denoiseall\n\n\n\n\n\n","category":"method"},{"location":"api/#Wavelets.Threshold.noisest-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T<:Number","page":"API","title":"Wavelets.Threshold.noisest","text":"noisest(x, redundant[, tree=nothing])\n\nExtension to the noisest function from Wavelets.jl. Estimates the noise of a signal from its coefficients.\n\nExamples\n\nx = randn(128)\nwt = wavelet(WT.haar)\n\n# noise estimate for dwt transformation\ny = dwt(x, wt)\nnoise = noisest(y, false)\n\n# noise estimate for wpt transformation\ntree = maketree(x, :full)\ny = wpt(x, wt, tree)\nnoise = noisest(y, false, tree)\n\n# noise estimate for sdwt transformation\ny = sdwt(x, wt)\nnoise = noisest(y, true)\n\n# noise estimate for swpd transformation\ny = swpd(x, wt)\nnoise = noisest(y, true, tree)\n\nSee also: relerrorthreshold\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Denoising.denoiseall-Union{Tuple{S}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, N} where N, Symbol, Union{Nothing, Wavelets.WT.DiscreteWavelet}}} where {T1<:Number, T2<:Number, S<:Wavelets.Threshold.DNFT}","page":"API","title":"WaveletsExt.Denoising.denoiseall","text":"denoiseall(x, inputtype, wt[; L=maxtransformlevels(size(x,1)),\n    tree=maketree(size(x,1), L, :dwt), dnt=VisuShrink(size(x,1)),\n    estnoise=noisest, bestTH=nothing, smooth=:regular])\n\nDenoise multiple signals of input type inputtype. \n\nArguments:\n\nx::AbstractArray{<:Number}: input signals/coefficients.\ninputtype::Symbol: input type of x. Current accepted types of inputs are\n:sig: original signals; x should be a 2-D array with each column    representing a signal.\n:dwt: dwt-transformed signal coefficients; x should be a 2-D array    with each column representing the coefficients of a signal.\n:wpt: wpt-transformed signal coefficients; x should be a 2-D array    with each column representing the coefficients of a signal.\n:sdwt: sdwt-transformed signal coefficients; x should be a 3-D array   with each 2-D slice representing the coefficients of a signal.\n:swpd: swpd-transformed signal coefficients; x should be a 3-D array   with each 2-D slice representing the coefficients of a signal.\n:acwt: acwt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 3-D array with each 2-D slice    representing the coefficients of a signal.\n:acwpt: acwpt-transformed signal coefficients from   AutocorrelationShell.jl; x should be a 3-D array with each 2-D slice    representing the coefficients of a signal.\nwt::Union{DiscreteWavelet, Nothing}: the discrete wavelet to be used for   decomposition (for input type :sig) and reconstruction. nothing can    be supplied if no reconstruction is necessary.\nL::Integer: the number of decomposition levels. Necessary for input types   :sig, :dwt, and :sdwt. Default value is set to be    maxtransformlevels(size(x,1)).\ntree::BitVector: the decomposition tree of the signals. Necessary for input   types :wpt and :swpd. Default value is set to be    maketree(size(x,1), L, :dwt).\ndnt::DNFT: denoise type. Default type is set to be VisuShrink(size(x,1)).\nestnoise::Union{Function, Vector{<:Number}}: noise estimation. Input can be   provided as a function to estimate noise in signal, or a vector of estimated   noise. Default is set to be the noisest function.\nbestTH::Union{Function, Nothing}: method to determine the best threshold    value for a group of signals. If nothing is given, then each signal will   be denoised by its respective best threshold value determined from the    parameters dnt and estnoise; otherwise some function can be passed   to determine the best threshold value from a vector of threshold values, eg:   mean and median. Default is set to be nothing.\nsmooth::Symbol: the smoothing method used. :regular smoothing thresholds   all given coefficients, whereas :undersmooth smoothing does not threshold   the lowest frequency subspace node of the wavelet transform. Default is set   to be :regular.\n\nSee alse: denoise, noisest\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Denoising.findelbow-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"API","title":"WaveletsExt.Denoising.findelbow","text":"findelbow(x, y)\n\nGiven the x and y coordinates of a curve, return the elbow.  \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Denoising.orth2relerror-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Number","page":"API","title":"WaveletsExt.Denoising.orth2relerror","text":"orth2relerror(orth)\n\nGiven a vector 'orth' of orthonormal expansion coefficients, return a  vector of relative approximation errors when retaining the 1,2,...,N  largest coefficients in magnitude.  \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Denoising.relerrorthreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}, Integer}} where T<:Number","page":"API","title":"WaveletsExt.Denoising.relerrorthreshold","text":"relerrorthreshold(coef, redundant[, tree, elbows=2; makeplot=false])\n\nTakes in a set of expansion coefficients, 'plot' the threshold vs relative error  curve and select the best threshold value based on the elbow method.\n\nExamples\n\nx = randn(128)\nwt = wavelet(WT.haar)\n\n# noise estimate for dwt transformation\ny = dwt(x, wt)\nnoise = relerrorthreshold(y, false)\n\n# noise estimate for wpt transformation\ntree = maketree(x, :full)\ny = wpt(x, wt, tree)\nnoise = relerrorthreshold(y, false, tree)\n\n# noise estimate for sdwt transformation\ny = sdwt(x, wt)\nnoise = relerrorthreshold(y, true)\n\n# noise estimate for swpd transformation\ny = swpd(x, wt)\nnoise = relerrorthreshold(y, true, tree)\n\nSee also: noisest, RelErrorShrink\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Denoising.surethreshold-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Bool}, Tuple{AbstractArray{T, N} where N, Bool, Union{Nothing, BitVector}}} where T<:Number","page":"API","title":"WaveletsExt.Denoising.surethreshold","text":"surethreshold(coef, redundant[, tree=nothing])\n\nDetermination of the t value used for SureShrink.\n\nSee also: SureShrink\n\n\n\n\n\n","category":"method"},{"location":"api/#Wavelets.Threshold.VisuShrink-Tuple{Integer, Wavelets.Threshold.THType}","page":"API","title":"Wavelets.Threshold.VisuShrink","text":"VisuShrink(n, th)\n\nExtension to the VisuShrink struct constructor from Wavelets.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Denoising.RelErrorShrink","page":"API","title":"WaveletsExt.Denoising.RelErrorShrink","text":"Relative Error Shrink\n\n\n\n\n\n","category":"type"},{"location":"api/#WaveletsExt.Denoising.RelErrorShrink-2","page":"API","title":"WaveletsExt.Denoising.RelErrorShrink","text":"RelErrorShrink([th=HardTH()])\n\nStruct constructor for Relative Error Shrink.\n\n\n\n\n\n","category":"type"},{"location":"api/#WaveletsExt.Denoising.SureShrink","page":"API","title":"WaveletsExt.Denoising.SureShrink","text":"Stein's Unbiased Risk Estimate (SURE) Shrink\n\n\n\n\n\n","category":"type"},{"location":"api/#WaveletsExt.Denoising.SureShrink-2","page":"API","title":"WaveletsExt.Denoising.SureShrink","text":"SureShrink(x[, tree=nothing, th=SteinTH()])\n\nStruct constructor for SureShrink based on the signal coefficients x.\n\n\n\n\n\n","category":"type"},{"location":"api/#WaveletsExt.LDB.discriminant_measure-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, DiscriminantMeasure}} where T<:Number","page":"API","title":"WaveletsExt.LDB.discriminant_measure","text":"discriminant_measure(Γ, dm)\n\nReturns the discriminant measure calculated from the energy maps.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.LDB.discriminant_power-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BitVector, BasisDiscriminantMeasure}} where T<:Number","page":"API","title":"WaveletsExt.LDB.discriminant_power","text":"discriminant_power(coefs, tree, dp)\n\nReturns the discriminant power of each leaf from the local discriminant basis (LDB) tree. \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.LDB.energy_map-Tuple{AbstractArray{var\"#s53\", 3} where var\"#s53\"<:Number, TimeFrequency}","page":"API","title":"WaveletsExt.LDB.energy_map","text":"energy_map(coef, method)\n\nReturns the Time Frequency Energy map or the Probability Density Energy map depending on the input method (TimeFrequency() or ProbabilityDensity()).  \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.LDB.ldb-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}} where {S<:Number, T}","page":"API","title":"WaveletsExt.LDB.ldb","text":"ldb(X, y, wt[; dm=AsymmetricRelativeEntropy(), energy=TimeFrequency(),\n    dp=BasisDiscriminantMeasure(), topk=size(X,1), m=size(X,1)])\n\nThe Local Discriminant Basis (LDB) feature selection algorithm developed by  Saito and Coifman. This function takes in the input signals and their  respective class labels, an orthogonal wavelet filter, and returns a set of  expansion coefficients of reduced features and dimensions.\n\nArguments:\n\nX::AbstractArray{<:Number,2}: the input set of signals. each column    represents a signal.\ny::AbstractVector{T}: the corresponding labels\nwt::DiscreteWavelet: a discrete wavelet for transform purposes\ndm::DiscriminantMeasure: the discriminant measure for the LDB algorithm.    Supported measures are the AsymmetricRelativeEntropy(), LpEntropy()   SymmetricRelativeEntropy(), and HellingerDistance(). Default is set to    be AsymmetricRelativeEntropy().\nenergy::EnergyMap: the type of energy map used. Supported maps are    TimeFrequency() and ProbabilityDensity(). Default is set to be    TimeFrequency().\ndp::DiscriminantPower(): the measure of discriminant power among expansion   coefficients. Supported measures are BasisDiscriminantMeasure(),   FishersClassSeparability(), and RobustFishersClassSeparability().    Default is set to be BasisDiscriminantMeasure().\ntopk::Integer: the top-k coefficients used in each node to determine the    discriminant measure. Default is set to all coefficients.\nm::Integer: the dimension of output after undergoing feature selection and   transformation. Default is set to all coefficients of most discriminant    subtree, ie. the length of each signals.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.SIWPD.makesiwpdtree-Tuple{Integer, Integer, Integer}","page":"API","title":"WaveletsExt.SIWPD.makesiwpdtree","text":"makesiwpdtree(n, L, d)\n\nReturns the multi-level, multi-depth binary tree corresponding to the Shift- Invariant Wavelet Packet Decomposition. \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.SIWPD.siwpd-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer}, Tuple{AbstractArray{T, N} where N, Wavelets.WT.OrthoFilter, Integer, Integer}} where T<:Number","page":"API","title":"WaveletsExt.SIWPD.siwpd","text":"siwpd(x, wt[, L=maxtransformlevels(x), d=L])\n\nComputes the Shift-Invariant Wavelet Packet Decomposition originally developed by Cohen, Raz & Malah on the vector x using the discrete wavelet filter wt for L levels with depth d.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.SWT.isdwt","page":"API","title":"WaveletsExt.SWT.isdwt","text":"isdwt(xw, wt[, ε])\n\nPerforms the inverse stationary discrete wavelet transform (ISDWT) on the sdwt transform coefficients with respect to the Boolean Vector ε which represents  the shifts to be used. If ε is not provided, the average-basis ISDWT will be  computed instead.\n\nSee also: iswpt, sdwt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.isdwt_step","page":"API","title":"WaveletsExt.SWT.isdwt_step","text":"isdwt_step(v1, w1, j, s0, s1, g, h)\n\nPerform one level of the inverse stationary discrete wavelet transform (ISDWT)  on the vector v1 and w1, which is the j-th level scaling coefficients (Note  the 0th level scaling coefficients is the raw signal). The vectors h and g  are the detail and scaling filters.\n\nReturns a vector v0 of the scaling and detail coefficients at level j-1.\n\nSee also: isdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.isdwt_step!","page":"API","title":"WaveletsExt.SWT.isdwt_step!","text":"isdwt_step!(v0, v1, w1, j, s0, s1, g, h)\n\nSame as isdwt_step but without array allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.iswpt","page":"API","title":"WaveletsExt.SWT.iswpt","text":"iswpt(xw, wt, ε[, L=maxtransformlevels(size(xw,1))])\n\niswpt(xw, wt, ε, tree)\n\niswpt(xw, wt[, L=maxtransformlevels(size(xw,1))])\n\niswpt(xw, wt, tree)\n\nPerforms the inverse stationary wavelet packet transform (ISWPT) on the swpd transform coefficients with respect to a given Boolean Vector that represents a binary tree and the BitVector ε which represents the shifts to be used. If ε is not provided, the average-basis ISWPT will be computed instead. \n\nSee also: isdwt, swpd\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.sdwt","page":"API","title":"WaveletsExt.SWT.sdwt","text":"sdwt(x, wt[, L=maxtransformlevels(x)])\n\nPerform a stationary discrete wavelet transform (SDWT) of the array x. The wavelet type wt determines the transform type and the wavelet class, see  wavelet. \n\nThe number of transform levels L can be 1 ≤ L ≤ maxtransformlevels(x). Default value is set to maxtransformlevels(x).\n\nReturns the n × (L+1) matrix (where n is the length of x) with the detail coefficients for level j in column (L-j+2). The scaling coefficients are in the 1st column.\n\nSee also: swpd, swpt, isdwt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.sdwt_step","page":"API","title":"WaveletsExt.SWT.sdwt_step","text":"sdwt_step(v, j, h, g)\n\nPerform one level of the stationary discrete wavelet transform (SDWT) on the  vector v, which is the j-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors h and g are the detail and scaling filters.\n\nReturns a tuple (v, w) of the scaling and detail coefficients at level j+1.\n\nSee also: sdwt_step!\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.sdwt_step!","page":"API","title":"WaveletsExt.SWT.sdwt_step!","text":"sdwt_step!(v1, w1, v, j, h, g)\n\nSame as sdwt_step but without array allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.swpd","page":"API","title":"WaveletsExt.SWT.swpd","text":"swpd(x, wt[, L=maxtransformlevels(x)])\n\nPerform a stationary wavelet packet decomposition (SPWD) of the array x. The  wavelet type wt determines the transform type and the wavelet class, see  wavelet.\n\nThe number of transform levels L can be 1 ≤ L ≤ maxtransformlevels(x). Default value is set to maxtransformlevels(x).\n\nReturns the n × (2⁽ᴸ⁺¹⁾-1) matrix (where n is the length of x) with each  column representing the nodes in the binary tree.\n\nSee also: swpt, sdwt, iswpt\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.SWT.swpt","page":"API","title":"WaveletsExt.SWT.swpt","text":"swpt(x, wt[, L=maxtransformlevels(x)])\n\nswpt(x, wt, tree)\n\nswpt(x, h, g, tree)\n\nswpt(x, h, g, tree, i)\n\nPerforms the stationary wavelet packet transform (SWPT) of the vector x of  length N = 2ᴸ. The wavelet type wt determines the transform type and the  wavelet class, see wavelet.\n\nThe number of transform levels L can be 1 ≤ L ≤ maxtransformlevels(x). Default value is set to maxtransformlevels(x).\n\nReturns the expansion coefficients of the SWPT of the size N × k. Each column  represents a leaf node from tree. Number of returned columns can vary between  1 ≤ k ≤ N depending on the input tree.\n\nSee also: sdwt, swpd\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.Utils.coarsestscalingrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T<:Number","page":"API","title":"WaveletsExt.Utils.coarsestscalingrange","text":"coarsestscalingrange(x, tree[, redundant=false])\n\ncoarsestscalingrange(n, tree[, redundant=false])\n\nGiven a binary tree, returns the index range of the coarsest scaling  coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.finestdetailrange-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, BitVector}, Tuple{AbstractArray{T, N} where N, BitVector, Bool}} where T<:Number","page":"API","title":"WaveletsExt.Utils.finestdetailrange","text":"finestdetailrange(x, tree[, redundant=false])\n\nfinestdetailrange(n, tree[, redundant=false])\n\nGiven a binary tree, returns the index range of the coarsest scaling  coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.generatesignals-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Integer}, Tuple{AbstractVector{T}, Integer, Integer, Bool}, Tuple{AbstractVector{T}, Integer, Integer, Bool, Real}} where T<:Number","page":"API","title":"WaveletsExt.Utils.generatesignals","text":"generatesignals(x, N, k[, noise=false, t=1])\n\nGiven a signal x, returns N shifted versions of the signal, each with shifts of multiples of k. \n\nSetting noise = true allows randomly generated Gaussian noises of μ = 0,  σ² = t to be added to the circularly shifted signals.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.getleaf-Tuple{BitVector}","page":"API","title":"WaveletsExt.Utils.getleaf","text":"getleaf(tree)\n\nReturns the leaf nodes of a tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.left-Tuple{Integer}","page":"API","title":"WaveletsExt.Utils.left","text":"left(i)\n\nGiven the node index i, returns the index of its left node.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.nodelength-Tuple{Integer, Integer}","page":"API","title":"WaveletsExt.Utils.nodelength","text":"nodelength(N, L)\n\nReturns the node length at level L of a signal of length N. Level L == 0  corresponds to the original input signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.psnr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"API","title":"WaveletsExt.Utils.psnr","text":"psnr(x, x₀)\n\nReturns the peak signal to noise ratio (PSNR) between original signal x₀ and noisy signal x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.relativenorm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Real}} where T<:Number","page":"API","title":"WaveletsExt.Utils.relativenorm","text":"relativenorm(x, x₀[, p=2]) where T<:Number\n\nReturns the relative norm of base p between original signal x₀ and noisy signal x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.right-Tuple{Integer}","page":"API","title":"WaveletsExt.Utils.right","text":"right(i)\n\nGiven the node index i, returns the index of its right node.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.snr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"API","title":"WaveletsExt.Utils.snr","text":"snr(x, x₀)\n\nReturns the signal to noise ratio (SNR) between original signal x₀ and noisy  signal x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Utils.ssim-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}} where T<:Number","page":"API","title":"WaveletsExt.Utils.ssim","text":"ssim(x, x₀)\n\nWrapper for assess_ssim function from ImageQualityIndex.jl.\n\nReturns the Structural Similarity Index Measure (SSIM) between the original  signal/image x₀ and noisy signal/image x. \n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Visualizations.plot_tfbdry-Tuple{BitVector}","page":"API","title":"WaveletsExt.Visualizations.plot_tfbdry","text":"plot_tfbdry(tree[; start=0, nodecolor:white])\n\nGiven a tree, output a visual representation of the leaf nodes, user will  have the option to start the node count of each level with 0 or 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Visualizations.treenodes_matrix-Tuple{BitVector}","page":"API","title":"WaveletsExt.Visualizations.treenodes_matrix","text":"treenodes_matrix(x)\n\nGiven a BitVector of nodes in a binary tree, output the matrix representation  of the nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Visualizations.wiggle!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"API","title":"WaveletsExt.Visualizations.wiggle!","text":"wiggle!(wav; taxis=1:size(wav,1), zaxis=1:size(wav,2), sc=1, \n    EdgeColor=:black, FaceColor=:black, Orient=:across, Overlap=true, \n    ZDir=:normal)\n\nPlot a set of shaded wiggles on the current displayed graphics\n\nArguments\n\n'wav::AbstractArray{<:Number,2}': matrix of waveform columns.\n'taxis::AbstractVector=1:size(wav,1)': time axis vector\n'zaxis::AbstractVector=1:size(wav,2)': space axis vector\n'sc::Real=1': scale factor/magnification.\n'EdgeColor::Symbol=:black': Sets edge of wiggles color.\n'FaceColor::Symbol=:black': Sets shading color of wiggles.\n'Overlap::Bool=true': How signals are scaled.       true  - Signals overlap (default);       false - Signals are scaled so they do not overlap.\n'Orient::Symbol=:across': Controls orientation of wiggles.       :across - from left to right       :down   - from top to down\n'ZDir::Symbol=:normal': Direction of space axis.       :normal  - First signal at bottom (default)       :reverse - First signal at top.\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito The previous MATLAB version contributors are:     Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC) Revised by Naoki Saito, Feb. 05, 2018\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.Visualizations.wiggle-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"API","title":"WaveletsExt.Visualizations.wiggle","text":"wiggle(wav; taxis=1:size(wav,1), zaxis=1:size(wav,2), sc=1, \n    EdgeColor=:black, FaceColor=:black, Orient=:across, Overlap=true, \n    ZDir=:normal)\n\nPlot a set of shaded wiggles.\n\nArguments\n\n'wav::AbstractArray{<:Number, 2}': matrix of waveform columns.\n'taxis::AbstractVector=1:size(wav,1)': time axis vector\n'zaxis::AbstractVector=1:size(wav,2)': space axis vector\n'sc::Real=1': scale factor/magnification.\n'EdgeColor::Symbol=:black': Sets edge of wiggles color.\n'FaceColor::Symbol=:black': Sets shading color of wiggles.\n'Overlap::Bool=true': How signals are scaled.       true  - Signals overlap (default);       false - Signals are scaled so they do not overlap.\n'Orient::Symbol=:across': Controls orientation of wiggles.       :across - from left to right       :down   - from top to down\n'ZDir::Symbol=:normal': Direction of space axis.       :normal  - First signal at bottom (default)       :reverse - First signal at top.\n\nTranslated by Nicholas Hausch – MATLAB file provided by Naoki Saito The previous MATLAB version contributors are:     Anthony K. Booer (SLB) and Bradley Marchand (NSWC-PC) Revised by Naoki Saito, Feb. 05, 2018\n\n\n\n\n\n","category":"method"},{"location":"api/#WaveletsExt.WPD.wpd","page":"API","title":"WaveletsExt.WPD.wpd","text":"wpd(x, wt[, L=maxtransformlevels(x)])\n\nwpd(x, wt, hqf, gqf[, L=maxtransformlevels(x)])\n\nReturns the wavelet packet decomposition WPD) for L levels for input signal(s)  x.\n\n\n\n\n\n","category":"function"},{"location":"api/#WaveletsExt.WPD.wpd!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Wavelets.WT.DiscreteWavelet, Integer}} where T<:Number","page":"API","title":"WaveletsExt.WPD.wpd!","text":"wpd!(y, x, wt[, L=maxtransformlevels(x)])\n\nwpd!(y, x, wt, hqf, gqf[, L=maxtransformlevels(x)])\n\nSame as wpd but without array allocation.\n\n\n\n\n\n","category":"method"},{"location":"bestbasis/#Best-Basis-Examples","page":"Best Basis Examples","title":"Best Basis Examples","text":"","category":"section"},{"location":"bestbasis/#Regular-Best-Basis","page":"Best Basis Examples","title":"Regular Best Basis","text":"","category":"section"},{"location":"bestbasis/","page":"Best Basis Examples","title":"Best Basis Examples","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nX = generatesignals(x, 10, 2, true, 0.5)\nwt = wavelet(WT.db4)\n\n# decomposition\ny = cat([wpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis tree\nbt = bestbasistree(y, BB())","category":"page"},{"location":"bestbasis/#Joint-Best-Basis-(JBB)","page":"Best Basis Examples","title":"Joint Best Basis (JBB)","text":"","category":"section"},{"location":"bestbasis/","page":"Best Basis Examples","title":"Best Basis Examples","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nX = generatesignals(x, 10, 2, true, 0.5)\nwt = wavelet(WT.db4)\n\n# decomposition\ny = cat([wpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis tree\nbt = bestbasistree(y, JBB())","category":"page"},{"location":"bestbasis/#Least-Statistically-Dependent-Basis-(LSDB)","page":"Best Basis Examples","title":"Least Statistically Dependent Basis (LSDB)","text":"","category":"section"},{"location":"bestbasis/","page":"Best Basis Examples","title":"Best Basis Examples","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nX = generatesignals(x, 10, 2, true, 0.5)\nwt = wavelet(WT.db4)\n\n# decomposition\ny = cat([wpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis tree\nbt = bestbasistree(y, LSDB())","category":"page"},{"location":"transforms/#Wavelet-Transforms","page":"Wavelet Transforms","title":"Wavelet Transforms","text":"","category":"section"},{"location":"transforms/#Wavelet-Packet-Decomposition","page":"Wavelet Transforms","title":"Wavelet Packet Decomposition","text":"","category":"section"},{"location":"transforms/#Example","page":"Wavelet Transforms","title":"Example","text":"","category":"section"},{"location":"transforms/","page":"Wavelet Transforms","title":"Wavelet Transforms","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nwt = wavelet(WT.db4)\n\n# decomposition\ny = wpd(x, wt)","category":"page"},{"location":"transforms/#Stationary-Discrete-Wavelet-Transform","page":"Wavelet Transforms","title":"Stationary Discrete Wavelet Transform","text":"","category":"section"},{"location":"transforms/#Example-2","page":"Wavelet Transforms","title":"Example","text":"","category":"section"},{"location":"transforms/","page":"Wavelet Transforms","title":"Wavelet Transforms","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nwt = wavelet(WT.db4)\n\n# transform\ny = sdwt(x, wt)","category":"page"},{"location":"transforms/#Stationary-Wavelet-Packet-Decomposition","page":"Wavelet Transforms","title":"Stationary Wavelet Packet Decomposition","text":"","category":"section"},{"location":"transforms/#Example-3","page":"Wavelet Transforms","title":"Example","text":"","category":"section"},{"location":"transforms/","page":"Wavelet Transforms","title":"Wavelet Transforms","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nwt = wavelet(WT.db4)\n\n# decomposition\ny = swpd(x, wt)","category":"page"},{"location":"transforms/#Shift-Invariant-Wavelet-Packet-Decomposition","page":"Wavelet Transforms","title":"Shift-Invariant Wavelet Packet Decomposition","text":"","category":"section"},{"location":"transforms/#Example-4","page":"Wavelet Transforms","title":"Example","text":"","category":"section"},{"location":"transforms/","page":"Wavelet Transforms","title":"Wavelet Transforms","text":"using Wavelets, WaveletsExt\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nwt = wavelet(WT.db4)\n\n# decomposition\ny = siwpd(x, wt, maxtransformlevels(x),)","category":"page"},{"location":"denoising/#Denoising-Examples","page":"Denoising Examples","title":"Denoising Examples","text":"","category":"section"},{"location":"denoising/#Denoising-a-single-signal","page":"Denoising Examples","title":"Denoising a single signal","text":"","category":"section"},{"location":"denoising/","page":"Denoising Examples","title":"Denoising Examples","text":"using Wavelets, WaveletsExt, Random\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\") + 0.5*randn(256)\nwt = wavelet(WT.db4)\n\n# best basis tree\nbt = bestbasistree(wpd(x, wt), BB())\ny = bestbasiscoef(x, wt, bt)\n\n# denoise\nx̂ = denoise(y, :wpt, wt, tree=bt)","category":"page"},{"location":"denoising/#Denoising-a-group-of-signals","page":"Denoising Examples","title":"Denoising a group of signals","text":"","category":"section"},{"location":"denoising/","page":"Denoising Examples","title":"Denoising Examples","text":"using Wavelets, WaveletsExt, Random\n\n# define function and wavelet\nx = testfunction(256, \"HeaviSine\")\nX = generatesignals(x, 10, 2, true, 0.5)\nwt = wavelet(WT.db4)\n\n# decomposition\ncoef = cat([wpd(X[:,i], wt) for i in axes(X,2)]..., dims=3)\n\n# best basis tree\nbt = bestbasistree(coef, JBB())\nY = bestbasiscoef(coef, bt)\n\n# denoise\nX̂ = denoiseall(Y, :wpt, wt, tree=bt)","category":"page"},{"location":"#WaveletsExt.jl","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"This package is a Julia extension package to Wavelets.jl (WaveletsExt is short for Wavelets Extension). It contains additional functionalities that complement Wavelets.jl, which include multiple best basis algorithms, denoising methods, Local Discriminant Basis (LDB), Stationary Wavelet Transform, and the Shift Invariant Wavelet Decomposition.","category":"page"},{"location":"#Authors","page":"WaveletsExt.jl","title":"Authors","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"This package is written and maintained by Zeng Fung Liew and Shozen Dan under the supervision of Professor Naoki Saito at the University of California, Davis.","category":"page"},{"location":"#Installation","page":"WaveletsExt.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"The package is part of the official Julia Registry. It can be install via the Julia REPL.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"(@1.x) pkg> add WaveletsExt","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"or","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"julia> using Pkg; Pkg.add(\"WaveletsExt\")","category":"page"},{"location":"#Usage","page":"WaveletsExt.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"Load the WaveletsExt module along with Wavelets.jl.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"using Wavelets, WaveletsExt","category":"page"},{"location":"#Wavelet-Packet-Decomposition","page":"WaveletsExt.jl","title":"Wavelet Packet Decomposition","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"In contrast to Wavelets.jl's wpt function, wpd outputs expansion coefficients of all levels of a given signal. Each column represents a level in the decomposition tree.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"y = wpd(x, wavelet(WT.db4))","category":"page"},{"location":"#Stationary-Wavelet-Transform","page":"WaveletsExt.jl","title":"Stationary Wavelet Transform","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"The redundant and non-orthogonal transform by Nason-Silverman can be implemented using either sdwt (for stationary discrete wavelet transform) or iswpd (for stationary wavelet packet decomposition). Similarly, the reconstruction of signals can be computed using isdwt and iswpt.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"# stationary discrete wavelet transform\ny = sdwt(x, wavelet(WT.db4))\nz = isdwt(y, wavelet(WT.db4))\n\n# stationary wavelet packet decomposition\ny = swpd(x, wavelet(WT.db4))\nz = iswpt(y, wavelet(WT.db4))","category":"page"},{"location":"#Best-Basis","page":"WaveletsExt.jl","title":"Best Basis","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"In addition to the best basis algorithm by M.V. Wickerhauser implemented in Wavelets.jl, WaveletsExt.jl contains the implementation of the Joint Best Basis (JBB) by Wickerhauser an the Least Statistically-Dependent Basis (LSDB) by Saito.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"y = cat([wpd(x[:,i], wt) for i in N]..., dims=3)    # x has size (2^L, N)\n\n# individual best basis trees\nbbt = bestbasistree(y, BB())\n# joint best basis\nbbt = bestbasistree(y, JBB())\n# least statistically dependent basis\nbbt = bestbasistree(y, LSDB())","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"Given a BitVector representing a best basis tree, one can obtain the corresponding expansion coefficients using bestbasiscoef.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"coef = bestbasiscoef(y, bbt)","category":"page"},{"location":"#Local-Discriminant-Basis","page":"WaveletsExt.jl","title":"Local Discriminant Basis","text":"","category":"section"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"Local Discriminant Basis (LDB) is a feature extraction method developed by Naoki Saito.","category":"page"},{"location":"","page":"WaveletsExt.jl","title":"WaveletsExt.jl","text":"coef, y, ldb_tree, power, order = ldb(X, y, wavelet(WT.coif3))","category":"page"}]
}
