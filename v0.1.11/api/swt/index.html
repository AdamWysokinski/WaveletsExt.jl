<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SWT · WaveletsExt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">WaveletsExt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/transforms/">Transforms</a></li><li><a class="tocitem" href="../../manual/bestbasis/">Best Basis</a></li><li><a class="tocitem" href="../../manual/denoising/">Denoising</a></li><li><a class="tocitem" href="../../manual/localdiscriminantbasis/">Local Discriminant Basis</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../dwt/">DWT</a></li><li><a class="tocitem" href="../acwt/">ACWT</a></li><li class="is-active"><a class="tocitem" href>SWT</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li></ul></li><li><a class="tocitem" href="../tiwt/">TIWT</a></li><li><a class="tocitem" href="../bestbasis/">Best Basis</a></li><li><a class="tocitem" href="../denoising/">Denoising</a></li><li><a class="tocitem" href="../ldb/">LDB</a></li><li><a class="tocitem" href="../siwpd/">SIWPD</a></li><li><a class="tocitem" href="../utils/">Utils</a></li><li><a class="tocitem" href="../visualizations/">Visualizations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>SWT</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SWT</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/master/docs/src/api/swt.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Stationary-Wavelet-Transform"><a class="docs-heading-anchor" href="#Stationary-Wavelet-Transform">Stationary Wavelet Transform</a><a id="Stationary-Wavelet-Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Stationary-Wavelet-Transform" title="Permalink"></a></h1><ul><li><a href="#WaveletsExt.SWT.isdwt"><code>WaveletsExt.SWT.isdwt</code></a></li><li><a href="#WaveletsExt.SWT.isdwt!"><code>WaveletsExt.SWT.isdwt!</code></a></li><li><a href="#WaveletsExt.SWT.isdwt_step"><code>WaveletsExt.SWT.isdwt_step</code></a></li><li><a href="#WaveletsExt.SWT.isdwt_step!"><code>WaveletsExt.SWT.isdwt_step!</code></a></li><li><a href="#WaveletsExt.SWT.isdwtall"><code>WaveletsExt.SWT.isdwtall</code></a></li><li><a href="#WaveletsExt.SWT.iswpd"><code>WaveletsExt.SWT.iswpd</code></a></li><li><a href="#WaveletsExt.SWT.iswpd!"><code>WaveletsExt.SWT.iswpd!</code></a></li><li><a href="#WaveletsExt.SWT.iswpdall"><code>WaveletsExt.SWT.iswpdall</code></a></li><li><a href="#WaveletsExt.SWT.iswpt"><code>WaveletsExt.SWT.iswpt</code></a></li><li><a href="#WaveletsExt.SWT.iswpt!"><code>WaveletsExt.SWT.iswpt!</code></a></li><li><a href="#WaveletsExt.SWT.iswptall"><code>WaveletsExt.SWT.iswptall</code></a></li><li><a href="#WaveletsExt.SWT.sdwt"><code>WaveletsExt.SWT.sdwt</code></a></li><li><a href="#WaveletsExt.SWT.sdwt!"><code>WaveletsExt.SWT.sdwt!</code></a></li><li><a href="#WaveletsExt.SWT.sdwt_step"><code>WaveletsExt.SWT.sdwt_step</code></a></li><li><a href="#WaveletsExt.SWT.sdwt_step!"><code>WaveletsExt.SWT.sdwt_step!</code></a></li><li><a href="#WaveletsExt.SWT.sdwtall"><code>WaveletsExt.SWT.sdwtall</code></a></li><li><a href="#WaveletsExt.SWT.swpd"><code>WaveletsExt.SWT.swpd</code></a></li><li><a href="#WaveletsExt.SWT.swpd!"><code>WaveletsExt.SWT.swpd!</code></a></li><li><a href="#WaveletsExt.SWT.swpdall"><code>WaveletsExt.SWT.swpdall</code></a></li><li><a href="#WaveletsExt.SWT.swpt"><code>WaveletsExt.SWT.swpt</code></a></li><li><a href="#WaveletsExt.SWT.swpt!"><code>WaveletsExt.SWT.swpt!</code></a></li><li><a href="#WaveletsExt.SWT.swptall"><code>WaveletsExt.SWT.swptall</code></a></li></ul><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Transforms-on-1-Signal"><a class="docs-heading-anchor" href="#Transforms-on-1-Signal">Transforms on 1 Signal</a><a id="Transforms-on-1-Signal-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms-on-1-Signal" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt" href="#WaveletsExt.SWT.sdwt"><code>WaveletsExt.SWT.sdwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdwt(x, wt[, L])</code></pre><p>Computes the stationary discrete wavelet transform (SDWT) for <code>L</code> levels.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Original signal,   preferably of size 2ᴷ where <span>$K \in \mathbb{N}$</span>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of levels of decomposition.</li></ul><p><strong>Returns</strong></p><p><code>::Matrix{T}</code> or <code>::Array{T,3}</code>: Output from SDWT on <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SDWT
xw = sdwt(x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.swpd"><code>swpd</code></a>, <a href="#WaveletsExt.SWT.swpt"><code>swpt</code></a>, <a href="#WaveletsExt.SWT.isdwt"><code>isdwt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L32-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt!" href="#WaveletsExt.SWT.sdwt!"><code>WaveletsExt.SWT.sdwt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdwt!(xw, x, wt[, L])</code></pre><p>Same as <code>sdwt</code> but without array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: An allocated array of dimension <code>(n,L+1)</code> to write the outputs of <code>x</code> onto.</li><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Original signal, preferably of size 2ᴷ where <span>$K \in \mathbb{N}$</span>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of levels of decomposition.</li></ul><p><strong>Returns</strong></p><p><code>xw::Array{T,2}</code> or <code>xw::Array{T,3}</code>: Output from SDWT on <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine, 7)
wt = wavelet(WT.haar)

# SDWT
xw = Matrix{Float64}(undef, (128,5))
sdwt!(xw, x, wt, 4)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.sdwt"><code>sdwt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L78-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt" href="#WaveletsExt.SWT.isdwt"><code>WaveletsExt.SWT.isdwt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdwt(xw, wt[, sm])</code></pre><p>Computes the inverse stationary discrete wavelet transform (iSDWT) on <code>xw</code>.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: SDWT-transformed array.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><p><code>::Vector{T}</code> or <code>::Matrix{T}</code>: Inverse transformed signal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SDWT
xw = sdwt(x, wt)

#  Shift-based iSDWT
x̂ = isdwt(xw, wt, 5)

# Average-based iSDWT
x̃ = isdwt(xw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt_step"><code>isdwt_step</code></a>, <a href="#WaveletsExt.SWT.iswpt"><code>iswpt</code></a>, <a href="#WaveletsExt.SWT.sdwt"><code>sdwt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L161-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt!" href="#WaveletsExt.SWT.isdwt!"><code>WaveletsExt.SWT.isdwt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdwt!(x, xw, wt[, sm])</code></pre><p>Same as <code>isdwt</code> but with no array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Allocation for reconstructed signal.</li><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: SDWT-transformed array.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><p><code>x::Vector{T}</code> or <code>x::Matrix{T}</code>: Inverse transformed signal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SDWT
xw = sdwt(x, wt)

#  Shift-based iSDWT
x̂ = similar(x)
isdwt!(x̂, xw, wt, 5)

# Average-based iSDWT
isdwt(x̂, xw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt"><code>isdwt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L220-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpt" href="#WaveletsExt.SWT.swpt"><code>WaveletsExt.SWT.swpt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swpt(x, wt[, L])</code></pre><p>Computes <code>L</code> levels of stationary wavelet packet transform (SWPT) on <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Original signal, preferably of size 2ᴷ where <span>$K \in \mathbb{N}$</span>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of levels of decomposition.</li></ul><p><strong>Returns</strong></p><p><code>::Matrix{T}</code> or <code>::Array{T,3}</code>: Output from SWPT on <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPT
xw = swpt(x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.sdwt"><code>sdwt</code></a>, <a href="#WaveletsExt.SWT.swpd"><code>swpd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L362-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpt!" href="#WaveletsExt.SWT.swpt!"><code>WaveletsExt.SWT.swpt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swpt!(xw, x, wt[, L])</code></pre><p>Same as <code>swpt</code> but without array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: Allocation for transformed signal.</li><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Original signal, preferably of size 2ᴷ where <span>$K \in \mathbb{N}$</span>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of levels of decomposition.</li></ul><p><strong>Returns</strong></p><p><code>xw::Matrix{T}</code> or <code>xw::Array{T,3}</code>: Output from SWPT on <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPT
xw = Array{Float64,2}(undef, (128,128))
swpt!(xw, x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.swpt"><code>swpt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L409-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswpt" href="#WaveletsExt.SWT.iswpt"><code>WaveletsExt.SWT.iswpt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswpt(xw, wt[, sm])</code></pre><p>Computes the inverse stationary wavelet packet transform (iSWPT) on <code>xw</code>.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: SWPT-transformed array.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><p><code>::Vector{T}</code> or <code>::Matrix{T}</code>: Inverse transformed signal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPT
xw = swpt(x, wt)

# Shift-based iSWPT
x̂ = iswpt(xw, wt, 5)

# Average-based iSWPT
x̃ = iswpt(xw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt_step"><code>isdwt_step</code></a>, <a href="#WaveletsExt.SWT.isdwt"><code>isdwt</code></a>, <a href="#WaveletsExt.SWT.swpt"><code>swpt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L516-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswpt!" href="#WaveletsExt.SWT.iswpt!"><code>WaveletsExt.SWT.iswpt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswpt!(x, xw, wt[, sm])</code></pre><p>Same as <code>iswpt</code> but with no array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Allocation for inverse transform.</li><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: SWPT-transformed array.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><p><code>x::Vector{T}</code> or <code>x::Matrix{T}</code>: Inverse transformed signal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPT
xw = swpt(x, wt)

# Shift-based iSWPT
x̂ = similar(x)
iswpt!(x̂, xw, wt, 5)

# Average-based iSWPT
iswpt!(x̂, xw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.iswpt"><code>iswpt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L574-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpd" href="#WaveletsExt.SWT.swpd"><code>WaveletsExt.SWT.swpd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swpd(x, wt[, L])</code></pre><p>Computes <code>L</code> levels of stationary wavelet packet decomposition (SWPD) on <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Original signal, preferably of size 2ᴷ where <span>$K \in \mathbb{N}$</span>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of levels of decomposition.</li></ul><p><strong>Returns</strong></p><p><code>::Matrix{T}</code> or <code>::Array{T,3}</code>: Output from SWPD on <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPD
xw = swpd(x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.iswpd"><code>iswpd</code></a>, <a href="#WaveletsExt.SWT.swpt"><code>swpt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L762-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpd!" href="#WaveletsExt.SWT.swpd!"><code>WaveletsExt.SWT.swpd!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swpd!(xw, x, wt[, L])</code></pre><p>Same as <code>swpd</code> but without array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: Allocation for transformed signal.</li><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Original signal, preferably of size 2ᴷ where <span>$K \in \mathbb{N}$</span>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code>) Number of levels of decomposition.</li></ul><p><strong>Returns</strong></p><p><code>xw::Matrix{T}</code> or <code>xw::Array{T,3}</code>: Output from SWPD on <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPD
xw = Matrix{T}(undef, (128, 255))
swpd!(xw, x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.swpd"><code>swpd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L809-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswpd" href="#WaveletsExt.SWT.iswpd"><code>WaveletsExt.SWT.iswpd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswpd(xw, wt, L, sm)
iswpd(xw, wt[, L])
iswpd(xw, wt, tree[, sm])</code></pre><p>Computes the inverse stationary wavelet packet transform (iSWPT) on <code>xw</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function might not be very useful if one is looking to reconstruct a raw decomposed signal. The purpose of this function would be better utilized in applications such as denoising, where a signal is decomposed (<code>swpd</code>) and thresholded (<code>denoise</code>/<code>denoiseall</code>) before being reconstructed.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T,2}</code> or <code>x::AbstractArray{T,3} where T&lt;:Number</code>: SWPD-transformed array.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code> or <code>minimum(size(xw)[1:end-1]) |&gt; maxtransformlevels</code>) Number of levels of decomposition used for reconstruction.</li><li><code>tree::BitVector</code>: Binary/Quad tree for inverse transform to be computed accordingly. </li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><p><code>::Vector{T}</code> or <code>::Matrix{T}</code>: Inverse transformed signal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPD
xw = swpt(x, wt)

# Shift-based iSWPD
x̂ = iswpd(xw, wt, maxtransformlevels(xw,1), 5)

# Average-based iSWPD
x̃ = iswpd(xw, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt_step"><code>isdwt_step</code></a>, <a href="#WaveletsExt.SWT.iswpt"><code>iswpt</code></a>, <a href="#WaveletsExt.SWT.swpd"><code>swpd</code></a>, <a href="#WaveletsExt.SWT.iswpd!"><code>iswpd!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L905-L951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswpd!" href="#WaveletsExt.SWT.iswpd!"><code>WaveletsExt.SWT.iswpd!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswpd!(x, xw, wt, L, sm)
iswpd!(x, xw, wt[, L])
iswpd!(x, xw, wt, tree, sm)
iswpd!(x, xw, wt, tree)</code></pre><p>Same as <code>iswpd</code> but with no array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code> or <code>x::AbstractMatrix{T} where T&lt;:Number</code>: Allocated array for output.</li><li><code>xw::AbstractArray{T,2}</code> or <code>xw::AbstractArray{T,3} where T&lt;:Number</code>: SWPD-transformed array.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>maxtransformlevels(x)</code> or <code>minimum(size(xw)[1:end-1]) |&gt; maxtransformlevels</code>) Number of levels of decomposition used for reconstruction.</li><li><code>tree::BitVector</code>: Binary/Quad tree for inverse transform to be computed accordingly. </li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><p><code>x::Vector{T}</code> or <code>x::Matrix{T}</code>: Inverse transformed signal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
x = generatesignals(:heavysine)
wt = wavelet(WT.haar)

# SWPD
xw = swpd(x, wt)

# ISWPD
x̂ = similar(x)
iswpd!(x̂, xw, wt, 4, 5)
iswpd!(x̂, xw, wt, maketree(x), 5)
iswpd!(x̂, xw, wt, 4)
iswpd!(x̂, xw, wt, maketree(x))</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.iswpd"><code>iswpd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/SWT.jl#L990-L1034">source</a></section></article><h3 id="Transforms-on-Multiple-Signals"><a class="docs-heading-anchor" href="#Transforms-on-Multiple-Signals">Transforms on Multiple Signals</a><a id="Transforms-on-Multiple-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms-on-Multiple-Signals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwtall" href="#WaveletsExt.SWT.sdwtall"><code>WaveletsExt.SWT.sdwtall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdwtall(x, wt[, L])</code></pre><p>Computes the stationary discrete wavelet transform (SDWT) on each slice of signal.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray{T} where T&lt;:Number</code>: Input <code>N-1</code>-D signals, where each signal is sliced at dimension <code>N</code>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>Wavelets.maxtransformlevels(xᵢ)</code>) Number of levels of wavelet transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Array{T}</code>: Slices of transformed signals.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Generate random signals
x = randn(32, 5)
# Create wavelet
wt = wavelet(WT.db4)

# SDWT on all signals in x
xw = sdwtall(x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.sdwt"><code>sdwt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_all.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwtall" href="#WaveletsExt.SWT.isdwtall"><code>WaveletsExt.SWT.isdwtall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdwtall(xw[, wt])
isdwtall(xw, wt, sm)</code></pre><p>Computes the inverse stationary discrete wavelet transform (ISDWT) on each slice of signal.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T} where T&lt;:Number</code>: SDWT-transformed signal.</li><li><code>wt::OrthoFilter</code>: (Default: <code>nothing</code>) Orthogonal wavelet filter.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Array{T}</code>: Slices of reconstructed signals.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Generate random signals
x = randn(32, 5)
# Create wavelet
wt = wavelet(WT.db4)

# SDWT on all signals in x
xw = sdwtall(x, wt)

# ISDWT on all signals in xw
x̂ = isdwtall(xw)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt"><code>isdwt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_all.jl#L55-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swptall" href="#WaveletsExt.SWT.swptall"><code>WaveletsExt.SWT.swptall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swptall(x, wt[, L])</code></pre><p>Computes the stationary wavelet packet transform (SWPT) on each slice of signal.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray{T} where T&lt;:Number</code>: Input <code>N-1</code>-D signals, where each signal is sliced at dimension <code>N</code>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>Wavelets.maxtransformlevels(xᵢ)</code>) Number of levels of wavelet transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Array{T}</code>: Slices of transformed signals.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Generate random signals
x = randn(32, 5)
# Create wavelet
wt = wavelet(WT.db4)

# SWPT on all signals in x
xw = swptall(x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.swpt"><code>swpt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_all.jl#L126-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswptall" href="#WaveletsExt.SWT.iswptall"><code>WaveletsExt.SWT.iswptall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswptall(xw[, wt])
iswptall(xw, wt, sm)</code></pre><p>Computes the inverse stationary wavelet packet transform (ISWPT) on each slice of signal.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T} where T&lt;:Number</code>: SWPT-transformed signal.</li><li><code>wt::Union{OrthoFilter, Nothing}</code>: (Default: <code>nothing</code>) Orthogonal wavelet filter.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Array{T}</code>: Slices of reconstructed signals.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Generate random signals
x = randn(32, 5)
# Create wavelet
wt = wavelet(WT.db4)

# SWPT on all signals in x
xw = swptall(x, wt)

# ISWPT on all signals in xw
x̂ = iswptall(xw)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.iswpt"><code>iswpt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_all.jl#L178-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.swpdall" href="#WaveletsExt.SWT.swpdall"><code>WaveletsExt.SWT.swpdall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swpdall(x, wt[, L])</code></pre><p>Computes the stationary wavelet packet decomposition (SWPD) on each slice of signal.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray{T} where T&lt;:Number</code>: Input <code>N-1</code>-D signals, where each signal is sliced at dimension <code>N</code>.</li><li><code>wt::OrthoFilter</code>: Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>Wavelets.maxtransformlevels(xᵢ)</code>) Number of levels of wavelet transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Array{T}</code>: Slices of transformed signals.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Generate random signals
x = randn(32, 5)
# Create wavelet
wt = wavelet(WT.db4)

# SWPD on all signals in x
xw = swpdall(x, wt)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.swpd"><code>swpd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_all.jl#L249-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.iswpdall" href="#WaveletsExt.SWT.iswpdall"><code>WaveletsExt.SWT.iswpdall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswpdall(xw, wt, L, sm)
iswpdall(xw, wt[, L])
iswpdall(xw, wt, tree, sm)
iswpdall(xw, wt, tree)</code></pre><p>Computes the inverse autocorrelation wavelet packet decomposition (ISWPD) on each slice of signal.</p><p><strong>Arguments</strong></p><ul><li><code>xw::AbstractArray{T} where T&lt;:Number</code>: SWPD-transformed signal.</li><li><code>wt::Union{OrthoFilter, Nothing}</code>: (Default: <code>nothing</code>) Orthogonal wavelet filter.</li><li><code>L::Integer</code>: (Default: <code>minimum(size(xw)[1:end-2]) |&gt; maxtransformlevels</code>) Number of levels of wavelet transforms.</li><li><code>tree::BitVector</code>: Binary tree for inverse transform to be computed accordingly.</li><li><code>sm::Integer</code>: If <code>sm</code> is included as an argument, the <code>sm</code>-shifted inverse transform will be computed. This results in significantly faster computation, but fails to fully utilize the strength of redundant wavelet transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Array{T}</code>: Slices of reconstructed signals.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Generate random signals
x = randn(32, 5)
# Create wavelet
wt = wavelet(WT.db4)

# SWPD on all signals in x
xw = swpdall(x, wt)

# ISWPD on all signals in xw
x̂ = iswpdall(xw)
x̂ = iswpdalll(xw, maketree(x))
x̂ = iswpdall(xw, 5)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.iswpd"><code>iswpd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_all.jl#L301-L342">source</a></section></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><h3 id="Single-Step-Transforms"><a class="docs-heading-anchor" href="#Single-Step-Transforms">Single Step Transforms</a><a id="Single-Step-Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Step-Transforms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt_step" href="#WaveletsExt.SWT.sdwt_step"><code>WaveletsExt.SWT.sdwt_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdwt_step(v, d, h, g)</code></pre><p>Perform one level of the stationary discrete wavelet transform (SDWT) on the vector <code>v</code>, which is the <code>d</code>-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors <code>h</code> and <code>g</code> are the detail and scaling filters.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractArray{T} where T&lt;:Number</code>: Array of coefficients from a node at level <code>d</code>.</li><li><code>d::Integer</code>: Depth level of <code>v</code>.</li><li><code>h::Vector{S} where S&lt;:Number</code>: High pass filter.</li><li><code>g::Vector{S} where S&lt;:Number</code>: Low pass filter.</li></ul><p><strong>Returns</strong></p><ul><li><code>w₁::AbstractVector{T} where T&lt;:Number</code> or <code>w₁::AbstractMatrix{T} where T&lt;:Number</code>: Output from low pass filter (1D case); or output from low + low pass filter (2D case).</li><li><code>w₂::AbstractVector{T} where T&lt;:Number</code> or <code>w₂::AbstractMatrix{T} where T&lt;:Number</code>: Output from high pass filter (1D case); or output from low + high pass filter (2D case).</li><li><code>w₃::AbstractVector{T} where T&lt;:Number</code> or <code>w₃::AbstractMatrix{T} where T&lt;:Number</code>: Output from high + low pass filter (2D case).</li><li><code>w₄::AbstractVector{T} where T&lt;:Number</code> or <code>w₄::AbstractMatrix{T} where T&lt;:Number</code>: Output from high + high pass filter (2D case).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
v = randn(8)
wt = wavelet(WT.haar)
g, h = WT.makereverseqmfpair(wt, true)

# One step of SDWT
SWT.sdwt_step(v, 0, h, g)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.sdwt_step!"><code>sdwt_step!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_one_level.jl#L3-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.sdwt_step!" href="#WaveletsExt.SWT.sdwt_step!"><code>WaveletsExt.SWT.sdwt_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdwt_step!(w₁, w₂, v, d, h, g)</code></pre><p>Same as <code>sdwt_step</code> but without array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>w₁::AbstractVector{T} where T&lt;:Number</code> or <code>w₁::AbstractMatrix{T} where T&lt;:Number</code>: Vector allocation for output from low pass filter (1D case); or matrix allocation for output from low + low pass filter (2D case).</li><li><code>w₂::AbstractVector{T} where T&lt;:Number</code> or <code>w₂::AbstractMatrix{T} where T&lt;:Number</code>: Vector allocation for output from high pass filter (1D case); or matrix allocation for output from low + high pass filter (2D case).</li><li><code>w₃::AbstractVector{T} where T&lt;:Number</code> or <code>w₃::AbstractMatrix{T} where T&lt;:Number</code>: Matrix allocation for output from high + low pass filter (2D case).</li><li><code>w₄::AbstractVector{T} where T&lt;:Number</code> or <code>w₄::AbstractMatrix{T} where T&lt;:Number</code>: Matrix allocation for output from high + high pass filter (2D case).</li><li><code>v::AbstractArray{T} where T&lt;:Number</code>: Array of coefficients from a node at level <code>d</code>.</li><li><code>d::Integer</code>: Depth level of <code>v</code>.</li><li><code>h::Vector{S} where S&lt;:Number</code>: High pass filter.</li><li><code>g::Vector{S} where S&lt;:Number</code>: Low pass filter.</li></ul><p><strong>Returns</strong></p><ul><li><code>w₁::AbstractVector{T} where T&lt;:Number</code> or <code>w₁::AbstractMatrix{T} where T&lt;:Number</code>: Output from low pass filter (1D case); or output from low + low pass filter (2D case).</li><li><code>w₂::AbstractVector{T} where T&lt;:Number</code> or <code>w₂::AbstractMatrix{T} where T&lt;:Number</code>: Output from high pass filter (1D case); or output from low + high pass filter (2D case).</li><li><code>w₃::AbstractVector{T} where T&lt;:Number</code> or <code>w₃::AbstractMatrix{T} where T&lt;:Number</code>: Output from high + low pass filter (2D case).</li><li><code>w₄::AbstractVector{T} where T&lt;:Number</code> or <code>w₄::AbstractMatrix{T} where T&lt;:Number</code>: Output from high + high pass filter (2D case).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
v = randn(8)
wt = wavelet(WT.haar)
g, h = WT.makereverseqmfpair(wt, true)
w₁ = zeros(8)
w₂ = zeros(8)

# One step of SDWT
SWT.sdwt_step!(w₁, w₂, v, 0, h, g)</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.sdwt_step"><code>sdwt_step</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_one_level.jl#L51-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt_step" href="#WaveletsExt.SWT.isdwt_step"><code>WaveletsExt.SWT.isdwt_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdwt_step(w₁, w₂, d, h, g)
isdwt_step(w₁, w₂, d, sv, sw, h, g)</code></pre><p>Perform one level of the inverse stationary discrete wavelet transform (ISDWT) on the vectors <code>w₁</code> and <code>w₂</code>, which are the <code>d+1</code>-th level scaling coefficients (Note the 0th level scaling coefficients is the raw signal). The vectors <code>h</code> and <code>g</code> are the detail and scaling filters.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One can decide to choose the average-based inverse transform or the shift-based inverse transform. For shift based, one needs to specify the shifts of the parent and children nodes; for the average based, the output is the average of all possible shift-based inverse transform outputs.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>w₁::AbstractVector{T} where T&lt;:Number</code> or <code>w₁::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients of left child node (1D case); or coefficients from top left child node (2D case).</li><li><code>w₂::AbstractVector{T} where T&lt;:Number</code> or <code>w₂::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients of right child node (1D case); or coefficients from top right child node (2D case).</li><li><code>w₃::AbstractVector{T} where T&lt;:Number</code> or <code>w₃::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients from bottom left child node (2D case).</li><li><code>w₄::AbstractVector{T} where T&lt;:Number</code> or <code>w₄::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients from bottom right child node (2D case).</li><li><code>d::Integer</code>: Depth level of parent node of <code>w₁</code> and <code>w₂</code>.</li><li><code>sv::Integer</code>: Shift of parent node <code>v</code>.</li><li><code>sw::Integer</code>: Shift of children nodes <code>w₁</code> and <code>w₂</code>.</li><li><code>h::Vector{S} where S&lt;:Number</code>: High pass filter.</li><li><code>g::Vector{S} where S&lt;:Number</code>: Low pass filter.</li></ul><p><strong>Returns</strong></p><ul><li><code>v::Vector{T}</code>: Reconstructed coefficients.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
v = randn(8)
wt = wavelet(WT.haar)
g, h = WT.makereverseqmfpair(wt, true)

# One step of SDWT
w₁, w₂ = SWT.sdwt_step(v, 0, h, g)

# One step of ISDWT
v̂ = SWT.isdwt_step(w₁, w₂, 0, h, g)         # Average based
ṽ = SWT.isdwt_step(w₁, w₂, 0, 0, 1, h, g)   # Shift based</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt_step!"><code>isdwt_step!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_one_level.jl#L129-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaveletsExt.SWT.isdwt_step!" href="#WaveletsExt.SWT.isdwt_step!"><code>WaveletsExt.SWT.isdwt_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdwt_step!(v, w₁, w₂, d, h, g)
isdwt_step!(v, w₁, w₂, d, sv, sw, h, g[; add2out])</code></pre><p>Same as <code>isdwt_step</code> but without array allocation.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractArray{T} where T&lt;:Number</code>: Array allocation for reconstructed coefficients.</li><li><code>w₁::AbstractVector{T} where T&lt;:Number</code> or <code>w₁::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients of left child node (1D case); or coefficients from top left child node (2D case).</li><li><code>w₂::AbstractVector{T} where T&lt;:Number</code> or <code>w₂::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients of right child node (1D case); or coefficients from top right child node (2D case).</li><li><code>w₃::AbstractVector{T} where T&lt;:Number</code> or <code>w₃::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients from bottom left child node (2D case).</li><li><code>w₄::AbstractVector{T} where T&lt;:Number</code> or <code>w₄::AbstractMatrix{T} where T&lt;:Number</code>: Coefficients from bottom right child node (2D case).</li><li><code>d::Integer</code>: Depth level of parent node of <code>w₁</code> and <code>w₂</code>.</li><li><code>sv::Integer</code>: Shift of parent node <code>v</code>.</li><li><code>sw::Integer</code>: Shift of children nodes <code>w₁</code> and <code>w₂</code>.</li><li><code>h::Vector{S} where S&lt;:Number</code>: High pass filter.</li><li><code>g::Vector{S} where S&lt;:Number</code>: Low pass filter.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>add2out::Bool</code>: (Default: <code>false</code>) Whether to add computed result directly to output <code>v</code> or rewrite computed result to <code>v</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>v::Array{T}</code>: Reconstructed coefficients.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Wavelets, WaveletsExt

# Setup
v = randn(8)
v̂ = similar(v)
ṽ = similar(v)
wt = wavelet(WT.haar)
g, h = WT.makereverseqmfpair(wt, true)

# One step of SDWT
w₁, w₂ = SWT.sdwt_step(v, 0, h, g)

# One step of ISDWT
SWT.isdwt_step!(v̂, w₁, w₂, 0, h, g)          # Average based
SWT.isdwt_step!(ṽ, w₁, w₂, 0, 0, 1, h, g)    # Shift based</code></pre><p><strong>See also:</strong> <a href="#WaveletsExt.SWT.isdwt_step"><code>isdwt_step</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UCD4IDS/WaveletsExt.jl/blob/d13ba2e2219ecce4732ceb0d06088056cc806087/src/mod/swt_one_level.jl#L205-L256">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acwt/">« ACWT</a><a class="docs-footer-nextpage" href="../tiwt/">TIWT »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 13 November 2021 04:08">Saturday 13 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
